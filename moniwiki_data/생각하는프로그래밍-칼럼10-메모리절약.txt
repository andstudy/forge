'''메모리 절약'''

 메모리 절약.. 術 인가? 略 인가?

 성능과 메모리 소비량의 관계는 반비례?

 {{{ 
 Reverse Trade Off
 }}}

[[TableOfContents]]

= 배경 =
 메모리 절약에 대해 '생각하는 프로그래밍'을 해 보자!
= 메인스트림 =
 {{{ 
 2000개 값이 지도 상의 (x,y) 점과 각각 매칭 된다고 했을때, 메모리 구조에 대한 논의를 해보자!
 }}}
 * 해쉬+링크드리스트
 * 세 개의 배열
 * 키 인덱싱
= '略' =
== 단순함 ==
== 요구사항 == 
 * 순차 탐색해도 될만큼 성능이슈가 적다.
 개발자가 '끼'를 발휘 할 수 있는 발판이기도 하다
== 절충 ==
 Physical 조건과의 절충

= '術' =
== 데이터 공간을 위한 기법 ==
 * 저장하지 말고, 다시 계산하라
 * 키인덱싱
 * 데이터 압축
 * 할당 정책 - 캐시가 잘 사용되도록 할 것인가??
== 코드 공간을 위한 기법 ==
 * 함수 정의 - 인라인,매크로 제거??
 * 인터프리터 - 자바의 태생을 생각해보자
 * 기계어로 변환하기 - 컴파일러가 더 똑똑하다면?

= '略'과 '術' 사이에서 =

 성능과 메모리 소비량 사이에서..

{{{
 그렇다면, 메모리절약을 위해서는 성능을 희생해야하는가?
}}}

 이번 컬럼의 미묘한 관점은 다음과 같이 정리될 수 있을 것이다.

 * 메모리를 많이 사용 해도 성능이 향상 안되는 경우를 피하자!
 * 메모리절약과 성능의 관계가 반비례가 안되는 경우를 찾자!

 '略''略''略''略''略''略''略''略''略''略''略''略''略''略'

= 연습문제 = 

= 메모리 절약을 생각하는 프로그래밍 =
 * 메모리 비용
 * 메모리의 핫 스팟
 * 메모리 측정
 * 트레이드오프
 * 환경에 걸맞게 작업하라
 * 작업에 적합한 방법을 사용하라

= 결론 =
 메모리 절약에 대한 환기는 프로그래머의 뇌에 신선한 충격을 주고, 다양한 상황에 대한 사고를 할 수 있게 하는 '생각하는 프로그래밍'의 한 방법이다.

 '생각하는 프로그래밍' 이 방법론이 될 수 있을까?

{{{
 struct
 {
   int head;
   int body;
   int armor;
   int shield;
   int hair;
   int skin;
 } Protocol
}}}

{{{
 struct
 {
   byte Seed;
 } Magic_Protocol

 int head   = Magic_Rand(Seed);
 int body   = Magic_Rand(Seed);
 int armor  = Magic_Rand(Seed);
 int shield = Magic_Rand(Seed);
 int skin   = Magic_Rand(Seed);
}}}

 수많은 방정식들로 나는 마법사가 된다..
 
 세상엔 Magic 이 있다.

