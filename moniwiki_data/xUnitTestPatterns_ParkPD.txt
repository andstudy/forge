[xUnitTestPatterns] 상위로 가기

== 의견 ==
베타리더 분들이 올려주신 내용 + 제가 수정했으면 하는 내용을 정리해서 여기에 올리도록 하겠습니다.
 제가 먼저 쭉 본 다음에, 베타리더님들 의견을 반영하도록 하겠습니다. 
 많은 분들의 소중한 의견 감사합니다. 계속 잘 부탁드립니다.

== 전체 ==
 * 원문 -> 수정본 으로 표시했습니다.
 * 패턴, 원칙 이름은 고딕체 등으로 표기
  * 용어에 있는 패턴 목록, 냄새 목록, 목표, 원칙, 테스트 리팩토링(부록 A), 부록 B, 부록 E, 부록 F, 부록 G 에 있는 단어들을 고딕체로 표시해 주시면 됩니다.
 * 서문등에 표시된 페이지가 숫자로 나와 있을 경우, 본문의 페이지 숫자와 헤갈릴 수 있습니다. 원서처럼 로마숫자표기법으로 보여주든지 등의 대책이 필요합니다.
 * ... 으로 표시한 부분은 원문과 수정본이 "서로 같은 부분" 입니다. 이 부분은 무시해 주세요.
 * 제목, 소제목 에도 필요하면 영어 병기 부탁드립니다.
 
== 인덱스 관련 ==
 * 개인적으로는 인덱스 없어도 되지 않을까 싶습니다.(부록이 워낙 잘 되어 있어서...)
 * 하지만 필요하다면 고딕체로 표시되는 단어들을
  * 한 번은 A-Z 순으로, 한 번은 ㄱ-ㅎ 순으로 정렬해서 보여주면 될 거 같습니다.
  * 페이지 번호는 이미 부록 같은 데에 다 표시되어 있으니까 그걸 그대로 보여주면 됩니다.

=== 용어 변경 ===
 * 회기 테스트 -> 회귀 테스트
 * 파사드 -> 퍼사드 
 * 묵시적<Implicit> -> 암묵적
 * 연결 테스트 -> 엮인 테스트
 * 불쌍한 사람의 -> 얼렁뚱땅
 * 여린 테스트 -> 깨지기 쉬운 테스트
 * 테스트 조건문 로직 -> 테스트 내 조건문 로직
 * 피하 테스트 -> 피하(皮下) 테스트 (한자는 영문 병기할 때에만 같이 보여줘도 될 거 같습니다)
 * 테스트 대역 -> 테스트 대역(代役) 
 * 커맨드라인 -> 명령행<Command-Line>
 * 다시 로드<reload> -> 리로드<reload>
 * 메소드 속성 -> 메소드 어트리뷰트
 * <> 는 거의 대부분 병기표시입니다. 예 : p.111 에서 <> 를 제거하고 대신 영문 병기해 주세요.
 * 렉<lack> -> 랙<lack>
 * 잘라 붙이기, 복사하고 붙이기 -> Copy & Paste
 * 페인<pane> -> 창
 * 어트리뷰트가 속성으로 많이 바뀌어 있습니다. 멤버변수 등의 의미로 쓰이는 경우에는 속성으로 써도 괜찮을 거 같지만, 어노테이션과 비슷한 의미로 쓰일 경우 등에는 어트리뷰트를 그대로 가져가야 하지 않을까 생각합니다. 어떤가요?
 * 게으른 -> 지연
  * 게으른 설치 -> 지연 설치
  * 데코레이트되는 게으른 설치 -> 데코레이트되는 지연 설치
  * 게으른 초기화 -> 지연 초기화
  * 게으른 해체 -> 지연 해체
 * 지속 레이어 -> 영속성 레이어
  * 지속 레이어 테스트 -> 영속성 레이어 테스트
 * 설정 가능한 테스트 대역 -> 설정되는 테스트 대역(으로 통일해 주세요)
 * 코드 패스 -> 코드 경로(로 통일)
 * 단단 -> 견고

=== 고민 중입니다 ===
 * 동력<force> -> 동기<force>
 * 맞춤 단언문 -> 사용자 정의 단언문
 * 속성?? 어트리뷰트??

== 추천사 ==
p.2
사실이긴 해도 핵심을 -> 사실일지는 몰라도 핵심에는
xUnit 도구와 더 중요하게는 xUnit의 철학은 -> xUnit 툴과 철학은

p.3
밥 마틴Bob Martin에게서 이 책을 빼앗아오기 위한 작전을 펼쳐야 했습니다 -> 온갖 수를 다 써서 이 책을 밥 마틴Bob Martin 시리즈로부터 빼내왔습니다

== 서문 ==
p.37
모든 독자에게는 몇 시간 아니 밤새 디버깅해본 기억이 있을 것이다. 프로그래머라면 누구든지 버그를 찾느라 하루 종일(아니면 그 이상으로) 고생한 얘기쯤은 하나씩 갖고 있다.
-> 프로그래머라면 누구나 몇 시간, 아니 밤새 디버깅 해 봤을 것이고, 이런 힘든 디버깅에 대한 무용담 쯤은 하나씩 늘어놓을 수 있다.

p.38
찾아봤다. 사전 -> 만들어 보았다. 먼저, 사전
모르는 사이에 필요에 의해 -> 하다보니 나도 모르게

p.39
그것도 빨리 -> 그것도 당장
메소드들로 뽑아내는 -> 메소드로 뽑아내는

p.40
유일 키 -> 유일 키<unique key>
집어넣으려다 테스트가 실패해 -> 집어넣으려다가 실패하는 테스트에
현재 여린 테스트<Fragile Test>라 부르는 -> 지금은 깨지기 쉬운 테스트<Fragile Test>라고 부르는
발견한 것은 그 -> 발견한 것은 그 당시의
일어날 수 있었던 -> 앞으로 일어날 수 있었던
맞추지 못했을 수도 있었다 -> 맞추지 못했을지도 몰랐다

p.41
프로그래밍을 해왔고, 단위 테스트를 -> 프로그래밍을 해왔었지만, 단위 테스트를 

p.42
Rick Mugridge -> 릭 머그리지<Rick Mugridge>
Ward Cunningham -> 워드 커닝햄<Ward Cunningham>

== 소개 ==
p.46
그렇다면, 소프트웨어 개발자가 -> 소프트웨어 개발자가

p.47
따로 테스트하는 걸 좋아한다 -> 따로 테스트하는 걸 선호한다

p.48
거의 실패한다 -> 거의 언제나 실패한다
어떤 종류의 사용자 인터페이스든지 문제는 -> 모든 사용자 인터페이스에서 이런 문제가

p.50
전혀 다른 방식으로 -> 전혀 다르게
대부분의 사람은 여러 개의 일을 ... 한 가지 일에만 -> 여러 일을 ... 하나의 일에만
알 수 있게 된다 -> 알 수 있다

p.51
모든 기법에 전부 동의하는 건 아니었지만 -> 동의하지 않는 기법에 대해서도 

p.56
5. 켄트 벡(Kent Beck)이 할머니에게 “기저귀를 언제 갈아줘야 하는지 어떻게 알 수 있을까요?”라고 묻자, 할머니는 “지린내가 나면, 그때 바꾸렴!”이라고 대답했다 한다. 냄새들은 지린내의 원인이 아닌 ‘지린내’로부터 이름을 지었다.
-> 켄트 벡<Kent Beck>이 "기저귀를 언제 갈아줘야 할까요?" 라고 묻자, 할머니가 "지린내가 날 때지!<If it stinks, change it!>" 라고 대답했다고 한다. 냄새의 이름은 지린내의 원인이 아닌 ‘지린내<stink>’로부터 따왔다.

p.57
자동 테스트용 자동 테스트가 -> 자동 테스트를 테스트하는 자동 테스트가
실수를 했기 때문일까 -> 생긴 실수 때문일까

p.58
건너뛸 수 있는 절[PLOPD3] -> 건너뛸 수 있는 절<Skippable Sections>[PLOPD3]
SUT에 들어가진 않아도 ... 부분들이 있다. 전자를 '의존... 라 하고, 둘 다 -> SUT 에 포함되진 않지만 ... 부분을 '의존 ... 라 한다. SUT 와 DOC 둘 다 

p.59
기반 언어의 특성을 인해 필요한 -> 해당 언어의 특징에 맞추기 위해 꼭 필요한
얘기하고 해당 xUnit 프레임워크 -> 얘기하고, 다른 해당 xUnit 프레임워크

p.60
무시해 버린다 -> 무시당하기 일수다

p.61
여러분에게서 그런 얘기를 듣고 싶다! -> 그런 얘기가 있다면 언제든지 들려주길 바란다!

p.63
둘 사이의 생산성 차이가 엄청날 수도 있다! -> 이들 생산성에는 엄청난 차이가 있다!
과정을 알려준다 -> 과정을 보여준다

궁극적으로는 이 글을 읽고 난 뒤 여러분이 좀 더 테스트에 많은 호기심을 가졌으면 한다.
-> 이번 예제가 여러분의 테스트에 대한 지적 욕구를 자극하길 바란다.

p.66
단언문이 고치기 -> 단언문은 고치기
그렇게 할 예정이면 바로 그렇다고 해주는 게 낫지 낳을까? -> 그럴거라면, 바로 실패시켜버리는 게 낫다.
대신 이런 호출을 캡슐화한 좀 더 의도가 드러나는 -> 을 캡슐화해서 좀 더 의도가 잘 드러나는

p.68
이 코드에서 line item 이 ... 있다. -> 이 코드의 의도는 line item 이 ... 같음을 보여주는 데 있다.

p.71
.. 가 있다는 것이다. -> .. 에 있다.
지금 방식이 그다지 효과적이지 않을 것이라는 점은 분명하다. -> 당연히 지금 방식은 효과적이지 않다.

p.72
필요하게 된다 -> 필요하다
대신 할 수 있게 할 수 있다. -> 대신 시키자. 
삭제하게 하는 방법을 추가할 수 있다. -> 삭제할 수 있게 만들면 된다.
등록해야 한다. -> 등록하자.

p.75
~에 대해 메소드 뽑아내기<Extract Method> 리팩토링으로 -> ~에 메소드 뽑아내기<Extract Method> 리팩토링을 해서
장점도 생긴다. -> 장점도 있다.

p.76
여러 문제가 있다. 첫 번째 문제는 ... 어렵다는 점이다. -> 문제가 많다. 먼저, ... 어렵다.
고객customer의 어딘가에서 결과에 어떤 식으로 영향을 미치고 있을까? 고객customer의 주소로
인해 결과가 달라지나?
-> 고객<customer> 의 주소나 다른 값이 결과에 어떤 식으로든 영향을 미치는가?
또 다른 문제는 테스트에 ... 있다는 점이다. -> 테스트에 ... 있는 것도 문제다.
만들어주면 -> 만들어
이 방법을 쓰면 ... 다른 객체를 생성하게 할 수 있다 -> 이렇게 하면 ... (고유 값이) 다른 객체를 생성할 수 있다

p.77
아예 숨길 수 있다 -> 아예 숨겨보자

p.78
테스트 하네스 안에 -> 테스트 하네스<harness> 안에

p.79
(price * quantity) -> (가격 * 수량)
무엇을 검증하려는지 찾았는가? -> 검증하려는 것이 무엇인지 알겠는가?

p.80
재사용할 수 있다. -> 재사용하면 된다.

p.81
만들면 된다. -> 만들자.

== 1장 ==
p.3
이 책에는 수많은 규칙, 패턴, 냄새들이 있다. 이 책에
-> 이 책에서는 수많은 규칙, 패턴, 냄새들을 다룬다. 심지어 이 책에

분명 통하는 가장 간단한 테스트 자동화 전략
-> 가장 확실하면서도 간단한 테스트 자동화 전략

이 모든 걸 다 배워야 할까? 이 모든 걸 다 사용해야 할까? 분명 아니다.
-> 그렇다고 모든 것을 다 배우고, 써 먹어야 한다는 건 아니다.

여기에서 보여주는 원칙, 패턴, 냄새들은 오랜 기간동안 우리에게 도움이 될 핵심 패턴들이다.
-> 여기에서 보여주는 원칙, 패턴, 냄새들은 장기적으로 도움이 될 것이다.

다른 대안 패턴들에 의지할 수 있다.
-> 다른 대안 패턴들도 확인해 보자.

p.4
개발 프로세스 : 코드 개발에 사용하는 프로세스가 테스트에 어떻게 영향을 미치는가?
고객 테스트 :“뭐가 어떻게 돼야 한다”를 절대적으로 정의하는 가장 먼저 작성해야 하는 테스트
단위 테스트 : 설계가 점진적으로 나타날 수 있게 해주고 전체 코드가 전부 테스트될 수 있게 해주는 테스트
테스트하기 쉬운 설계 : 설계를 테스트하기 쉽게 해주는 패턴 덕분에 테스트 자동화 비용이 줄어든다.
테스트 조직 : 테스트 메소드(348 페이지)와 테스트케이스 클래스(373 페이지)를 어떻게 조직할 것인가?

->
개발 프로세스 : 코드 개발에 사용되는 프로세스가 테스트에 미치는 영향
고객 테스트 :“무엇이 어떻게 돼야 한다”에 대한 궁극적인 정의로써 가장 먼저 작성해야 하는 테스트
단위 테스트 : 설계가 점진적으로 나타날 수 있게 해주고, 전체 코드가 전부 테스트될 수 있게 해주는 테스트
테스트하기 쉬운 설계 : 설계를 테스트하기 쉽게 만들어, 테스트 자동화 비용을 줄여주는 패턴들
테스트 구성 : 테스트 메소드(348)와 테스트케이스 클래스(373)를 구성하는 방법

특히, 성공했을 때 어떻게 되어야 하는지에 대해 합의된 정의를 얻을 수 있다.
-> 특히, 어떤 상태를 성공이라고 할지에 대한 의견 일치를 볼 수 있다.

소프트웨어 전체가 테스트 될 수 있도록 단위 테스트를 추가해서 코드의 전체 패스나, 적어도 고객 테스트가 처리하지 못하는 코드 패스를 다 검증할 수 있도록 한다.
-> 소프트웨어의 전체 실행 경로나, 적어도 고객 테스트가 처리하지 못하는 코드 실행 경로에 대해 단위 테스트를 추가해 소프트웨어를 구석구석 검증한다.

이 코드에 맞춰 단위테스트를 -> 이 코드에 맞는 단위테스트를

빠진 단위 테스트(Missing Unit Test, 제품 버그. 268 페이지) -> 빠진 단위 테스트<Missing Unit Test> (제품 버그. 268)

소프트웨어를 개발하기 전에 고객이 테스트를 정의하지 못한다면, 충분히 걱정되는 상황이다!
-> 소프트웨어를 개발하기 전에 고객이 테스트를 정의할 수 없다면, 이미 문제가 있다.

p.5
스모크 테스트<SCM> 안에
-> 스모크 테스트[SCM] 안에(박일 : 원문 느낌대로 대괄호를 붙여주세요)

테스트 주도 개발<Test-Driven Development, TDD>을 하면 소프트웨어를 테스트 가능하게 할 수 있다. 코드를 작성하기 전에 먼저 단위 테스트를 작성 하고 덕분에 소프트웨어 설계에 도움을 얻을 수 있다. 이러한 전략은 데이터베이스에 독립적인 테스트를 위해 잘 정의된 객체를 통해서 검증이 필요한 비지니스 로직에 집중 하도록 도움을 준다.
-> 테스트 주도 개발<Test-Driven Development, TDD>을 하면 소프트웨어를 테스트 가능하게 할 수 있다. 코드를 작성하기 전에 먼저 단위 테스트를 작성하고, 여기에서 소프트웨어 설계를 이끌어낸다. 덕분에 데이터베이스와는 별개로 테스트할 수 있는 잘 정의된 객체와 함께 비지니스 로직에만 집중할 수 있다.

고객 테스트는 고객이 시스템에서 해주기는 기대하는 내용에 대한 핵심을 담고 있어야 한다.
-> 고객 테스트에는 고객이 시스템에 무엇을 기대하는지에 대한 핵심이 들어 있어야 한다. 

p.6
테스트 계획의 일환으로 테스트 픽스처test fixture라는 시작 위치를 각 테스트가 시작할 때마다 설치하게 한다.
-> 모든 테스트에는 시작 위치가 필요하다. 먼저 테스트 픽스처<fixture>라는 시작 위치를 각 테스트가 시작할 때마다 설치한다.

같은 걸 써서 서로를 격리시킬 필요가 있다 
-> 같은 것으로 서로를 격리시키는 게 좋다

이것은 테스트 냄새가 나는 서로 반응하는 테스트가 변장한 것일 뿐이다.
-> 연결 테스트는 결국에는 테스트 냄새가 나는 서로 반응하는 테스트다.

p.7
각 테스트 메소드는 최소 픽스처<Minimal Fixture>(302페이지)를 만들기 위해 위임 설치<Delegated Setup>(411 페이지)를 쓸 수 있다.
-> 각 테스트 메소드는 위임 설치<Delegated Setup>(411 페이지)로 최소 픽스처<Minimal Fixture>(302페이지)를 만든다.

테스트가 쉽게 이해될 수 있게 한다 -> 테스트를 쉽게 이해할 수 있게 한다

테스트에서는 하나 이상의 기대 객체 ->하나 이상의 기대 객체

이때에는 모의 객체 -> 이럴때는 모의 객체

비즈니스 로직을 테스트하기 쉽게 하기 위해 적어도 -> 비즈니스 로직을 테스트하기 쉽게 하려면, 적어도

이런 방식은 런타임 환경에서 가비지 컬렉션 해체<Garbage-Collected Teardown>(500 페이지)를 하게 한다.
-> 이러면, 런타임 환경이 알아서 가비지 컬렉션 해체<Garbage-Collected Teardown>(500 페이지)를 하게 만들 수 있다.

p.8
테스트 대역을 사용하게 될 것이다. -> 테스트 대역을 사용한다.

테스트 대역을 런타임에 설치하기 위해 의존 주입Dependency Injection이나 의존 찾기Dependency Lookup(686 페이지), 상속받은 싱글턴Subclassed Singleton(테스트용 하위클래스, 579 페이지) 등을 사용할 수 있다.
-> 의존 주입Dependency Injection(678)이나 의존 찾기Dependency Lookup(686), 상속받은 싱글턴Subclassed Singleton(테스트용 하위클래스, 579) 등을 써서 테스트 대역을 런타임에 설치할 수 있다.

테스트케이스 클래스에 테스트 메소드가 너무 많아진다면 테스트를 통해 클래스를 검증하려는 메소드(혹은 기능)나 필요한 픽스처에 따라 나눌 수 있다.
-> 테스트케이스 클래스에 테스트 메소드가 너무 많아지면, 검증하려는 메소드(혹은 기능)나 필요한 픽스처별로 클래스를 나눌 수 있다.

p.9
바로 넘어갈 수 있다. -> 바로 넘어가자.

== 2장 ==
p.11
리팩토링 3장은 "기저귀를 언제 갈아줘야 하는지 어떻게 알 수 있을까요?" 라는 질문에 할머니 벡의 유명한 대답인 "지린내가 나면, 그때 바꾸렴!" 으로 시작한다.
-> 리팩토링 3장은 "기저귀를 언제 갈아줘야 할까요?" 라는 질문에 켄트백의 할머니가 "지린내가 날 때지!<If it stinks, change it!>" 라고 대답하면서 시작한다. 

p.12
일부를‘원인’상태로 강등시켰다 -> 일부는‘원인’으로 강등시켰다

p.13
최근에 나는 제3의 냄새를 발견했다. 이 냄새는 ... 맡게 된다.
-> 최근에는 제3의 냄새를 발견했는데, 이 냄새는 ... 맡는다.

예를 들어, 프로젝트 냄새는 어떤 근원적인 원인이 프로젝트 수준에서 나타나는 증상이다.
-> 예를 들어, 프로젝트 냄새는 프로젝트 수준에서 숨어있는 원인 때문에 생기는 증상이다.

p.14
냄새를 피할 수 있다고 한다. -> 냄새를 피할 수 있다.

살펴볼 때 중요한 것은 냄새와 동시에 그 냄새의 증상도 같이 살펴본다는 점이다.
-> 살펴볼 때는 냄새와 동시에 그 냄새의 증상도 같이 살펴봐야 한다.

냄새로 알 수 있음sniffability -> 냄새맡기sniffability

p.15
냄새를 통해 관리자는 테스트 자동화가 완벽함에서 멀어지고 있다는 사실을 알 수 있는 힌트를 얻을 수 있다.
-> 냄새를 통해서 관리자는 테스트 자동화가 완벽함에서 멀어지고 있다는 힌트를 얻을 수 있다.

있다는 사실을 알 수 있는 힌트를 얻을 수 있다 -> 있는지에 대한 힌트를 얻을 수 있다

“왜 버그가 자동 테스트 안전망을 통과해 나올 수 있었나?”를
-> "어떻게 이렇게 많은 버그가 자동 테스트 안전망을 통과할 수 있었는지" 를

유지비용이라는 훨씬 일반적인 문제를 -> 유지비용이라는 문제를

관리자가 “테스트 만든다고 시간 낭비하지 마라”" 로 얘기하거나
-> 관리자가 "테스트 작성에 시간 낭비하지 마라" 고 한다던가

발생할 수 있다 -> 생길 수 있다

동작 냄새 -> 작동 냄새

p.18
발생한다 -> 생긴다

어렵게 된다 -> 어렵다

수동 조정을 해줘야 -> 수동 조정을 해야

p.19
초기 경고 역할도 -> 조기 경고 역할도

p.20
가장 잘 나타난다 -> 잘 생긴다

(많은 클래스로 만들어진 더 큰 SUT) -> (여러 클래스로 되어 있는 훨씬 큰 SUT 를)

제품 코드 내 테스트 로직<Test Logic in Production>(217 페이지)는
-> 제품 코드 내 테스트 로직<Test Logic in Production>(217 페이지)은

Ariane(218 페이지)에 관련된 -> Ariane(218 페이지)에서 관련된

== 3장 ==
p.21
이 부분은 이런 목표들을 여러 원칙과 패턴의 근본 이유로 삼는 장들에서 다룬다.
-> 이 부분은 뒤에서 따로 자세히 다루기로 한다.

p.24
품질보증(QA) -> 품질보증(quality assurance. QA)

p.25
왜 잘 돌아가지 않는지 이유를 알려준다. 이런 현상을 -> 왜 잘 돌아가지 않는지를 알려준다. 이것을
있다는 걸 알 수 있다 -> 있는 것이다
하는 것은 무척 중요한다 -> 하는 것이 굉장히 중요하다

p.26
를 위한 단위 테스트는 -> 에 대한 단위 테스트는

소프트웨어의 품질을 향상시킨다. 이것은 분명 위험 감소의 한 형태다.
-> 소프트웨어의 품질을 향상시켜 위험을 감소시켜준다.

위험 감소의 다른 형태는 전체 애플리케이션을 하나의 블랙박스로 보고 테스트하는 전통적인 고객 테스트에서는 ‘불가능한’ 상황에서 소프트웨어 동작을 검증해보는 것에서 나타난다.
-> 또한 전체 애플리케이션을 하나의 블랙박스로 보고 테스트하는 전통적인 고객 테스트에서는 "불가능한" 소프트웨어 동작을 검증해줌으로서 위험을 줄여준다.

p.27
뭔가를 변경하기 전에 수동으로 오랫동안 분석해야 한다.
-> 뭔가를 변경하기 전에 한줄한줄 오랫동안 분석해야 한다.

p.29
덕분에 깨끗하게 성공한 테스트의 경우에는 아무런 일이 없다. xUnit 계통의 여러 프레임워크가 모든 것이 "문제 없음" 을
-> 덕분에 테스트가 깨끗하게 성공했다면 따로 해 줄 일이 없다. 여러 xUnit 프레임워크에서 전부 "문제 없음" 을

p.30
모든 개발자가 굉장히 자주(매번 코드를 저장할 때마다) 테스트를 실행시킬 수 있게 하고 싶기 때문에 이러면 곤란하다. 반복 안 되는
-> 테스트는 최대한 자주(매번 코드를 저장할 때마다) 실행할 수 있어야 한다. 하지만 반복 안 되는

반본 안 되는 -> 반복 안 되는
찾는 데 노력이 더 든다. -> 찾는 노력이 더 든다.

p.31
자동 테스트 자체를 테스트하는 게 복잡한 일이므로 테스트는 읽고 이해하기 쉬워야 한다. SUT에서 찾고자 의도한 바로 그 버그만 다뤄야 제대로 테스트될 수 있다. 이것을 자동화된 방식으로 하기란 어렵기 때문에 보통은 딱 한 번, 처음 테스트가 작성됐을 때에만 하게 된다. 이런 이유로 눈에 의지해 테스트에 슬금슬금 생길 수 있는 어떤 문제라도 찾을 수 있어야 하고, 이렇게 하려면 테스트를 빨리 읽을 수 있도록 충분히 쉽게 유지해야 한다

-> 자동 테스트는 테스트하기 어렵기 때문에, 읽고 이해하기 쉬워야 한다. 테스트가 찾아내야 하는 바로 그 버그를 SUT 에 집어넣었을 때에만 자동 테스트를 제대로 테스트할 수 있기 때문에, 이런 과정을 자동으로 하기는 어렵고, (그나마도 한다면) 보통 딱 한 번 테스트를 처음 작성할 때에만 테스트를 제대로 작성했는지를 테스트한다. 따라서 나중에는 슬슬 테스트에 문제가 생기지 않았는지는 눈으로 알 수 있어야 하는데, 그럴려면 테스트를 빨리 읽을 수 있도록 쉽게 유지해야 한다.

너무 많은 기능을 하나의 테스트에서 전부 검증하려 든다.
-> 너무 많은 기능을 하나의 테스트에서 한꺼번에 검증하려 든다.

p.32
하지만 반대 세력도 있다. 테스트는 의도를 나타내야 하므로 핵심 테스트 코드를 테스트 메소드 내에 같이 둬야 한눈에 보기 좋다는 것이다. 하지만 SUT에 변경이 발생했을 때 한 곳만 고치면 되게 하려고 많은 지원코드<supporting code>를 테스트 유틸리티 메소드로 옮기는 것을 막는 건 아니다.
-> 하지만 반대로 테스트는 의도를 나타내야 하므로, 핵심 테스트 코드를 테스트 메소드 안에 같이 두면 한눈에 보기 좋은 면도 있다. 그렇다고 해서, SUT에 변경이 생겼을 때 한 곳만 고치면 되도록 여러 지원코드<supporting code>를 테스트 유틸리티 메소드로 옮기는 것을 막는 건 아니다.

(테스트 로직을 제품 코드에 넣지 마라 원칙(45 페이지)) -> (테스트 로직을 제품 코드에 넣지 마라)
(따로 테스트하라 원칙(47 페이지)) -> (따로 테스트하라)

p.33
테스트는 시스템이 발전해 나감에 따라 필요한 유지 보수 비용이 최소화돼야 한다
-> 시스템이 발전하는 동안 테스트에 필요한 유지 보수 비용이 최소화돼야 한다

이런 테스트들이 우리가 변경을 하는데 도움이 되는가? -> 이런 테스트들이 변경에 도움이 된다고 할 수 있을까?

이를 위해서는 테스트 사이의 겹침이 최소가 되게 해야 한다.
-> 그럴려면 테스트끼리 최대한 적게 겹쳐야 한다.

== 4장 ==
p.36
얘기할 때 나오게 된다. -> 얘기할 때 나온다.

왜 그리 중요하냐고? -> 뭐 그리 중요하냐고?

소프트웨어가 ‘작성이 끝난’-> 소프트웨어 '작성이 끝난'

p.37
튼튼해진다 -> 견고해진다

이런 때는 Brian Marrick이 말한 대로 화제를 ‘예제’와 예제 주도 개발example-driven development, EDD에 대해 얘기하는 걸로 바꾼다.
-> 이럴 때는, 브라이언 메릭<Brian Marrick> 의 제안대로, '예제' 와 예제 주도 개발example-driven development, EDD 로 바꿔서 얘기해 보자.

p.38
테스트 주도 개발 프로세스는 -> 테스트 주도 개발 프로세스에서는

많은 테스트 실행 담당자는 -> 여러 테스트 실행 담당자들이

적절한데, 그 이유는 객체나 -> 적절하다. 객체나

p.39
이런 방식을 쓸 경우 안쪽 소프트웨어를 위한 테스트를 작성할 때 바깥쪽 소프트웨어의 요구 사항을 예상해야 한다. 그리고 바깥쪽 소프트웨어가 안쪽 소프트웨어와는 독립적으로 테스트되지 않음을 의미한다.
-> 이런 방식에서는 안쪽 소프트웨어를 위한 테스트를 작성할 때 바깥쪽 소프트웨어의 요구 사항을 예상해야 할 뿐만 아니라, 테스트할 때도 바깥쪽 소프트웨어가 안쪽 소프트웨어에 종속된다는 점을 감안해야 한다.

p.40
테스트 대역<Test Double>을 -> (박일 : <> 는 병기표시입니다)

p.42
1. 예를 들어 -> 1. 예 :

p.43
코드 커버리지를 더 좋게 하기 위해 -> 코드 커버리지를 높히기 위해

내가 어떤 철학을 갖지고 -> 내가 어떤 철학을 가지고

== 5장 ==
p.45
차이점을 살펴봤다. 또한 경험 많은 -> 차이점과, 경험 많은 
배경도 제공했다. -> 배경을 알아보았다.

‘원칙’이라는 단어를 사용한 이유는 2가지인데, 우선 패턴이라고 하기엔 너무 고차원적이고 모두가 공감하진 않는 가치 체계이기 때문이다. 가치 체계가 다르면 이 책에 있는 어떤 패턴이 아닌 다른 패턴을 선택하게 될 수도 있다. 이런 가치 체계를 분명하게 하면 어디에서 의견이 다르고 이유는 무엇인지 이해하는 과정을 가속시킬 수 있을 것이라 생각한다.

-> ‘원칙’이라는 단어를 사용한 이유는, 이를 패턴이라고 하기엔 고차원적인데다가 모두가 공감할 수 있는 가치 체계가 아니기 때문이다. 가치 체계가 다른 사람은, 패턴도 이 책에 있는 것과는 다른 패턴을 선택할 수 있다. 이런 가치 체계를 분명하게 하면, 우리가 어디에서 의견이 다른지, 그 이유는 무엇인지를 더 빨리 이해할 수 있을 거라고 생각한다.

p.46
원칙에는 명령형 이름을 붙였다.
-> 원칙에는 명령형 이름을 붙였다.(역주 : 원문과는 원칙을 인용할 때 항상 명령형을 썼지만, 번역문에는 문맥에 맞춰서 약간씩 변형한 곳도 있습니다)

디버깅에 필요한 노력을 충분히 벌충해준다.-> 디버깅에 드는 노력을 충분히 보상한다.

작성하면 자연히 코드를 테스트하기 쉽게 설계하게 해준다.
-> 작성하다보면, 저절로 코드를 테스트하기 쉽게 설계하게 된다.

p.48
DOC에 호출한 결과를 -> 의존 컴포넌트<depended-on component, DOC>에 호출한 결과를

p.48
충분한 것은 아니다 -> 충분하진 않다
너무 많은 코드(1)가 있거나 ... 들어있는 테스트는 보통 애매한 ... -> 테스트에 코드가 너무 많거나(1) ... 들어있다면 대부분이 애매한 ...
문서로 사용하기 위해 테스트를 다시 -> 문서삼아 다시
들어내면 -> 드러내면

p.49
꼭 교체해야 한다면 원래 돌아가던 방식 그대로 돌아간다는 걸 
-> 꼭 교체해야 한다면 SUT 가 원래대로 실행된다는 걸

그렇지 않다면 테스트한다고 생각하는 SUT의 부분을
-> 그렇지 않다면 테스트하려고 했던 SUT를

테스트한다고 생각하는 SUT의 부분을 -> 테스트하고자 했던 SUT 를
이런 점은 ... 특히 그렇다. -> 특히 ... 주의해야 한다.
있게 만들려고 -> 있게 하려고
두는 게 일반적이다. -> 두는 게 보통이다.

이렇게 여러 테스트를 ... 비효율적이다.
-> 여러 테스트에서 시스템의 시작 상태를 설정하는 단계를 반복해 줘야 하는데, 이런 작업을 수동으로 하기에는 비효율적이기 때문이다.

양쪽 테스트가 전부 실패할 때 구별할 수 없다. -> 테스트가 둘 다 실패하면, 이를 구별할 수 없다.
집어낼 수 있게 도와준다. -> 집어낼 수 있다.
소프트웨어의 일부분은 -> 일부 소프트웨어는 
소프트웨어의 대부분은 -> 대부분의 소프트웨어는 

p.50
게다가 테스트하는 주체가 사람이므로 테스트가 실패했을 때 ... 알 수 있다.
-> 게다가 사람이 테스트하기 때문에 실패한 테스트를 보고 ... 판단할 수 있다.

p.51
서로 테스트를 독립적으로 -> 테스트를 서로 독립적으로

단단하게 만들 수 -> 견고하게 만들 수

커버리지를 ... 들릴 수 있다. -> 커버리지를 향상시키고자 하는 사람에게는 이게 무슨 소리인가 싶을 것이다.
실패할 때 전부 실패한다. -> 실패할 때 다 같이 실패한다.

p.52
테스트할 수 없는 코드는 ... 막을 수 없게 만든다. 
-> 테스트할 수 없는 코드가 있다면, 눈에 잘 보이지 않는 사악한 버그가 완전 자동 테스트를 피해 코드에 들어오는 걸 막을 수 없다.

테스트 메소드조차도 자신의 테스트 불가능한 코드를 테스트 유틸리티 메소드로 뽑아내면 테스트할 수 있다.
-> 테스트 메소드조차도 테스트 유틸리티 메소드로 뽑아내면 스스로를 테스트할 수 있다.

p.53
더 심하게는 테스트 훅이 실제 제품 소프트웨어가 실패하게 만들 수도 있다.
-> 심지어 테스트 훅 때문에 제품 소프트웨어에서 문제가 생기기도 한다.

SUT가 처음 상태가 아닌 다른 상태가 된다. -> SUT 의 상태가 변경된다.

있으므로 굉장히 관심이 갈 수 있다 -> 있다는 점에서 매력적이다.

각 스크립트 기반 테스트는 -> 각 스크립트 기반 테스트<Scripted Test> 에서는

p.54
프로그램은 픽스처를 -> 컴퓨터는 픽스처를 

검증하는 내용에 따라 이름을 정하는 곳에서 나올 수 있다
-> 검증하는 내용에 따라 이름을 정할 때 나올 수 있다

== 6장 ==
p.57
이전 장들에서는 -> 이전 장에서는

테스트 전략을 픽스처 설치보다 먼저 다루지만 사실은 테스트 전략이 좀 더 고급 주제다.
-> 흐름상 테스트 전략을 픽스처 설치보다 먼저 다루고 있지만, 사실 테스트 전략이 좀 더 어려운 고급 주제다.

경험이 부족하고 테스트 전략을 -> 경험이 부족한 상태에서 테스트 전략을

노력이 필요할 수 있다 -> 노력이 필요하다

p.58
접근법을 취하라고 ->를 하라고

이 책에서 다루는 전략과 더 상세한 패턴들은 사용하려는 어떤 종류의 테스트 자동 프레임워크(298 페이지)에서든 동일하게 적용할 수 있다.
-> 이 책에서 다루는 전략과 세부 패턴들은 어느 테스트 자동 프레임워크(298 페이지)에서나 동일하게 적용할 수 있다.

먹을 수 있다는 점을 잊지 말자. -> 먹을 수 있다.

p.59
Component Tests : 컴포넌트 테스트
Architect Inten : 아키텍트의 의도
(Design of the System) : (시스템 설계)
Support Development : 개발 지원
Critique Product : 제품 평가
Business Facing : 사업적인 측면
Technology Facing : 기술적인 측면

p.60
자동화는 ... 핵심이다.
-> 고객 테스트 자동화는 개발자가 한다. 하지만, 고객 테스트의 핵심은 테스트를 읽지 못하는 최종 사용자<end user>도 테스트에 명시된 동작을 알아볼 수 있어야 한다는 데 있다.

단위 테스트는 개발자가 스스로 필요에 의해 작성한다
-> 단위 테스트는 개발자가 스스로 필요해서 작성한다. 단위 테스트를 만들면 단위의 특정 동작이 "어떻게 되어야 하" 는지를 테스트 형태로 요약할 수 있다.

캡슐화돼 있는 경우가 아니라면 -> 캡슐화된 경우가 아니라면

제공하는 클래스들의 -> 제공하는 클래스의

통합 테스트<integration tests> -> 통합 테스트<integration test>

테스트' 하는 것과는 완전히 -> 테스트' 라는 컴포넌트 테스트와는 전혀

p.61
‘비기능적nonfunctional’ 또는 ‘기능 외extrafunctional’나 ‘교차 기능적cross-functional’
-> ‘비기능nonfunctional’ 또는 ‘기능 외extrafunctional’나 ‘교차 기능cross-functional’

아키텍처적인 '무슨 무슨 품질-ilities' 에 해당하는 
-> 아키텍처적인 (Scailability, Integrability 같은) '품질~ilities' 에 해당하는 

p.62
테스팅는 -> 테스팅은

정도는 가능하다 -> 정도는 할 수 있다

하려는 작업에 맞는 적절한 도구를 -> 하려는 작업에 맞는 도구를

p.63
그림 6.2 아래 글 배치를 조금 바꿔주면 어떨까 싶습니다.
'기록하는 테스트를 갈무리하는 방법' 같이 읽힐 수도 있을 거 같네요.

p.64
유지 보수하기 좋지 않을 수도? -> 유지 보수하기 어려울지도?

스크립트 기반 테스트를 하는 것일 수도 있다. -> 스크립트 기반 테스트일 수도 있다.

p.65
나머지 부분을 스텁할 수만 있다면 -> 나머지 부분을 스텁<Stub>할 수만 있다면

이들은 다음 ... 설계됐다. -> xUnit 의 설계 목표는 다음과 같다.

테스트 하나나 여러 테스트를 -> 한 개, 또는 여러 테스트를

관찰 위치를 집어넣어 -> 관찰 위치<observation point>를 집어넣어

p.66
테스트 실행 비용을... -> (앞에 . 넣어주세요) 테스트 실행 비용을...

생각이 든다면 사실 좀 더 -> 생각이 든다면 xUnit 보다 좀 더

다른 도구를 선택하더라도 그 도구가 뭔가를 선택하는 데 있어 제약이 있지 않은 한 전략적인 선택을 내려야 할 필요까지 없어지는 건 아니다.
-> 다른 도구를 선택했다고 해도, 여전히 전략적인 선택을 내려야 한다(그 도구 때문에 제약이 생기는 선택은 제외해야 겠지만).

다른 패턴(하나의 ...) 있다.
-> 이전 테스트에서 다음에 실행될 테스트의 픽스처를 설치하는 엮인 테스트 같은 일부 패턴들은 자동화하기 어려워 xUnit에서보다 Fit에서 더욱 더 인기가 없을 수도 있다.

p.67
xUnit에서보다 Fit에서 -> xUnit보다 Fit에서

게다가 xUnit의 유연함 덕분에 .. 모순이다.
-> 높은 테스트 유지 비용(265 페이지)을 발생시키는 애매한 테스트<Obscure Test>(186 페이지)를 만들 수 있는 이유가 바로 xUnit 이 유연하기 때문이라는 것은 참 아이러니한 부분이다.

xUnit 계열에서는 테스트를 설치하기 쉬운 조그만 픽스처를 필요로 하는 작은 테스트들의 큰 집합으로 만들 때 가장 잘 돌아간다.
-> xUnit에서는 픽스처를 설치하기 쉬운 작은 테스트들이 모여 있는 집합으로 만들어 주는 게 가장 좋다.

테스트를 xUnit이나 Fit으로 데이터 주도 테스트Data-Driven Test(288 페이지) 형태로 ...
-> 기존 테스트를 xUnit이나 Fit 으로 구현한 데이터 주도 테스트Data-Driven Test(288 페이지) 로 ...

이므로 특히 그렇다. -> 이므로 특히 잘 맞아 떨어진다.

일부 xUnit에서는 픽스처와 픽스처를 생성하는 테스트케이스 클래스(373페이지)를 달리 생각한다. JUnit와 그 쪽 계통이 이에 속한다.
-> 일부 xUnit는 픽스처와 픽스처를 생성하는 테스트케이스 클래스(373페이지)를 구분한다. JUnit 계통이 이에 속한다.

xUnit의 다른 계열들은 테스트케이스 클래스의 객체를 ‘사실상’ 픽스처라 생각한다.
-> xUnit의 다른 계열은 테스트케이스 클래스 객체를 ‘사실상’ 픽스처로 본다.

p.71
불변 공유 픽스처<Immutable Shared Fixture>(-> 공유 픽스처)
-> 불변 공유 픽스처<Immutable Shared Fixture>(공유 픽스처 참조)

p.72
‘멍청하다’고 할 수도 있지만 ... 있다 -> '멍청해' 보일지는 몰라도, 이런 전략이 꼭 필요할 때가 있다.

이 전략과 1회용 신선한 픽스처와의 가장 큰 차이점은 이 전략에서는 ... 써야 한다는 점이다.
-> 1회용 신선한 픽스처와의 가장 큰 차이점은 ... 테스트가 끝날 때마다 ... 써야 한다는 데 있다.

적어도 부분적으로라도 -> 부분적으로라도

같이 일했던 프로젝트 팀에서 데이터베이스 전체를 진짜 테이블 대신 해시
테이블을 쓰는 가짜 데이터베이스Fake Database(가짜 객체, 551 페이지)로 바꾸기 위
해 의존 주입Dependency Injection(678 페이지)이나 의존 찾기Dependency Lookup(686 페
이지)를 썼더니 테스트가 평균 50배 빨라지는 걸(진짜로 기존 시간의 2%만 걸린다)
볼 수 있었다.

-> 같이 일했던 팀에서는 의존 주입Dependency Injection(678 페이지)이나 의존 찾기Dependency Lookup(686 페이지)로 진짜 데이터베이스를 가짜 데이터베이스Fake Database(가짜 객체, 551 페이지)로 바꿔서 테스트를 평균 50배 빠르게(진짜로 기존 시간의 2%만 걸린다) 만들 수 있었다.

p.74
덜하면 할수록 -> 덜하면 덜할수록

을 볼 가능성이 있다. -> 도 생길 수 있다.

p.75
각오가 필요하다 -> 각오는 되어 있는가?

가장 생산성이 낮기도 하다. -> 생산성도 가장 낮다.

p.76
테스트에서 SUT에 어떤 식으로 제어 위치와 관찰 위치가 필요할지 미리 알기 어렵기 때문에
-> 어떤 제어 위치와 관찰 위치가 SUT에 필요할지를 테스트에서 미리 알기 어렵기 때문에

불시 설계<emergent design> -> 창발적 설계<emergent design>

p.81
하지만 오지 않는 메시지 응답을 기다려야 할 수도 있다면 테스트가 훨씬 오래 걸릴 수도 있다.
-> 하지만 메시지 응답이 오지 않는 경우까지 생각해 본다면, 테스트 실행이 예상보다 훨씬 오래 걸릴 수 있다.

이런 종류의 테스트는 -> 이런 테스트는

p.83
테스트 - SUT -> 테스트-SUT

== 7장 ==
p.85
도움을 줄 수 있다. -> 도움이 된다.

지금까지 설명한 공통된 특징의 직접 ... 를 자동화하기 위해 사용되는 ... 프레임워크이라면 ...
-> 지금부터 설명할 공통 특징이 있는 직접 ... 를 자동화하는데 사용되는 ... 프레임워크라면 ...

많이 사용되는 대부분의 언어에는 적어도 하나 이상의 xUnit 구현이 있다
-> 많이 사용되는 언어에는 대부분 하나 이상 xUnit 이 구현되어 있다.

개발이 훨씬 ... -> 개발하기가 훨씬 ...

p.90
실행기를 쓸 수 있다. -> 실행기를 제공한다.

커맨드라인 돌아가는 -> 명령행에서 돌아가는

p.92
실패한 곳의 스택에서는 -> 실패한 곳의 스택 트레이스를 보면

검증하는 부분의 일부일 뿐이고 -> 검증하는 한 부분이며,

‘컴파일’ 관점 -> '컴파일 시점'에서의 관점

알지 않고서도 -> 몰라도

만들기 쉽다. 따라서 -> 만들고 싶지 않다면

그림 7.3 
Testcast Object -> 테스트케이스 객체

p.94
다른 xUnit 계열에서는 -> 다른 xUnit 에서는

이런 식의 테스트 나열에는 -> 이런 식으로 테스트 나열<Test Enumeration>을 하다보면 

== 8장 ==
p.97
관련된 부분에서 추가적으로 고려해야 할 부분이 있는 정도다. -> 관련된 부분만 추가적으로 고려해주면 된다.

p.98
무엇이 픽스처인가? -> 픽스처?

SUT를 실행하기 위해 필요한 상태로 만들어 둔다.
-> SUT 실행에 필요한 상태로 만들어 둔다.

픽스처를 설치하기 위해서 호출하는 테스트 로직 부분을 -> 픽스처를 설치하는 테스트 로직 부분을

p.99
무엇이 신선한 픽스처인가? -> 신선한 픽스처?

두 가지 다른 방법이 -> 두 가지 방법이

확실한 ... 것이다. -> 테스트가 끝날 때마다 ... 것이 가장 확실한 방법이다.

덜 확실한 방법으로는 ... 것이다. -> 차선책으로 ... 해 주면 된다.

p.101
중복은 결과적으로... -> 중복은 결과적으로 깨지기 쉬운 테스트<Fragile Test> 를 만들어 높은 테스트 유지 비용을 발생시킨다.

테스트도 발생할 수 있다. -> 테스트도 생기기 쉽다.

관련된 문제로는 ... 점이다. 이것은 ... 때문이다. -> 하드코딩된 테스트 데이터(애매한 테스트 참조) 가 생길 수 있다는 점도 문제다. 이런 문제는 지역변수에 의도가 드러나는 이름<Intent-Revealing Name>[SBPP] 을 붙이는 데 드는 노력에 비해 도움은 그다지 안 된다고 생각하기 때문에 생긴다.

p.102
사용하게 하는 것이다. -> 사용하는 것이다.

// Exercise SUT and verify outcome -> // SUT 실행 후 결과 검증

p.103
픽스처 설치를 위해 테스트 재사용하기(생성 메소드 참조)를 -> 픽스처 설치를 위한 테스트 재사용(생성 메소드 참조)을 (p.474)

따라서 문서로서의 테스트를 중요하게 생각한다면 테스트를 읽을 때 픽스처가 무엇을 하는지 알 수 있게 하기 위해 호출되는 테스트를 의도가 드러나는 이름을 가진 생성 메소드로 감싸는 것을 고려해야 할 것이다.
-> 문서로서의 테스트를 고려한다면, 호출되는 테스트를 보고 픽스처에서 무엇을 하는지 알 수 있도록 테스트를 의도가 드러나는 이름의 생성 메소드로 감싸주는 것도 좋다.

p.104
‘모든 생성 메소드의 부모’가 객체 부모Object Mother(테스트도우미)다. 이런 전략 수준의 패턴에서는 하나 이상의 ...
-> 객체 부모<Object Mother>(테스트 도우미 참조)는 ‘모든 생성 메소드의 부모’ 다. 전략 수준의 패턴인 객체 부모 패턴에서는 하나 이상의 ...

메소드 속성(예: NUnit에서의 ‘[Setup]’)가 -> 메소드 어트리뷰트(예: NUnit에서의 ‘[Setup]’)가

p.105
xUnit 계열 일부(VbUnit, NUnit 등)는 -> 일부 xUnit(VbUnit, NUnit 등) 에서는

적어도 하나(NUnit)는 그렇지 않다. -> 적어도 NUnit 는 그렇지 않다.

p.106
...의 세상으로 넘어간다는 점에 주의하자. -> ...의 세상이 시작된다는 점에 주의하자.

p.107
... 의 세상으로 들어간다. -> ... 의 세상이 펼져질 것이다.

== 9장 ==
p.110
대부분의 경우 SUT에 데이터베이스가 있을 때 ... 경우에도 발생할 수 있다. -> 대부분 SUT 에서 데이터베이스를 사용할 때 이런 일이 벌어지지만, ... 경우에도 생길 수 있다.

다시 로드<reload> -> 리로드<reload>
클래스 다시 로드 -> 클래스 리로드

지속적으로 되는 걸 -> 지속되는 걸

p.111
일반적인 경우지만 -> 일반적이지만

즉, SUT를 이해하는 데 도움이 되지도 않을 뿐만 아니라 테스트의 의도를 애매하게 만들거나 적어도 이해하기 힘들게 만들 수는 있다. 그래서 가장 좋은 해체 코드란 없다고 할 수 있다.

-> 즉, SUT 를 이해하는데 도움을 주기는 커녕 오히려 테스트의 의도를 애매하게 만들기 쉽다. 따라서 해체 코드는 아예 없는게 최선이다.

작성하지 않아야 하고, 이런 면에서 -> 작성하지 않는게 좋다는 점에서

하지만 신선한 픽스처가 -> 신선한 픽스처가

p.112
해체하지 못하게 된다. -> 해체할 수 없다.

안타깝게도 ... 부분으로 인해 -> 결과적으로 ... 부분 덕분에

이런 위임 해체Delegated Teardown(인라인 해체 참조)가 해체 에러의 복잡함을 숨겨주기는 해도 여전히 테스트 에러나 실패가 발생했을 때에도 메소드 호출을 보장해줘야 한다.
-> 이런 위임 해체<Delegated Teardown>(인라인 해체 참조) 덕분에 해체 에러의 복잡함은 숨길 수 있지만, 여전히 테스트에서 에러나 실패가 발생해도 위임 해체 메소드 호출을 보장해 줘야 한다.

p.113
대부분의 xUnit 계열에서는 -> 대부분의 xUnit 에서는

표 9.1 의 Acceptable 을 '쓸 수 있음', '사용가능' 정도로 번역
(표의 위임 해체 부분이 권장하지 않음이 아니라 '사용가능' 인 부분이 있습니다. 확인 부탁드려요)

p.114
에는 두 개의 문제점이 있다 -> 는 좀 문제가 있다.

테스트가 될 수 있다. -> 테스트가 되기 쉽다.

안 보이게 하는 게 더 좋다는 점이다. -> 숨겨줄 수록 좋다는 점이다.

이것은 다음과 같이 세 부분으로 -> 자동 해체 메커니즘은 다음 세 부분으로

p.115
덜 격렬한 방법으로는 -> 좀 더 점잖은 방법으로는

SUT가 ... 을 쓰게 돼 있어 ... 있어야 한다 -> SUT 에서 ... 을 쓰고 있어서 ... 호출할 수 있을 때 사용 가능하다.

해체 요구 피하기 -> 아예 해체 코드를 필요없게 만들기

이유로 인해 -> 이유 때문에

p.116
픽스처가 지속되는 이유가 테스트에게 있다면 -> 픽스처가 지속되는 이유가 테스트에 있다면

p.117
테스트가 시작할 때마다 신선한 픽스처를 설치하고, 테스트가 끝날 때마다 신선한 픽스처를 해체하는 작업이 SUT에서 픽스처에 접근하는 작업보다 훨씬 디스크 접근량이 많다.
-> 테스트를 시작, 종료하면서 신선한 픽스처를 설치, 해체할 때 발생하는 디스크 접근량(즉, DB 나 파일의 접근 횟수 및 데이터 크기 : 옮긴이) 이 SUT에서 픽스처에 접근하는 작업보다 보통 더 크다.

p.118
점에 주의한다 -> 점에 주의하자

문서화되지 않은 값(애매한 테스트, 186 페이지)이 되므로 언제나 결과가 좋지 않다.
-> 값에 대한 문서화가 제대로 안 되기 때문에 결과가 좋지 않다.

p.119
이 붙은 찾기 메소드 -> 의 찾기 메소드

p.121
실행될 수 없다는 점이다. 즉, 외로운 테스트가 된다. -> 실행될 수 없어서 외로운 테스트가 된다는 데 있다.

‘완벽한 상태의’ -> '완벽한 상태'의

테스트 하나라도 반복 안 되는 테스트라면 -> 테스트 중 하나라도 반복 안 되는 테스트가 있다면

값를 -> 값을

== 10장 ==
p.123
(-> 테스트 자동화의 목표) -> (테스트 자동화의 목표 참조)

내장 단언 메소드<Assertion Methods> (병기)

제공하고 있다. -> 제공한다.

그냥 보기에는 ... 많다. 또한 테스트를
-> 하지만 좋은 테스트를 작성하려면 내장 단언 메소드 호출 외에도 할 게 많다. 테스트를

p.124
넘겨줄 수 있게 한다. -> 넘겨준다.

동기 메소드 ...
-> 동기 메소드를 호출해 접근할 수 있는 정보에 대한 관찰 위치는 쉬운 반면에, 다른 정보에 대한 관찰 위치는 만만하지 않다. 그래서 더 재미있지만 말이다.

하지만 이렇게 하면 ... 따로 작성하는 게 더 좋다. -> 하지만 오히려 애매한 테스트<...>(...) 를 만들 수도 있으므로 테스트 유틸리티 ... 따로 작성하는 게 낫다.

객체의 상태를 통해 -> 객체 상태를 보고

찾기 메소드... 에서도 이렇게 해줄 수 있다. -> 찾기 메소드... 에서도 마찬가지다.

p.126
약간 다른 두 방법으로 상태 검증을 할 수 있다. -> 상태 검증을 할 수 있는 방법에는 두 가지가 있다.

기댓 값과 -> 기대값과

단언문들을 작성한다. -> 단언문을 작성한다.

자세히살펴 -> 자세히 살펴

단순히 내장 단언문을 사용하는 것은 전체의 일부일 뿐이다.
-> 단순히 내장 단언문을 사용하는 것은 xUnit 에 있어서 극히 일부분일 뿐이다.

p.127
"시스템은 S2 상태가 돼야 한다" -> "시스템은 S2 상태이어야 한다"

이런 기법은 단언 룰렛... 가능성을 막아줘 -> 이렇게 하면 단언 룰렛<...> 을 막아줘

그다지 도움이 되지 않는다 -> 별 도움이 안 된다

공유 픽스처<Shared Fixture>(317 페이지)를 사용한다면 ... 를 만들 수 있게 되는데, 
-> 공유 픽스처<Shared Fixture>(317 페이지)를 사용하다보면 ... 를 만들기 쉬운데,

p.128
이 기법은 분명 ... 맞춤 단언문과 (혹은) 검증......수 있다
-> 물론 테스트 복잡도가 높아지긴 하겠지만, 맞춤 단언문과 검증 메소드<...>(...) 리팩토링으로 추가된 복잡성을 숨길 수 있다.

일종의 맞춤 검증 -> 일좀의 맞춤 단언문

만들기 위해 -> 만들려면

파일의 어느 부분을 무시하게 -> 파일의 특정 부분은 무시하게

에 맞지 않을 수 있다. -> 에 맞지 않는다.

p.130
절차형 동작 검증에서 가장 어려운 부분은 원하는 동작이 실행되는 순간을 잡아내 나중에 테스트가 볼 수 있는 정보를 남기는 곳이다
-> 절차형 동작 검증에서는 원하는 동작이 실행되는 순간을 잡아내 나중에 테스트가 볼 수 있는 정보를 남기는 게 가장 어렵다.

p.131
검증하는 데 사용된다. -> 검증하는 데 쓰인다.

냄새가 나게 하므로 나쁘다. -> 냄새가 나게 만드므로 피해야 한다.

p.132
검증 로직으로 인해 보통 테스트 코드 중복은 -> 일반적으로 검증로직에서 테스트 코드 중복은

이런 경우에 검증 개수를 줄일 수 있는 기법이 여러 개 있다 :
-> 다음 기법을 쓰면 검증 개수를 줄일 수 있다 :

이런 테스트 코드 중복을 제거할 -> 코드 중복을 제거할

p.133
동일identity -> identity 병기표시

직접 작성하는 도메인 특화 단언문 -> 우리가 직접 작성해야 하는 도메인 전용 단언문

p.134
메소드로 뽑아낸 후[Fowler] -> 메소드로 뽑아낸 후<Extract Method>[Fowler]

또 다른 기법이 생겼다. -> 또 다른 기법이 나왔다.

p.135
코드 리팩토링을 해야 할 -> 코드 리팩토링이 필요한

보통 맞춤 단언문은 일반적인 ...다.
-> 보통 맞춤 단언문의 시그니처는 일반적인 ... 과 같다.

이렇게 만든 인자를 받는 테스트는 필요한 인자로 인해 테스트 자동 프레임워크(298 페이지)에서 자동으로 호출하게 할 수는 없고 대신 인자를 받는 테스트에 테스트별로 다른 데이터를 전달하는 식으로 매우 간단하게 테스트 메소드를 정의할 수 있다.
-> 이렇게 만든 인자를 받는 테스트에는 인자를 전달해 줘야 하기 때문에 테스트 자동 프레임워크(298 페이지)에서 자동으로 호출할 수는 없고, 대신 다른 테스트에서 인자를 받는 테스트에 필요한 데이터를 전달하는 식으로 간단하게 정의할 수 있다.

p.136 
테스트 케이스는 완전히 일반적이며 프레임워크에서 바로 실행할 수 있다.
-> 테스트 케이스는 일반적이며 프레임워크가 직접 실행할 수 있다.

다음 코드는 루비로 ... 예제다. -> 다음은 루비로 ... 예제코드다.

p.137
달리 ... 점에서 좋지 않다. -> 다르게 ... 점에서 나쁘다.

테스트 메소드의 코드가 테스트할 수 없는 테스트 코드가 되므로 테스트의 신뢰가 떨어진다. 이게 왜 중요할까?
-> 테스트 메소드 코드는 테스트할 수 없기 때문에, 테스트 내 조건문 로직이 들어있을 경우 테스트에 대한 신뢰가 떨어진다. 

p.138
있다는 사실이 가려질 수 있다는 점이다. -> 있다는 사실을 놓칠 수 있다는 점이다.

마지막 ‘이유’는 무조건 안 좋은 생각이다. -> 마지막 ‘이유’는 무조건 피해야 한다.

p.139
Stephen Covey -> 스티븐 코비<Stephen Covey>

p.140
(부작용(副作用)... - 옮긴이) 를 삭제하거나 이 부분의 부수 효과를 부작용으로 변경
가끔 부작용이라는 단어가 다른 곳에서 나오니, 이 부분의 '부수 효과'를 대신 '부작용'으로 변경하는 게 어떨까요?

== 11장 ==
p.143
대부분 SUT가 -> 대부분 테스트 대상 시스템<system unter test. SUT> 이
(SUT, DOC 가 뭔지 모르겠다는 의견이 있습니다. 각 장 처음에 나오는 SUT, DOC 에 대해서 병기할까 합니다)

p.145
간접 입력들은 다른 컴포넌트를 ... 등의 형태로 얻는다.
-> 간접 입력은 다른 컴포넌트를 ... 등의 형태로 들어온다.

p.146
간접 입력 테스트는 여기에서 쓰는 기법에 기반하는 간접 출력 테스트보다
-> 간접 입력 테스트는 간접 출력 테스트보다

p.147
pass-by-reference된 전달한 인자 -> pass-by-reference로 전달한 함수 인자

p.148
이를 제어 위치로 쓸 수 있다 -> 이런 식으로 테스트 스텁에게 제어 위치 역할을 맡길 수 있다.

p.149
파일에 작성한 컨텐츠가 제대로 원하는 내용이 -> 작성한 파일에 원하는 내용이 제대로

p.150
안 된다면 실제 컴포넌트를 테스트용 대체제로 바꿔야 한다. 다음과 같은 이유가 있을 수 있다.
-> 안 된다면 다음과 같은 이유에서 실제 컴포넌트 대신 테스트용 대체제로 바꿔줘야 한다.

p.152
테스트 스파이나 모의 객체를 쓰는 경우 이들이 호출된 후에도 테스트가 계속 진행될 수 있게 하려고 이들을 SUT가 의존하는 모든 간접 입력에 대한 제어 위치로 계속 사용해야 할 수도 있다.

-> 테스트 스파이나 모의 객체를 쓰는 경우, 이들이 호출된 후에도 테스트가 계속 진행될 수 있도록 SUT 가 의존하는 모든 간접 입력에 대한 제어 위치 역할을 계속 해 줘야 할 수도 있다.

p.153
(또는 그냥 ‘가짜') -> (또는 그냥 '가짜'<Fake>)

Invoice 생성자에서 꼭 필요한 인자를 위해 -> Invoice 생성자의 필수 인자로

DummyCustomer는 테스트하려는 코드에서 사용되지 않는다.
-> 테스트 대상 코드에서는 DummyCustomer 를 쓰지 않는다.

p.154
쓰지 않기 때문에 동작을 신경 쓰지 않아도 된다. -> 쓰지 않기 때문에 더미 객체가 어떻게 동작하는지를 걱정할 필요 없다.

p.155
‘바꿔치기’ 하기는 굉장히 힘들다. -> ‘바꿔치기’ 란 굉장히 어렵다.

if 테스트 중 then ... else -> if testing then ... else

p.156
단지 프로시저 변수 -> 단, 프로시저 변수

p.157
테스트 스파이랑 다른 -> 테스트 스파이와 다른

재사용할 수 있게 된다. -> 재사용할 수 있다.

p.158
들어온 인자를 기대 -> 들어온 인자가 기대

설정할 수 있게 한다. -> 설정할 수 있게 해 준다.

부분을 엄청 단순하게 할 수 있다. -> 부분을 쉽게 만들어 준다.

p.162
결국 언제나 테스트 개발자가 -> 결국에는 테스트 개발자가

p.163
일반적으로는 테스트 대역을 생성하고 설정되는 테스트 대역이라면 필요한 설정을 한 후 SUT를 실행하기 전이나 실행할 때 테스트 대역을 쓰게 알려주는 절차를 따른다.
-> 보통은 먼저 테스트 대역을 생성한 뒤, 설정되는 테스트 대역이라면 필요한 설정을 하고 나서, SUT를 실행하기 전이나 실행할 때 테스트 대역을 대신 사용하게 만든다. 

다음 3가지로 압축된다. (1) 클라이언트 ... (2) SUT 가 DOC의 ... (3) SUT 내에서 DOC나

p.164
의존 주입<Dependency Injection>은 클라이언트가 SUT에게 어떤 DOC를 써야 하는지 런타임에 알려줄 수 있는 설계 결합을 제거하는<decoupling> 클래스다
-> 의존 주입<Dependency Injection>은 클라이언트가 SUT에게 어떤 DOC를 써야 하는지 런타임에 알려줘서 SUT와 DOC간의 설계 결합을 제거할 수 있는<decoupling> 패턴이다.

운동에서 많은 인기를 얻었다. -> 진영으로부터 환영을 받았다.

p.166
테스트의 테스트 대역 의존을 좀 더 명확하게 해준다는 점에서
-> 테스트가 테스트 대역에 의존한다는 걸 좀 더 명확하게 보여준다는 점에서

p.167
작고 ... 최고다! -> 이럴 때 메소드는 작고 ... 하는게 좋다!

p.168
야기할 수 있으므로 누구도 말하지 않는 -> 만들 수 있다보니 누구도 언급하지 않는

도입하려고 할 때 -> 도입할 때

테스트 훅이야말로 딱 맞는 방법이다 -> 테스트 훅 만한게 없다.

테스트 훅은 테스트 용이성을 높이기 위해 전 방위 리팩토링을 하는 동안 안전망(24 페이지)을 제공할 수 있게 스크립트 기반 테스트Scripted Test(285 페이지)나 기록 테스트Recorded Test(278 페이지)를 쓸 수 있게 하기 위한 ‘중간 단계transition’로 사용된다.
-> 테스트 훅은 테스트 용이성을 높이기 위해 전 방위 리팩토링을 하는 동안 스크립트 기반 테스트Scripted Test(285 페이지)나 기록 테스트Recorded Test(278 페이지)가 안전망(24 페이지)을 제공할 수 있는 상태로 가기 위한 징검다리 역할을 한다.

p.169
의존 라이브러리는 테스트 전용으로 -> 의존 라이브러리를 테스트 전용으로

각 테스트에서 동적으로 의존을 교체해야 할 경우 이런 기법들은 환경을 변화시켜야 한다는 점에서 의존 주입이나 의존 찾기보다는 덜 적합하다.
-> 이런 기법들은 각 테스트에서 의존을 교체할 때마다 환경을 변화시켜야 한다는 점에서 의존 주입이나 의존 찾기보다는 못하다.

p.171
새로 산 망치의 에러 -> 새로 산 망치의 오류

문제가 생길 수 있다. -> 문제가 생긴다.

== 12장 ==
p.173
테스트를 어떻게 구성하느냐가 테스트를 찾기 쉽고 이해하기 쉽게 유지하는 데 결정적이다.
-> 테스트를 어떻게 구성하느냐에 따라서 테스트를 찾고 이해하기 쉽게 유지할 수 있는지 여부가 결정된다.

p.174
계열에서는 -> 에서는

“테스트 코드는 어디에 둬야 할까?” 테스트케이스 클래스의 테스트 메소드 안에 둔다. 그럼
-> 테스트 코드는 테스트케이스 클래스의 테스트 메소드 안에 둔다. 이제, 

p.175
많은 순수주의자들은 좋은 결함 국소화<Defect Localization>(22 페이지)를 제공하는 테스트별로 하나의 조건만 검증하라는 원칙(45 페이지)을 선호한다.
-> xUnit 순수주의자들은 결함 국소화<Defect Localization>(22 페이지) 때문에 테스트별로 하나의 조건만 검증하라는 원칙을 선호한다.

재미있는 타협안을 개발했는데 -> 흥미로운 타협안을 제안했는데,

주석으로 딱 표시한다. -> 주석으로 표시해 둔다.

p.177
SUT 의 특정 능력을 -> SUT 의 특정 기능을

하지만 이러면 모든 테스트케이스 클래스마다 -> 대신 모든 테스트케이스 클래스에

p.178
FixtureATestcaseClass -> 픽스처A테스트케이스클래스

FixtureBTestcaseClass -> 픽스처B테스트케이스클래스

주어진 상황에 가장 적당한 것이다. -> 주어진 상황에 가장 적합한 것이다.

대항해 고객 테스트를 -> 대해 고객 테스트를

p.179
할 수만 있다면 얻을 수 있는 게 많다. IDE 창에서 ... 있다. 예를 들어 그림 ... 
-> 할 수만 있다면 많은 것을 얻을 수 있다. 예를 들어 IDE 창에서... 있다. 그림 ...

(그래서 IDE에서 보이지 않는다면 - 옮긴이) -> (그래서 IDE에서 보이지 않는다면)

p.180
객체(382 페이지)들이 들어 있는 -> 객체(382 페이지)가 들어 있는

p.181
보통 적어도 전체 단위 테스트를 위한 부분 스위트 하나와 고객 테스트(대부분 실행 시간이 오래 걸리는)만을 위한 부분 스위트 하나를 갖고 있다. xUnit 계열 중에는
-> 일반적으로 전체 단위 테스트를 위한 부분 스위트와 고객 테스트(대부분 실행 시간이 오래 걸리는) 만을 위한 부분 스위트를 따로 둔다. xUnit 중에는

p.182
속성이나 어노테이션을 -> 어트리뷰트나 어노테이션을

그렇긴 한데 다른 용도로 쓰면 안 된다는 건 아니다. -> 맞다. 그렇다고 다른 용도로 못 쓸 건 없다.

p.185
상속을 받을 수 있다. -> 상속을 받는다.

== 13장 ==
p.187
테스터베이스와 테스트 -> 데이터베이스와 테스트

13장에서는 프로그램에 데이터베이스가 있을 때 발생할 수 있는 문제점들을 살펴본다.
-> 13장에서는 프로그램에서 데이터베이스를 사용할 때 발생할 수 있는 문제점을 살펴본다.

데이터베이스는 요즘 컴퓨터의 프로세서보다 훨씬 느리다. 따라서 데이터베이스와 상호작용하는 테스트는 메모리에서만 돌아가는 테스트보다 아주 훨씬 느린 편이다.
-> 데이터베이스는 최신 컴퓨터의 프로세서보다 훨씬 느리다. 따라서 데이터베이스와 상호작용하는 테스트도 메모리에서만 실행되는 테스트보다 훨씬 느리다.

느린 테스트(253 페이지)에 대한 가능성은 젖혀 두더라도 데이터베이스는 자동 테스트 스위트에서 여러 가지 테스트 냄새가 나게 만드는 원인이 되기 쉽다.
-> 데이터베이스를 사용하면 느린 테스트(253 페이지)를 포함한 여러 가지 테스트 냄새가 자동 테스트 스위트에서 날 수 있다.

데이터베이스의 지속성으로 인해 발생하고 -> 데이터베이스의 영속성 때문에 생기고

픽스처 객체를 공유하므로 발생한다. -> 픽스처 객체를 공유하기 때문에 생긴다.

p.188
어떻게든 데이터베이스 없이 테스트할 수 있다면, 그렇게 하라!
-> 데이터베이스 없이 테스트할 수 있다면 수단과 방법을 가리지 마라!

왜 데이터베이스를 테스트 하는가? -> 왜 데이터베이스를 이용한 테스트가 필요한가?

부분이다 보니 데이터베이스를 제대로 -> 부분이다 보니 이를 제대로

같은 벽에서 일하는 게 맞는 일일까? -> 같은 벽에서 작업한다고 생각해 보자.

p.189
... 어렵게 만드는 여러 문제점이 있다. 픽스처가 지속된다는 점과 관련된 많은 문제가 있다.
-> ... 어렵게 만드는 문제가 많고, 이들 문제 대부분이 픽스처 지속 때문에 생긴다.

볼 수 있는 몇 가지 문제점이 있다. -> 볼 수 있는 문제가 몇 가지 있다.

픽스처 객체에 동시 접근하는 경우에 발생한다. 이런 작동 냄새들은 -> 픽스처 객체에 동시에 접근할 때 생긴다. 이런 모든 작동 냄새들이

p.190
전략을 쓰려고 할 때 표준 픽스처(..) 를 쓰는 것과도 -> 전략을 쓰려고 하다가 표준 픽스처(..) 를 쓰게 되는 것과도

레이어 테스트를 쓰면 각 레이어를 다른 레이어와는 독립적으로 빌드할 수 있다.
-> 레이어 테스트를 쓰면 각 레이어를 독립적으로 빌드할 수 있다.

문맥에 민감함(Context Sensitivity) -> 문맥에 민감함<Context Sensitivity> (병기 표기 부탁드립니다.)

p.191
전부 메모리 안에 저장하는 -> 전부 메모리에 저장하는

훨씬 빠르게 실행된다. -> 훨씬 빠르다.

경우에는 좀 더 재미있어진다. -> 경우에는 좀 더 고민해봐야 한다.

이럴 때는 테스트하기 쉽게 설계하는 데 좀 더 신경을 써야만 데이터베이스를 교체할 수 있으므로 좀 더 어렵다.
-> 이런 경우에는 미리 설계가 테스트하기 쉽게 되어 있어야 데이터베이스 교체가 가능하기 때문에 쉽지 않다.

테스트 대역으로 기능과 관련된 -> 테스트 대역으로 해당 기능과 관련된

p.192
테스트는 애플리케이션의 로직에서 사용하는 것과 같은 -> 테스트에서는 애플리케이션의 로직에서 하는 것처럼

p.193
튼튼하게 만드는 과정에서 -> 견고하게 만드는 과정에서

왕복 테스트<round-trip test>의 형태가 된다. -> 왕복 테스트<round-trip test>다.

보장해주면 좋다 -> 보장해 주는 게 좋다.

확장판를 써서 -> 확장판을 써서

p.194
DFT 패턴에 의존 한다. -> DFT 패턴을 사용한다.

지우고 싶은 때에만 쓸 수 있다. -> 지우고 싶은 때에만 적당하다.

한다는 의미다. 하나의 샌드박스를 여러(혹은 전체)개발자가 같이 쓰게 하면 되로 막으려다 말로 갚는 꼴이 된다.
-> 한다는 의미다. 데이터베이스가 필요한 테스트를 할 때는 모든 개발자에게 각자의 데이터베이스 샌드박스를 줘야 한다. 하나의 샌드박스를 여러 (혹은 전체)개발자가 같이 쓰게 만드는 것은 되로 막으려다 말로 갚는 것과 다를 게 없다.

많은 시간을 버리게 된다. -> 많은 시간을 낭비하게 된다.

여러 목수에게 망치를 하나로 나눠 쓰라고 하는 게 말이 된다고 생각하는가?
-> 여러 목수에게 망치 하나로 나눠 쓰라고 하는 것과 다를게 없다.

p.195
... 테스트하기(또!) -> ... 테스트하기(한번 더!)

해놨다고 가정해보자 -> 해놨다고 해보자.

적게 하지만 -> 적게, 하지만

(데이터, 데이터베이스라는 단어가 너무 많이 나오는 거 같다. 지속성보다는 영속성이라는 단어가 더 적당할 거 같다. eg : 데이터베이스의 영속성, 데이터의 지속성)

== 14장 ==
p.197
로드맵 -> 길잡이

(혹은 없이) -> (혹은 데이터베이스 없이)

효과적으로 하기 전에 알아야 할 것들이 너무나 많았다. 
-> 효과적으로 하려면 알아야 할 것들이 참 많다.

자유자재로 쓰기에는 시간이 든다. -> 자유자재로 쓰기까지에는 많은 시간이 필요하다.

어떤 테스트들은 다른 것보다 작성하기가 더 어렵다.
-> 어떤 테스트는 다른 테스트보다 작성하기가 더 어렵다.

어려움은 이런 테스트들이 기술도 많이 ... 없으므로 발생한다. 
-> 어려움은 테스트에 기술이 많이 ... 없다보니 생긴다.

p.198
의존 없는 간단한 비즈니스 클래스 -> 의존 관계가 없는 간단한 비즈니스 클래스
의존 있는 복잡한 비즈니스 클래스 -> 의존 관계가 있는 복잡한 비즈니스 클래스

목록 아래로 내려갈수록 점점 테스트하기 어려운 것들이다.
-> 아래로 갈 수록 테스트하가 어렵다.

여러 기법을 다루고 있다.
-> 여러 기법을 다루고 있다. (역주 : 간단한 툴이나, 토이 프로그램에서 먼저 단위 테스트를 붙여본 다음에 감을 잡고 나서 큰 프로젝트에 적용하는 것도 실패 확률을 줄이는 방법이다. 이 때 어떤 xUnit 이 자신에게 맞는지 이것저것 테스트 해 보길 바란다.)

p.199
잘 유지되는 자동 테스트를 위한 길잡이
-> 자동 테스트를 유지보수하기 좋게 만드는 길잡이

다른 테스트보다 훨씬 작성하기 어려운 테스트가 있긴 해도 그런 어려운 테스트를 하기 전에 쉬운 테스트부터 어떻게 작성할지 배우는 게 좋다.
-> 어려운 테스트보다는 쉬운 테스트부터 먼저 배우는 게 좋다.

1. 주요 경로 코드 실행 -> 1. 주요 경로<happy path> 코드 실행

SUT의 -> SUT<system unter test, 테스트 대상 시스템> 의

..를 이용해 밖으로 나가는 -> ..로 밖으로 나가는

테스트 실행을 빠르게 만들기 -> 테스트 실행 빠르게 만들기

빠진 버그에 -> 놓친 버그에

p.200
하드 코딩을 약간 해야 -> 약간 하드 코딩해야 

주요 경로 결과 바로 검증 -> 주요 경로의 직접 출력값 검증

p.201
경우에는 좀 더 흥미진진하다. -> 경우는 만만하지 않다.

p.202
테스트를 반복 가능하고 단단하게 만들기 -> 테스트를 반복 가능하고 견고하게 만들기

의존 컴포넌트<DOC> -> 의존 컴포넌트<DOC, depended-on component>

굉장히 바람직한 부작용이 나타나게 된다. 즉, 테스트가 훨씬 튼튼해지고 반복 가능해진다.
-> 굉장히 바람직한 부작용 덕분에 테스트가 훨씬 견고하고 반복 가능하게 된다.

동작 검증<Behavior Verification>(468 페이지)을 통해서만 검증할 수 있다.
-> 동작 검증<Behavior Verification>(468 페이지)을 통해서만 검증할 수 있는 부분이 있다.

이 정도까지 오면 코드의 전체적인 경로에 대해 자동 테스트가 설치돼 있겠지만
-> 지금쯤이라면 전반적인 코드 실행 경로에 대해 자동 테스트가 설치돼 있겠지만

p.203
이런 방식은 이것대로 -> 이런 방식은 나름대로

또한 체계적으로 테스트케이스 클래스와 테스트 메소드의 이름으로 검증하려는 테스트 조건을 보여줄 수 있게 해주면 의도를 더 잘 전달할 수 있다.
-> 또한 테스트케이스 클래스와 테스트 메소드 이름으로 검증하려는 테스트 조건을 체계적으로 보여주는 것도 테스트 의도를 전달하기에 좋다.

== 15장 ==
p.208
이들 두 가지 목표는 테스트를 실행하게 상세히 구현하다보면 ... 서로 ...
-> 테스트를 실행할 수 있게 구현하다보면 어느새 복잡해지기 때문에 이들 두 가지 목표를 동시에 만족하기란 어렵다.

애매한 테스트의 첫 번째 문제는 테스트를 이해하기 힘들게 만들고 유지 보수하기도 힘들게 한다는 점이다. 
-> 애매한 테스트가 있으면 테스트를 이해하기 힘들고 유지 보수하기도 어렵다.

애매한 테스트의 두 번째 문제는 애매한 테스트에 숨어 있는 테스트 코드 에러로 인해 버그가 빠져나갈 수 있다는 점이다. 
-> 또한 애매한 테스트에 가려 보이지 않는 테스트 코드 에러 때문에 버그가 빠져나갈 수도 있다.

너무 적을 때 발생할 수 있다. -> 너무 적을 때 생긴다.

미스터리한 ... 적을 때 생긴다. 욕심쟁이 테스트와 관련 없는 정보가 너무 많을 때 생긴다.
-> 미스터리한 ... 적을 때 생긴다. 반대로 욕심쟁이 테스트와 관련 없는 정보<Irrelevant Information> 는 정보가 너무 많을 때 생긴다.

p.209
보통 테스트 코드를 깔끔하고 간단하게 유지하려는 관심이 없는 것이 애매한 테스트의 근본 원인이다.
-> 애매한 테스트는 테스트 코드를 깔끔하고 간단하게 유지하려는 의지가 없을 때 생긴다.

여기에서 다루는 애매한 테스트의 몇 가지 ... 테스트에 잘못된 정보를 갖고 있는 ... 
-> 다음 몇 가지 ... 테스트에 잘못된 정보가 있을 때 생긴다 :

테스트 독자에게는 이들 간의 ... 않는다. -> 코드를 봤을 때 이들 간의 ... 보이지 않는 테스트

테스트 독자가 알기 어렵다. -> 코드만 봐서는 알기 어렵다.

테스트를 수동으로 할 경우 ... -> 수동으로 테스트한다면 ...

몰아넣는 게 의미가 있다. 이때는 ... 테스트를 실행하고, 따라서 
-> 몰아넣어도 된다. 수동 테스트에서는 ... 테스트를 실행하기 때문에

간접 테스팅<Indirect Testing> (bold 체 부탁드립니다.)

p.211
테스트 독자에게는 이들 간의 ... 않는다. -> 코드를 봤을 때 이들 간의 ... 보이지 않는 테스트

테스트에서는 으레 SUT에 데이터를 보내야 한다. -> 테스트는 으레 SUT에 데이터를 보낸다.

더 안 좋은 것은 -> 더 큰 문제는

p.212
문자 키 -> 리터럴 키<literal key>

이런 모든 상황의 결과는 비슷하다. -> 다들 결과는 비슷하다.

미스터리한 손님이 있다는 의미다. -> 미스터리한 손님이 있는 것이다.

p.213
아래에 숨길 수도 있다. -> 아래에 숨겨준다.

고려해봐야 한다 -> 고려해보자

들어있는지를 분명하게 해줘야 한다. -> 들어있는지를 짐작할 수 있게 해줘야 한다.

1. 자세한 것은 인라인 자원(In-line Resource, 736 페이지) 리팩토링에서 확인하라
-> 1. 인라인 자원(In-line Resource, 736 페이지) 리팩토링 참고

p.214
알아차리기 좀 더 어려운 경우로는 테스트에서 ... 경우를 들 수 있다.
-> 테스트에서 ... 경우에는 일반 픽스처가 있다는 걸 알아차리기가 좀 더 어렵다.

이런 예가 된다. -> 한 예다.

만들 가능성이 많다. -> 만들기 쉽다.

p.215
느린 테스트까지 될 수 -> 느린 테스트도 될 수

테스트 독자가 알기 어렵다. -> 코드만 봐서는 알기 어렵다.

어느 부분이 수정됐는지만 분명해질 뿐이지 -> 어느 부분이 수정됐는지는 분명해지겠지만 

p.217
데이터를 너무 많이 -> 데이터가 너무 많이

테스트를 작성하는 가장 무난한 방법이 테스트와의 관련 여부와 상관없이 사용할 수 있는 거라면 어느 메소드라도(SUT에 있던, 다른 객체에 있던) 사용하고 모든 인자에 값을 넣어주는 것이다.
-> 테스트와의 관련 여부를 고민할 거 없이 사용할 수 있는 거라면 어느 메소드라도(SUT에 있던, 다른 객체에 있던) 사용하고 모든 인자에 값을 넣어주는 것이 (당장은) 편하게 테스트를 작성하는 방법이기는 하다.

하나의 원인이 될 수 있다. -> 하나의 원인이다.

p.218
제거하는 가장 좋은 방법은 ... 로 직접 호출하는 부분을 관련 ... 호출하게 바꾸는 것이다 
-> 제거하려면 ... 를 직접 호출하기 보다는 대신 관련 ... 호출해 주는 게 가장 좋다.

p.219
테스트를 작성하는 가장 무난한 방법이 테스트와의 관련 여부와 상관없이 사용할 수 있는 거라면 어느 메소드라도(SUT에 있던, 다른 객체에 있던) 사용하고 모든 인자에 값을 넣어주는 것이다.
-> 테스트와의 관련 여부를 고민할 거 없이 사용할 수 있는 거라면 어느 메소드라도(SUT에 있던, 다른 객체에 있던) 사용하고 모든 인자에 값을 넣어주는 것이 (당장은) 편하게 테스트를 작성하는 방법이기는 하다.

'잘라 붙이기'로 테스트 로직을 재사용하면 -> 'Copy & Paste'로 테스트 로직을 재사용하다보면

어떤 객체도 현장에 남기고 나오지 않기 -> 어떤 객체도 남기지 않기

두 번째로 큰 충돌은 다른 테스트에서 같은 값을 쓰다가 충돌이 날 때 생긴다.
-> 다른 테스트에서 같은 값을 쓰는 경우에도 충돌이 생길 수 있다.

공유 픽스처를 쓸 경우에만 발생하는데, 그 이유는 신선한 픽스처 전략에서는
-> 공유 픽스처를 쓸 경우에만 발생한다. 신선한 픽스처 전략에서는

p.220
문자 상수 -> 리터럴 상수<Literal Constant>

이 객체를 통해 상호작용해야 한다. -> 이를 통해 SUT 와 상호작용해야 한다.

p.222
값를 -> 값을

들어있는 쉽게 테스트 -> 들어있는, 쉽게 테스트

p.223
튼튼하게 만들 수 -> 견고하게 만들 수

p.224
말이 있듯이 -> 말처럼

다양한 경우에서서 -> 다양한 경우에서

유틸리티 메소드를 작성할 수 있다. -> 유틸리티 메소드를 작성한다.

p.225
테스트를 읽다보면 이게 있다는 걸 분명하게 알 수 있다 
-> 테스트코드만 봐도 존재 여부를 바로 알 수 있다.

p.226
동작 증상이 테스트 조건문 로직이 만들어내는 복잡함으로 인해 발생하는 프로젝트 단계 냄새인 높은 테스트 유지 비용(265 페이지)이라는 형태로 나타날 수 있다.
-> 이런 테스트 내 조건문 로직은 코드를 복잡하게 만들어 프로젝트 단계 냄새인 높은 테스트 유지 비용(265 페이지) 동작 증상이 생기게 할 수 있다.

이것은 애매한 테스트... 가 되기 훨씬 쉽다.
-> 사실 이것은 애매한 테스트... 에서 일반적으로 생기는 문제다. 애매한 테스트가 있으면 코드가 더 복잡해지고 버그투성이 테스트<Buggy Test>(260 페이지)가 되기 쉽다.

피하려면 if문을 쓴다 -> 피하려고 if문 사용.

검증하고 싶을 때 반복문을 쓴다 -> 검증하려고 반복문 사용

검증하기 위해 테스트 조건문 로직을 쓰는 경우 
-> 검증하기 위해 테스트 내 조건문 로직 사용

p.227
가장 일반적으로는 테스트 ... 싶을 때 테스트 조건문 로직 형태를 쓴다
-> 보통 테스트 ... 싶을 때 이렇게 많이 한다.

p.228
두 번째 문제는 실제로 -> 또한 실제로

지원하게 리팩토링한다 -> 지원하도록 리팩토링한다

p.234
다른 것들이 테스트 독자를 두렵게 만든다면 여러 테스트 조건의 가장 큰 문제는 ... 못한다는 것 정도다.
-> 다른 원인들이 테스트 독자를 두렵게 만드는 반면에, 여러 테스트 조건의 경우에는 ... 못한다는 점 정도의 문제밖에 없다.

p.235
가장 좋은 것이 테스트를 먼저 작성하고 결함 국소화(Defect Localization, 22 페이지)를 한 것 덕분에 잦은 디버깅(Frequent Debugging, 248 페이지)을 피할 수 있게 해주는 것이다.
-> 가장 좋은 것이 테스트 먼저 작성과 결함 국소화(Defect Localization, 22 페이지) 를 통해서 잦은 디버깅(Frequent Debugging, 248 페이지)을 피하는 것이다.

쉽게 작성하고 싶은 게 당연하다. -> 쉽게 작성할 수 있을수록 좋다.

p,236
도입하기란 훨씬 어려운 문제다 -> 도입하기가 훨씬 어렵다.

p,237
이 주제는 큰 주제라 마이클 페더스Michael Feathers가 레거시 코드 활용 전략Working Effectively with Legacy Code[WEwLC]이라는 이름으로 여기에 관련된 기법에 대한 책을 썼을 정도다.
-> 이 부분은 마이클 페더스<Michael Feathers>가 관련된 기법을 모아서 레거시 코드 활용 전략<Working Effectively with Legacy Code>[WEwLC]이라는 이름으로 책을 냈을 정도로 주제가 광범위하다.

실행에도 시간이 오래 걸린다. -> 실행이 느려진다.

두 번째 문제는 주로 단위 테스트와 관련된 문제인데, 단위 테스트가 느리게 실행되면 개발자들이 자주 실행하지 않으리라는 점이다.
-> 또한 단위 테스트만 놓고 보면, 단위 테스트가 느리면 개발자들이 자주 실행하지 않는 문제가 있다.

비동기 코드를 테스트하는 핵심은 로직과 비동기 접근 메커니즘을 분리하는 것이다.
-> 비동기 코드 테스트의 핵심은 로직과 비동기 접근 메커니즘 분리에 있다.

p.238
너무 귀찮지만 정말 드문 환경에서는 -> 너무 귀찮지만 드물게 일부 환경에서는

p.241
‘잘라 붙이기’가 같은 코드의 복사본을 여기저기 만든다. 이런 코드들은 SUT 변경으로 인해 SUT 메소드의 의미(...)에 영향을 미칠 때마다 유지 보수를 해줘야 한다
-> 'Copy & Paste' 때문에 같은 코드의 복사본이 여기저기 생긴다. 이러면 SUT 메소드의 의미(...) 가 변경될 때마다 모든 복사본에 대해서 유지 보수를 해줘야 한다.

비용이 크게 늘어날 수 있다. -> 비용이 크게 늘어난다.

코드 복사본이 늘어나게 만든다. -> 코드 복사본이 늘어난다.

잘라 붙이이 -> 'Copy & Paste'

테스트는 점점 단순해지지 않고 오히려 더 복잡해진다
-> 점점 더 단순해져야 하는 테스트가 오히려 더 복잡해진다.

p.242
<<테스트 코드 리팩토링>> -> '테스트 코드 리팩토링'

p.243
테스트 커버리지를 하기 위해 -> 테스트 커버리지를 달성하기 위해

순전히 테스트에서 필요한 -> 순전히 테스트에서만 필요한

p.244
할당하자(오버플로우가 발생해서 - 옮긴이). 항법 
-> 할당하자, (오버플로우가 발생해서 - 옮긴이) 항법

p.245
그냥 테스트 때문에 꼭 필요하지도 않은 equals 메소드를 만들 수 있다. equals의 정의를 변경하는 바람에 더 이상 비즈니스 요구를 만족할 수 없게 만들 수도 있다.
-> 필요없는 equals 메소드를 테스트 때문에 만들어야 할 때가 있다. 이렇게 equals의 정의를 변경하다보면 더 이상 비즈니스 요구를 만족시키지 못할 수 있다.

스트레티지 객체Strategy object[GOF]에 두고 기본 값은 
-> 스트레티지 객체에 두고 기본 값은

p.248
<<테스트 코드 리팩토링>> -> '테스트 코드 리팩토링'

== 16장 ==
p.252
이런 문제가 생길 수 있다. -> 이런 문제가 생긴다.

p.254
<<테스트 코드 리팩토링>> -> '테스트 코드 리팩토링'

p.255
어떤 개발자가 실행하면 항상 같은 결과가 나오다가도,
-> 항상 같은 결과가 나오다가도,

테스트 실행기<Test Runner> -> 테스트 실행기<Test Runner>(<> 는 병기표시)

싶겠지만 이렇게 되면 -> 싶겠지만, 이러면

알고 있는 테스트 하나가 실패하지 않고 두 개가 실패했다는 것을 알아차리기는 어려우므로 테스트를 실패하는 채로 두면 추가 실패를 놓치기 쉽다. 초록 막대가 빨간 막대로 바뀌는 걸 보는 게 더 쉽다.
-> 초록 막대가 빨간 막대로 바뀔때는 바로 알아볼 수 있지만, 이미 빨간 막대 상태에서 알고 있는 실패 테스트외에 다른 테스트가 더 실패했다는 것은 알아차리기는 어렵다.

p.256
그림 16.1 의 '~일지도' 를 ? 로 바꿔볼까요?
예 : '테스트 실행 전쟁일지도' -> '테스트 실행 전쟁?' 또는 '테스트 실행 전쟁 확인'

p.257
서로 반응하는 메커니즘은 굉장히 뻔할 수 있다. 예를 들어 데이터베이스를 쓰는 SUT를 테스트할 수도 있고, 이보다는 좀 더 미묘한 것일 수도 있다.
-> 서로 반응하는 메커니즘은 데이터베이스를 쓰는 SUT 테스트 같이 눈에 딱 보일 수도 있고, 좀 더 미묘한 것일 수도 있다.

서로 반응하게 할 수 있다. -> 서로 반응하게 만들 수 있다.

테스트 자동 프레임워크(298 페이지) 모두 피해야
-> 테스트 자동 프레임워크(298 페이지) 에서 최대한 피해야

여러 이유로 서로 반응한다. -> 여러 이유로 서로 반응한다 :

의존 관계가 사라진다. -> 의존 관계가 사라진다 :

p.258
다음과 같을 때 충돌이 시작될 수 있다.
-> 다음과 같을 때 충돌하기 시작한다 :

가장 먼저 실행했다. 또는 -> 가장 먼저 실행했다.

현명한 판단이 아니다. -> 현명하지 않다.

신선한 픽스처Fresh Fixture(311 페이지)를 쓰는 것이 서로 반응하는 테스트에 대한 최고의 해결책이다. 이러면 거의 모든 문제가 해결된다.
-> 서로 반응하는 테스트에 대한 최고의 해결책은 신선한 픽스처<Fresh Fixture>(311 페이지) 를 쓰는 것이다. 거의 모든 문제가 해결된다.

를 써서 테스트들이 픽스처를 -> 로 테스트들이 픽스처를

게으른 설치Lazy Setup(435 페이지) 양쪽 테스트에
-> 지연 설치<Lazy Setup>(435 페이지)로 양쪽 테스트에

생성하게 만들 수 있다 -> 생성하게 할 수 있다

p.263
공유 픽스처를 쓰는 것이 -> 공유 픽스처가

p.264
테스트를 완전히 격리하려면 데이터베이스 샌드박스 같은 어떤 공유 픽스처도 개별 테스트가 끝나면 남아있지 않게 해야 한다.
-> 테스트를 서로 완전히 격리하려면 개별 테스트가 끝난 후에 데이터베이스 샌드박스 같은 모든 종류의 공유 픽스처를 전부 제거해야 한다.

p.265
읽기 락(비관적인 락)을 걸어놓았을 때. 
-> 읽기 락(비관적인 락<pessimistic locking>)을 걸어놓았을 때.(비관적인 락<pessimistic locking>은 먼저 락을 건 다음에 값을 바꾸는 작업을 한다. 낙관적인 락<optimistic locking> 에서는 작업을 먼저 한 후에 값을 덮어쓰기 직전에 이 값이 중간에 변경되지 않았는지를 검사한다. [PEAA] 참고 - 옮긴이)

공유 픽스처(데이터베이스 샌드박스) -> 공유 픽스처(즉, 데이터베이스 샌드박스)

p.267
이로 안해 -> 이로 인해

p.269
그림 16.2 의 '~일지도' 를 ? 로 바꿔볼까요?
예 : '여린 테스트가 아닐지도' -> '여린 테스트 아님?' 또는 '여린 테스트 아닌지 확인'

Caveat emptor!	(매수자위험부담원칙 : 물건을 사는 사람도 물건에 이상이 없는지를 검사해야 한다는 의미 - 옮긴이)

p.270
상호작용하려고 필요한 사용자 -> 상호작용하는데 필요한 사용자

p.272
문맥에 민감함이 있다. 다시 말해 SUT를 너무 전부 테스트하려고 하는 것일 수 있다.
-> 문맥에 민감함이 있는 것이다. SUT를 너무 크게 잡고 테스트하는 것일지도 모른다.

p.273
동료 소프트웨어 개발자가 -> 동료 소프트웨어 개발자 A 가

요청했습니까?”라고 물었다 -> 요청했습니까?”라고 따졌다.

동료는 -> A 는

그녀는 -> A 는

p.274
그녀가 -> A 가

그녀는 -> A 는

p.275
검증하려는 기능이 시간이나 날짜에 어떤 식으로든 의존한다.
-> 검증하려는 기능이 시간이나 날짜에 의존관계가 있다.

SUT를 헤갈리는 데 있다 -> SUT를 헷갈리는 데 있다

p.276
이것은 레이어 횡단 테스트를 만들기 위해 광범위하게 모의 객체Mock Object(544 페이지)를 쓰는 특징이 있다.
-> 이런 테스트에서는 레이어 횡단 테스트를 만들기 위해 광범위하게 모의 객체<Mock Object>(544 페이지)를 쓰는 경향이 있다.

p.278
무엇이 문제인지 알기 어렵다. 이럴 때는 무엇이 잘못됐는지 알기 위해 디버거를 써야 한다.
-> 문제를 파악하기 어렵다. 결국에는 디버거로 어디가 문제인지를 찾아봐야 한다.

그렇지 않다면 다음과 같다. -> 그렇지 않다면 다음을 의심해 봐야 한다.

단위 테스트가 없는 것일 수 있다 -> 단위 테스트가 없다

없는 것일 수 있다. -> 없다.

이런 일이 생길 수 있다. -> 이런 일이 생긴다.

(어떤 사람들은 이런 접근법을 ...) -> (이런 접근법을 ...)

으로 인해 생길 수도 -> 때문에 생길 수도

p.279
방금 집어넣은 코드가 어디에 있는지 아니까 말이다!
-> 방금 추가한 코드만 확인하면 되니까 말이다!

낭비하기 십상이다. -> 낭비하기 쉽다.

잦은 디버깅이 있을 경우 소프트웨어를 개발해야 하는 시간 중 반나절이나 그 이상을 디버깅이 있을 때마다 날려먹으므로 생산성을 감소시키고 개발 일정을 비현실적으로 만든다.
-> 잦은 디버깅을 하다보면 소프트웨어를 개발하면서 디버깅을 할 때마다 반나절 이상을 날려먹기 일수여서 생산성이 떨어지고 개발 일정이 한없이 늘어진다.

수동으로 디버깅 하지 않아도 될까 -> 수동으로 디버깅을 안 해도 될까

테스트를 해 좋은 결함 국소화를 보장해야 한다. 
-> 테스트를 통해서 높은 결함 국소화를 보장해야 한다. 

p.280
사람이 직접 ... 검증해야 할 수도 있다.
-> 또는 사람이 직접 ... 검증해야 한다.

이런 작업으로는 서버를 설정한다거나 서버 프로세스를 실행한다거나 미리 만든 픽스처Prebuilt Fixture(429 페이지)를 설치하기 위한 스크립트를 실행하는 등의 작업이 있다.
-> 이런 작업에는 서버 설치, 서버 프로세스 실행, 미리 만든 픽스처<Prebuilt Fixture>(429 페이지) 설치 스크립트 실행 등이 있다.

p.281
없을 때에도 발생할 수 있다. -> 없을 때에도 생긴다.

완전 자동 테스트를 만들려고 한다는 걸 명심해야 한다.
-> 완전 자동 테스트를 만드는 게 목표라는 점을 명심하자.

문제가 개발 환경에서 소프트웨어를 실행할 수 없게 만드는 부분에 있다면
-> 개발 환경에서 소프트웨어를 실행할 수 없는게 문제라면

p.282
SUT의 많은 이벤트는 -> SUT의 여러 이벤트는

시스템 다른 부분의 -> 다른 시스템의

에서 확인하라 -> 에서 확인하자

p.283
망가졌으므로 생긴다. -> 망가졌기 때문에 생긴다.

p.285
이런 게 느린 컴포넌트를 쓸 때 생길 수 있는 가장 일반적인 문제 중 하나다.
-> 느린 컴포넌트를 쓰면 이런 문제를 쉽게 볼 수 있다.

p.286
더 좋은 방법이다. -> 더 좋다.

테스트하려는 소프트웨어에서 스레드나 프로세스를 ... 그것들을 시작, 실행 후 예상한 부작용이 발생했는지 검증할 때까지 기다려야 한다면 실행이 느릴 수밖에 없다.
-> 테스트하려는 소프트웨어가 스레드나 프로세스를 ... 그것들을 시작, 실행한 후 예상한 부작용이 발생했는지 검증할 수 있을 때까지 기다려야 한다면 테스트가 느릴 수밖에 없다.

p.287
이렇게 하려면 테스트 가능한 컴포넌트 ... 구현해야 할 수도 있다.
-> 테스트 가능한 컴포넌트 ... 구현하는 것도 한 방법이다.

이 문제의 분명한 원인은 너무 테스트가 많다는 데 있다.
-> 분명 테스트가 너무 많다는 게 원인이다.

p.288
덜 분명한 원인으로는 너무 많은 테스트를 너무 자주 실행하는 것이다!
-> 너무 많은 테스트를 너무 자주 실행하는 것도 원인 중 하나일 수 있다.

따라서 인터페이스가 변경되면 이들 테스트 역시 같이 갱신해야 한다. 흠... 문서로서의 테스트(23 페이지)랄까. 좋은 걸!
-> 인터페이스가 변경되면 (컴파일이 안 되기 때문에) 테스트 코드도 같이 갱신해야 한다. 그야말로 문서로서의 테스트(23 페이지) 역할을 하는 것이다!

== 17장 ==
p.290
자동 테스트에서 계속 버그가 발견된다. -> 자동 테스트에서 계속 버그가 나온다.

p.291
이들 민감함이 무언인가를 바꿔 -> 이들 민감함이 무엇인가를 바꿔

제거하기는 쉽지 않아도 결과적으로 -> 제거하기란 만만치 않지만 결과적으로는

p.293
더 단단하게 만들기 -> 더 견고하게 만들기

비애자일 -> 비-애자일

원한다면 계속 가던 길을 가자. 아니라면 바로 지금 바로 뭔가를 하자.
-> 그래도 상관없다면 계속 하던대로 해라. 아니라면 지금 바로 조치를 취하자.

p.294
들어 있어야 한다 -> 포함되어야 한다

물론 관리자는 개발자가 자기 계발하는 것을 최대한 지원해줘야 한다.
-> 물론 관리자는 개발자들의 자기 계발을 최대한 지원해야 한다.

시간도 들어 있어야 한다 -> 시간도 포함해야 한다.

p.296
기존 테스트 유지 보수에 너무 힘이 많이 든다.
-> 기존 테스트를 유지 보수하기가 너무 힘들다.

새로운 기능 개발에 시간이 점점 오래 걸린다
-> 새로운 기능을 개발하는데 드는 기간이 점점 늘어난다.

과도하게 변경해줘야 한다. -> 많이 고쳐야 한다.

p.297
테스트를 유지 보수하는 노력이 너무 들기 때문에 팀의 생산성이
-> 테스트 유지 보수 때문에 팀의 생산성이

"제품 코드 작성은 꼭 해야 하지만 테스트 유지 보수를 꼭 할 필요는 없잖아?" 라고 생각한다. 이런 문제를 계속 놔두면 팀이나 관리자들은 자동 테스트를“쓸모가 없다”고 보고 테스트를 치워버려 지금까지 테스트 자동화에 쏟았던 노력을 물거품으로 만든다.
-> "제품 코드는 꼭 작성해야 하지만, 테스트 코드까지 이렇게 유지 보수해 줘야 하나?" 라고 생각하게 된다. 이렇게 계속 놔주면 결국에는 팀이나 관리자가 자동 테스트를 "쓸모없다" 며 제거해버려 지금까지 쏟아왔던 노력이 물거품이 될 것이다.

p.298
이 목표에서 부족한 점이 있는만큼 높은 테스트 유지 비용이 생길 가능성이 높아질 것이다.
-> 목표에 다가갈 수록 테스트 유지 비용이 낮아질 것이다.

않을 더 좋은 방법을 찾을 수 있게 개발자들을 독려할 수 있다.
-> 않는 더 좋은 방법을 찾도록 개발자들을 독려할 수 있다.

p.300
제품에 수많은 버그가 남아있다 -> 제품에서 버그가 많이 남아있다.

놓친 테스트로 인해 생길 -> 놓친 테스트 때문에 생길

p.302
[Test Fixture] 속성을 -> [TestFixture] 속성을

p.303
...에서 타고 들어가 -> ...를 타고 들어가

(변덕스러운 테스트)) -> (변덕스러운 테스트)

p.304
고객 테스트는 통과하는 기능을 -> 고객 테스트를 통과하는 기능을

p.305
SUT 내에서 의존 컴포넌트DOC의
-> SUT 내에서 의존 컴포넌트<depended-on component. DOC>의

방법이 없을 때 보통 테스트 -> 방법이 없을 때 테스트

테스트 중에 코드가 실행되는 걸 한 번도 본 적이 없거나 코드 커버리지 도구를 통해 확실하게 확인해 볼 수도 있다.
-> 테스트 하는 동안에 특정 코드가 (breakpoint 나, printf 를 통해서 : 옮긴이) 한 번도 실행이 안 된다는 걸 알고 있을 수도 있고, 코드 커버리지 도구로 실행 안 되는 코드를 정확하게 알 수도 있다.

p.306
제대로 구현 못한 -> 제대로 구현 안 된

두려움 때문에 무자비한 리팩토링... -> 두려움 때문에 과감한 리팩토링..

여기에는 테스트에서 직접 확인할 수 없는 ‘부작용’(...), 즉 간접 출력이 있을 수 있다.
-> 테스트에서 직접적으로는 확인할 수 없는 "부작용" (파일, 레코드에 쓰기, 다른 객체나 컴포넌트의 메서드 호출하기) 같은 간접 출력이 여기에 해당한다.

= 3 부 =
== 18장 ==
(18장 전체의 오른쪽 페이지의 장 표기가 17장으로 표기 되고 있습니다.)

p.312
방식으로 테스트를 자동화할 수 있다. -> 방식으로 테스트를 자동화한다.

p.313
도구를 써서 SUT로 작업하는 동안 발생하는 상호작용을 모니터링한다.
-> SUT로 작업하는 동안 발생하는 상호작용을 도구<tool>를 통해서 모니터링한다.

기술 지식이 필요할 수 있다. -> 기술 지식이 필요한 경우도 있다.

p.314
꽤 자주 주기적으로 -> 자주 주기적으로

정의 기능이 없어 힘들다. -> 정의 기능이 없어 쉽지 않다.

새로 기록 테스트에서 -> 먼저 기록 테스트에서

다시 재기록하면 된다. -> 재기록하면 된다.

테스트를 사용할 때 이런 방식을 쓴다. -> 테스트를 만들 때 이렇게 한다.

p.315
만든 툴을 구하거나 -> 만든 툴을 구하는 것이고,

사실 마이크로소프트의 엑셀에 -> 마이크로소프트의 엑셀에

p.316
기록 테스트를 도입할 수도 있다. -> 기록 테스트 도입을 고려해 볼 만 하다.

회귀 테스트를 하기 위해 사용된다. -> 회귀 테스트를 하기 위해 작성되었다.

actual 요소<elements>, 특성<attributes> -> 병기표시

p.317
복잡하기가 이를 데 없다. -> 굉장히 복잡하다.

기록돼 있는지를 볼 수 있다. 바로 -> 기록돼 있는지를 볼 수 있는데, 바로

p.320
경험을 볼 수 있다. -> 경험을 소개한다.

p.321
설계를 끌어내는 데 -> 설계를 이끌어내는 데 

p.322
SUT 의 기능을 -> 테스트 대상 시스템<system unter test, SUT>의 기능을

테스트 대상 소프트웨어 같은 -> 테스트 대상 소프트웨어와 같은

이런 용도로 쓰기 어렵다. -> 적합하지 않다.

있게 만들고 나면 -> 있게 만든 후에는

p.323
SUT 같은 언어를 -> SUT 에서 쓰는 언어와 같은 언어를

p.324
단점이라면 이런 이름으로 인해 탐색적 ... 따라하는 스크립트와 헷갈릴 수 ...
-> 단점이라면 탐색적 ... 따라하는 스크립트(어떻게 테스트해야 하는지 과정이 적혀있는 종이 : 옮긴이)와 이름이 비슷해 헷갈릴 수 ...

p.325
과정도 동일할 수 있다. -> 과정도 동일할 때가 많다.

p.327
테스트 적용 범위를 최대로 할 수 있고, 더 많은 필요한 테스트도 쉽게 추가할 수 있다.
-> 테스트 적용 범위를 최대로 할 수 있고, 더 쉽게 테스트를 추가할 수 있다.

테스트를 데이터 주도 방식으로 만들면 설정 데이터나 메타 객체의 값을 변경했을 때 데이터 주도 테스트를 변경하면 된다. 이게 훨씬 자연스럽다.
-> 그보다는 데이터 주도 방식으로 테스트를 만들어, 먼저 데이터 주도 테스트를 변경하고, 이어서 설정 데이터나 메타 객체를 변경하는 게 훨씬 자연스럽다.

두 자산이 시간에 따라 어떻게 발전돼 왔는지를 알고 잘못 변경됐을 때 되돌릴 수 있으려면 
-> 두 파일이 시간에 따라 어떻게 변경되어왔는지를 알고, 잘못 변경됐을 때 되돌리고 싶다면

영업 팀에게는 -> 사업 팀 사람들에게는

p.328
나중에 발견됐을 때 고치느라 고생하는 걸 막을 수 없다. -> 나중에 고치느라 고생하게 된다.

과정에 추가하려면 어떤 고객 테스트가 통과했는지 표시할 방법이 필요하다. 코드를 커밋하기 전에 모든 고객 테스트가 통과한다고 주장하진 않기 때문이다.
-> 과정에 추가하려면 이전에 통과한 고객 테스트가 어떤 것이었는지를 기록할 방법이 필요하다. 관련 코드를 커밋하기도 전에 고객 테스트를 전부 통과시킬 수는 없기 때문이다.

Ward Cunningham 이 -> 워드 커닝햄<Ward Cunningham> 이

p.329
픽스처 종류가 엄청나게 많다. -> 픽스처 종류가 다양하다.

p.330
일반적으로 xUnit이 Fit보다는 -> 일반적으로 Fit보다는 xUnit이

고객 테스트의 경우에는 반대로 생각하면 된다.
-> 반대로 고객 테스트 입장에서는 xUnit 보다 Fit 이 훨씬 편하다.

결함 국소화<Defect Localization>(22 페이지)를 잃어버리게 된다.
-> 결함 국소화<Defect Localization>(22 페이지)가 사라진다.

이해할 수 있게 알려줄 방법이 필요하다 -> 이해할 수 있게 해 줘야 한다

p.334
만들면 다음과 같. -> 만들면 다음과 같다.

p.337
테스트 자동 프레임워크 사용은 완전 자동 테스트(26 페이지) 작성에 드는 노력을 최소화할 수 있는 길이다.
-> 테스트 자동 프레임워크를 쓰면 완전 자동 테스트(26 페이지) 작성에 드는 노력을 최소화할 수 있다.

p.339
보이므로 마켓팅할 때 좋다 -> 보이므로 마케팅에 좋다.

p.340
켄트 벡<Kent Beck>은 TDD를 설명하기 위해 파이썬으로 테스트 자동 프레임워크를 만드는 과정을 보여준다. '스스로 자신의 뇌를 수술하기' 와 비슷한 접근 방식에서 켄트 벡은 새로 ... 어느새 만들어진 테스트 자동 프레임워크를 사용한다. 이런 식의 응용은 TDD와 부트스트랩핑 모두에게 좋은 예다.
-> 켄트 벡<Kent Beck>은 TDD를 설명하기 위해 '스스로 자신의 뇌를 수술하기<doing brain surgery on yourself>' 와 비슷한 접근 방식으로 새로 ... 어느새 테스트 자동 프레임워크를 사용하게 되는 과정을 파이썬 언어로 보여준다. 이것은 TDD 와 부트스트랩핑<bootstrapping> 양쪽 모두에게 좋은 예다.

p.341
하지만 최소 픽스처를 만드는 것은 다른 테스트에서 같이 사용되는 공유 픽스처가 더 어렵다.
-> 하지만 다른 테스트에서 같이 사용되는 공유 픽스처와 함께 최소 픽스처를 만드는 것이, 신선한 픽스처와 함께 최소 픽스처를 만드는 것보다는 더 어렵다.

p.342
객체 자체는 어떤 이유에서 -> 객체 자체는 컴파일 등의 이유 때문에

만드는 데에나 도움이 될 것이다. -> 만드는 것 외에는 아무런 도움이 안 된다.

(SUT가 잘못된 입력을 받았을 때를 테스트) -> (SUT가 잘못된 입력을 받은 경우를 테스트)

p.345
“실제로 이렇게 하는 경우가 있을까요?" -> "과연 표준 픽스처를 쓰는 사람이 실제로 있을까요?"

p.346
다른 테스트에서만 필요한 객체를 생성하느라
-> 지금 실행중인 테스트에서는 전혀 필요없는 객체를 생성하느라

테스트 하니스 -> 테스트 하니스<harness>

p.348
정확하게 얘기하자면 여러 테스트를 표준 픽스처로 바꾸는 건 ‘리팩토링’이라 할 수 없는데, 이것은 테스트의 기능을 실제로 변경하기 때문이다.
-> 여러 테스트를 표준 픽스처로 바꾸다보면, 실제로 테스트의 기능을 변경하기 때문에 엄밀하게 말해서 '리팩토링'은 아니다.

p.350
픽스처 생성 로직를 -> 픽스처 생성 로직을

p.353
변덕스러운 테스트의 형태가 나타나게 된다. -> 변덕스러운 테스트가 생긴다.

p.354
픽스처 설계 재사용이라고 -> 픽스처 설계(코드) 재사용이라고

p.356
하지만 이번 시작 예제 같은 경우에는 미리 만든 픽스처<Prebuilt Fixture>(429 페이지)도 쉽게 사용할 수 있다. 어느 쪽이든 이러다보면 언제든지 테스트끼리 서로 반응할 수 있다.
-> 조금만 고쳐보면 미리 만든 픽스처<Prebuilt Fixture>(429 페이지) 라고도 할 수 있다. 양쪽 다 쉽게 테스트끼리 반응할 수 있다.

싶다고 가정해보자. -> 싶다고 해보자.

신선한 표준 픽스처<fresh Standard Fixture> -> 신선한 표준 픽스처<Fresh Standard Fixture>

다음과 같자. -> 다음과 같다.

p.357
있다는 점에 주의하자. -> 있다는 점을 놓치지 말자.

p.360
‘메모리로’ 실행할 수 있었다. 테스트 실행 시간도 엄청 줄일 수 있었다.
-> ‘메모리'로 실행할 수 있었다. 테스트 실행 시간도 많이 줄일 수 있었다.

p.361
6,700개 있다. -> 6700 개 있다. (괜히 , 붙이니까 오히려 6~700 개로 보이네요. , 제거 부탁드립니다)

p.362
서버에서는 모든 개발자 머신에 대해 계정을 설치했다.
-> 서버에 모든 개발자 계정을 설치했다.

상당한 비용으로 작용한다. -> 상당한 비용이 든다.

p.363
레퍼런스를 유지해야 한다. 그러면 이미
-> 레퍼런스를 유지해야 한다. 그래야 이미

p.365
(처음 한 번만 변경될 수 있다 - 옮긴이) -> (처음 한 번만 변경 가능하다 - 옮긴이)

p.368
꼭 실행돼야 한다! -> 꼭 실행되어야 함!

두 번째 부분에는 테스트에서 변경하고 삭제해야 하는 객체들이 들어있다. 이 부분은 테스트에서 신선한 픽스처로 만들어야 한다.
-> 두 번째 부분은 테스트에서 변경하고 삭제해야 하는 객체들이 들어있는 신선한 픽스처다.

p.371
애매한 테스트<Obscure Test>(186 페이지)가 생기기 쉽다. 
-> 애매한 테스트<Obscure Test>(186 페이지)가 되기 쉽다

p.372
통로를 만들면 빠르게 할 수 있다. -> 통로를 만들어 빠르게 만들 수 있다.

변경될 때 생길 수 있다. -> 변경될 때 생긴다.

SUT API로는 할 수 없는 테스트 시나리오를 만들 수도 있다. 
-> SUT API로는 불가능한 테스트 시나리오를 만들 수 있는 장점도 있다.

특히 SUT가 해당 테이블을 쓰지 않거나 쓰더라도 특정한(그리고 올바른) 데이터 설정만 쓴다면 뒷문 설치 외에는 방법이 없다.
-> 특히 SUT가 해당 테이블을 쓰지 않거나, 쓰더라도 특정한(그리고 올바른) 데이터 설정만 쓴다면 뒷문 설치 외에는 방법이 없다. (다른 어플리케이션에서 테이블에 데이터를 집어넣어 주고, SUT 는 읽기만 하는 경우에는, 테스트에서 SUT 를 가지고 픽스처를 만들기 위해 원하는 테이블에 데이터를 집어넣을 방법이 없다 : 옮긴이)

뒷문 검증을 하면 SUT의 실행 후 -> 뒷문 검증은 SUT의 실행 후

p.373
검증할 수 없다. 레이어 횡단 테스트로
-> 검증할 수 없다. 이럴 때는 레이어 횡단 테스트로

p.374
해당 레코드를 SUT 로직을 우회해 데이터베이스에 직접 집어넣을 수 있는
-> SUT 로직을 우회해 데이터베이스에 해당 레코드를 직접 집어넣을 수 있는

필요하면 언제든지 사용하면 된다. -> 필요할 때마다 사용하면 된다.

SUT가 입력 값을 받는 방식(예: 다른 ‘업로드upstream’ 프로그램)과는 달리
-> SUT가 일반적으로 입력 값을 받는 방식과는 달리

p.375
SUT의 여러 ‘편집 점검edit check’(입력 값 검사) 루틴을 
-> SUT의 여러 ‘입력 값 검사<edit check>’ 루틴을 

p.376
로거에 호출해 -> 로거<logger>에 호출해

p.380
테스트 픽스처 설치에 뒷문 검증 -> 테스트 픽스처 설치에, 뒷문 검증

집중하더란다. -> 집중했다.

p.382
지속 방식이나 -> 영속 방식이나

n - 1번째 레이어는 테스트 -> n - 1번째 레이어를 테스트

테스트하는 게 훨씬 간단하다. -> 테스트하는 게 훨씬 쉽다.

하향식 테스트로는 한 두 개 정도의 기본 시나리오만 검증하면 된다.
-> 한 두 개 정도의 기본 시나리오만 하향식 테스트로 검증하면 된다.

p.384
영향을 미칠지 않을 수도 -> 영향을 미치지 않을 수도

p.387
한 군데에서는 비즈니스 -> 한 곳에서는 비즈니스

'복사하고 붙이기’ -> 'Copy & Paste'

p.388
이런 방법을 쓰면 -> 이렇게 하면

== 19장 ==
p.393 의 <> 병기 표시

p.394
그림 Test Suite Object -> 테스트 스위트 객체

단언문을 포함해야 한다. -> 단언문을 넣어야 한다.

언어별 구조로 -> 언어에 따라서

생성자 테스트<Constructor Test>라면 -> 생성자 테스트<Constructor Test>에서는

p.395
들어 있으면 어느 테스트에서 그런 기본 동작을 ... 쉬워진다.
-> 들어 있을 때, 어느 테스트에서 SUT 의 기본 동작을 ... 쉽다.

결국 이런 기본 3가지 유형에 모두 포함된다. -> 결국 기본 3가지 유형에 모두 포함된다

p.396
테스트 독자 입장에서는 예외가 -> 테스트를 읽는 사람도 예외가

문제를 해결하기 훨씬 쉽다. -> 문제 해결에 훨씬 도움이 된다.

p.397
정상적으로 발생시킬 수는 없는 예외에 대해서는 -> 정상적인 방법으로는 발생시킬 수 없는 예외라면

테스트 실패로 나타나야 하기 때문이다. -> 테스트 실패로 나타날 것이기 때문이다.

We should not write an Expected Exception Test for exceptions that the SUT might raise but that we cannot force to occur on cue, because these kinds of errors should show up as test failures in the Simple Success Tests.

들여다봐야 할 수도 있다. -> 들여다봐야 할 수도 있다.

p.403
'복사하고 붙이기' -> 'Copy & Paste'

p.406
이해하기 어려울 수 있다. -> 이해하기 어렵다.

문서로서의 테스트(23 페이지)를 생각해보면 중요한 테스트 로직이 시스템 뒷정리 코드랑 섞여 애매해지는 건 싫을 것이다.
-> 문서로서의 테스트(23 페이지)를 만들고 싶다면, 중요한 테스트 로직이 시스템 뒷정리 코드과 섞여서 알아보기 어렵게 되는 건 피하고 싶을 것이다.

애매한 테스트<Obscure Test>(186 페이지)가 될 수 있다.
-> 애매한 테스트<Obscure Test>(186 페이지)를 만들게 된다.

작은 단일 조건 테스트<Single Condition Test>(45 페이지)가 있는 더 낫다.
-> 작은 단일 조건 테스트<Single Condition Test>(45 페이지)가 더 낫다.

p.409
문서로서의 테스트(23 페이지)를 할 수 있게 한다.
-> 문서로서의 테스트(23 페이지)를 만들 수 있게 해 준다.

p.410
프레임워크 개발자가 결정한다. -> 프레임워크에 따라 결정된다.

p.413
가장 흔하게 퍼지 동등 단언문을 쓴다.
-> 가장 흔하게 퍼지 동등 단언문을 쓴다. (예 : UnitTest++ 에서 퍼지 동등 단언문 CHECK_CLOSE(3.14, 3.1415, 0.01); 는 통과한다. 이 때 0.01 은 오차 허용범위다. - 옮긴이)

p.414
스몰토크의 SUnit hould: ->
스몰토크의 SUnit
	should:
(should : ... 코드를 한 줄 밑에 tab 을 하나 더 둬서 적어주세요. 아래 루비 코드도 마찬가지)

p.416
다르다는 점을 주의해서 살펴보자. -> 다르다는 점에 주의하자.

p.417
블록을 지원하는 언어에서 -> 다음은 블록을 지원하는 언어에서

p.419
파일 이름과 줄 번호가 단언 메시지에 자동으로 보이게 한다.
-> 파일 이름과 줄 번호를 단언 메시지에 알아서 추가해 준다.

p.420
실패했는지를 알 수 없다. 그다지 쓸모가 없지 않은가?
-> 실패했는지를 알 수 없기 때문에 큰 도움이 안 된다.

p.421
물론 변수에 의도가 드러나는 이름<Intent-Revealing Name>[SBPP]이 붙어있다면
-> 물론 변수 이름이 a,b 가 아닌 의도가 드러나는 이름<Intent-Revealing Name>[SBPP] 이었다면

p.423
(정렬이 제대로 안 되어 있네요)

p.427
컴포짓<composite> -> 컴포짓<Composite>

p.429
상단 텍스트 페인pane은 -> 상단 텍스트창에서는

아래 텍스트 페인은 -> 하단 텍스트창에서는

p.431
왼쪽 페인pane은 -> 왼쪽 창은

p.448
전통적인 방법으로는 테스트 메소드 이름을 ‘test’로 시작하는 식으로 이름을 이용하는 방법이 있다.
-> 전통적인 방법에서는 테스트 메소드 이름이 ‘test’로 시작하는지를 보고 안다.

다른 방법으로는 닷넷이나 ...  최신 버전에서 ... 표시해주는 방법이다.
-> 닷넷이나 ... 최신 버전에서처럼 ... 표시해주는 것도 한 방법이다.

p.454
1단계, 2단계 지워도 될 거 같습니다. 아니면 숫자 표시.

p.459
좀 더 유연한 방식으로는 이름에 ... 클래스를 선택하는 수가 있다.
-> 좀 더 유연한 방식은 이름에 ... 클래스를 선택하는 것이다.

p.460
유연하지 못하게 된다. -> 유연하지 못하다.

== 20장 ==
p.462
맨 앞부분에 둔다. -> 맨 앞에 둔다.

p.463
무딘 픽스처 설치 코드를 -> 픽스처 설치 코드를

1단계는 모든 생성 -> 먼저 모든 생성

p.466
테스트 독자들이 '큰 그림'을 읽을 수 있게 해야 한다. 
-> 테스트를 읽을 때 '큰 그림'을 볼 수 있게 해야 한다.

setUp 메소드 재사용 하나로 인해 -> setUp 메소드 재사용 하나 하겠다고

p.468
코드를 테스트에 남겨둬 테스트를 읽을 때 어떤 일이 벌어지는지를 알 수 있게 하면 테스트에서 테스트 독자에게 ‘큰 그림’을 전달할 수 있다.
-> 코드를 테스트에 남겨두면, 나중에 테스트 코드를 볼 때 어떤 일이 벌어지는지에 대한 '큰 그림'을 보여줄 수 있다.

p.470
어려울 것이다! -> 어려울 것이다.

p.471
간단한 형태는 적당한 생성자에 필요하지만 인자로 주어지진 않은 기본 값을 넘겨줘 호출하는 것이다.
-> 간단한 생성 메소드에서는 적당한 객체 생성자를, 필요하지만 인자로 주어지진 않은 기본 값으로 호출한다.

p.472
생성 메소드의 여러 변형은 좀 더 자세히 살펴볼 필요가 있다.
-> 생성 메소드의 여러 변형을 좀 더 자세히 살펴보자.

약간의 맞춤 주문이 필요할 경우가 있다. -> 약간씩 커스터마이징을 해 줘야 할 때가 있다.

익명 생성 메소드는 자신이 생성하는 객체에 필요한 고유 식별자용 별개의 생성 값<Distinct Generated Value>(생성 값, 723 페이지)을, 자신이 받은 인자는 꼭 고유하지 않더라도 알아서 생성해준다.
-> 익명 생성 메소드는 객체를 생성할 때 인자값이 고유한지 여부와는 상관없이 고유 식별자용 별개의 생성 값<Distinct Generated Value>(생성 값, 723 페이지)을 알아서 생성해준다.

피할 수 있게 해주므로 중요하다. -> 피할 수 있게 해 준다는 점에서 중요하다

p.474
사실, 픽스처를 정의하는 고급 언어<Higher-Level Language>(41 페이지)를 정의하는 것이다.
-> 사실상, 픽스처를 정의하는 고급 언어<Higher-Level Language>(41 페이지)를 정의한다고 볼 수 있다.

티가 나지 않을 날 수도 있다. -> 티가 나지 않을 수도 있다.

p.480
신선한 픽스처<Fresh Fixture>(311 페이지) 방식을 사용해 테스트 한 군데에서만 쓰이는 최소 픽스처<Minimal Fixture>(302 페이지)를 만들수 있다.
-> 하나의 테스트에서만 사용되는 최소 픽스처<Minimal Fixture>(302) 를 신선한 픽스처<Fresh Fixture>(311) 로 만들어준다.

이런 방법은 인라인 설치<In-line Setup>(408)이나 위임 설치
-> 이런 방법은 인라인 설치<In-line Setup>(408)나 위임 설치

p.486
편해서이든 꼭 필요해서든지 -> 편리를 위해서이든 꼭 필요해서든지

p.487
만들면 해결할 수 있다. -> 만들어 해결할 수 있다.

p.493
설치하게 만들면 해결할 -> 설치하게 만들어 해결할

p.494
대부분의 xUnit에서는 전체 테스트 스위트에 대해 설치 데코레이터<Setup Decorator>를 쓰는 것 외에는 이런 점을 지원해 주지 않는다. 
-> 대부분의 xUnit에서는 전체 테스트 스위트에 대한 설치 데코레이터<Setup Decorator>정도 외에는 이 부분을 지원하지 않는다. 

모든 골칫거리도 같이 들어 있다. -> 모든 단점도 함께 가지고 있다.

p.495
하지만 tearDown 메소드 호출 횟수와 비교하려고 테스트 스위트 객체(387 페이지) 안에 얼마나 많은 테스트케이스 객체(382 페이지) 가 있는지 알아내기 어렵다.
-> 하지만 그럴려면 먼저 테스트 스위트 객체(387 페이지) 안에 들어있는 테스트케이스 객체(382 페이지) 갯수를 얻어온 다음, 이 값을 tearDown 메소드 호출 횟수와 비교해야 하는데 이게 어렵다.

테스트 스위트 객체 단계에서 tearDown 메소드를 호출하는 로직을 테스트 실행기에 추가하는 것은 스위트 픽스처 설치를 구현하는 것과 다를 게 없다.
-> 테스트 스위트 객체 수준에서 tearDown 메소드를 호출하도록 테스트 실행기<Test Runner>에 로직을 추가하는 작업은 스위트 픽스처 설치를 구현하는 것과 맞먹을 것이다.

p.497
한 번만 설치하게 하는 방법이다. -> 한 번만 설치하는 것이다.

p.500
공유 픽스쳐<Shared Fixture> -> <> 병기표시

p.502
@BeforeClass 속성을 어떤 메소드가 첫 테스트 메소드가 호출되기 전에 호출돼야 하는지를 지정하는 데 쓰인다.
-> 첫 테스트 메소드가 호출되기 전에 어떤 메소드가 호출돼야 하는지를 @BeforeClass 어노테이션으로 지정한다.

p.504
속성을 써서 테스트 자동 프레임워크에게 특정 메소드를 지정할 수 있다.
-> 속성을 써서 특정 메소드를 지정할 수 있다.

p.506
자바/펄/루비 -> Java/Perl/Ruby (모든 프로그래밍 언어는 영어로 표기합니다)

p.508
편해서나 꼭 필요해서 -> 편해서, 또는 꼭 필요해서

p.509
하드 코딩된 값<Hard-Coded Value>(리터럴 값,714 페이지)를 쓰고 있어
-> 하드 코딩된 값<Hard-Coded Value>(리터럴 값,714 페이지)을 쓰고 있어

대신 쓸 수도 있다. -> 대신 써도 된다.

p.517
여린 테스트<Fragile Test>(239 페이지)를 막는 데 도움이 된다.
-> 여린 테스트<Fragile Test>(239 페이지)를 막아준다.

p.521
하단 페인(pane) -> 하단 창
상단 페인 -> 상단 창

p.523
상단 페인(pane) -> 상단 창
하단 페인 -> 하단 창

자동 프레임워크(298 페이지)이 알아서 -> 자동 프레임워크(298 페이지)가 알아서

== 21 장 ==
p.526
SUT의 상태를 알아보는 작업도 들어있다.
-> SUT의 상태를 알아보는 작업도 포함된다.

p.527
코드 패스로 인해 -> 코드 경로 때문에

p.528
기대 상태 명세를 한다면 -> 기대 상태 명세를 만들때는,

생성 메소드<Parameterized Creation Method>(생성 메소드, 415 페이지)를 쓴다.
-> 생성 메소드<Parameterized Creation Method>(생성 메소드, 415 페이지)를 쓰는 게 좋다.

p.529
을 생기게 하는 것보다 낫다 -> 이 생기게 하는 것보다 낫다

p.531
이미 속성 일부를 SUT의 인자로 쓰고 있으므로 테스트의 픽스처 설치 단계에서 기대 객체를 만든 후 SUT 인자로 기대 객체의 속성을 쓰기로 한다.
-> 이미 속성 일부를 SUT 의 인자로 쓰고 있었기 때문에, 픽스처 설치 단계에서 기대 객체를 만든 후, 이 객체의 어트리뷰트를 SUT 인자로 사용했다.

p.542
어떤 것이 다르다는 -> 어디가 다르다는

SUT와의 상호작용에 연관돼 있다. -> SUT와의 상호작용과 관련있다.

넣는 게 좋을 수 있다. -> 넣는 게 좋다.

p.543
단언 메소드가 SUT다 보니 -> 맞춤 단언문 테스트에서는 단언 메소드가 SUT다 보니

p.544
와 비슷하게 하는 게 가장 쉬운 방법이다. -> 이 가장 쉽다.

일부 xUnit 에서 생길 수 있는 복잡한 문제를 간단하게 경고한다.
-> 일부 xUnit 계열에서 생길 수 있는 복잡한 문제에 대해 간략하게 집고 넘어가자.

테스트 실행 처리 코드가 테스트 실행기<Test Runner>(377 페이지)에서 발생하지 않을 경우에는 맞춤 단언문 테스트에서 생긴 에러나 예외를 잡아냈음에도 불구하고 fail이나 내장 단언문을 호출했을 때 실패 로그만 남을 수 있다.
-> 일부 xUnit 에서는 테스트 실패 처리 코드가 테스트 실행기<Test Runner>(377 페이지)에서 호출되지 않으면, 맞춤 단언문 테스트에서 에러나 예외를 잡아냈음에도 불구하고 따로 fail이나 내장 단언문을 호출했을 때만 실패 로그가 남는 경우가 있다.

같은 단언문들이 반복된다. -> 같은 단언문이 반복된다.

p.547
단언 룰렛이 생기지 않게 한다. -> 단언 룰렛이 생기지 않는다.

p.548
공간을 줄이기 위해 -> 지면을 아끼기 위해

p.549
이러면 부작용이 없는 함수(맞춤 단언문)에서 SUT의 상태를 변경하는 조작으로 변경되므로 맞춤 단언문의 의미와 더 이상 맞지 않는다.
-> 이러면 맞춤 단언문이 부작용이 없는 함수<function>가 아닌 SUT의 상태를 변경하는 조작<operation>이 되어버리기 때문에 더 이상 맞춤 단언문이 아니게 된다.

'vefiry' -> 'verify'

p.555
테스트 전 데이터를 확인하게 수정해야 할 것이다.
-> 테스트 전 데이터를 확인하는 처리로직이 필요하게 될 것이다.

p.556
실행한 동안 -> 실행하는 동안

assertAllFlightsIncludedInDtoList 를 한 tab 앞으로 이동...

p.559
SUT가 리턴하는 값과 관련된 조건이 맞지 않을 때 테스트 메소드(348 페이지)의 특정 행을 실행하면 오류가 발생할 경우 보호 단언문으로 그 실행을 막아줘야 한다. 이 과정을 if then else fail 코드로 해당 명령문 주위에 감싸는 대신 해줘야 한다.
-> SUT가 리턴하는 값과 관련된 조건이 맞지 않을 때 테스트 메소드(348 페이지)의 특정 행을 실행하면 오류가 발생하는 민감한 명령문이 있다면, 여기를 if then else fail 로 막기보다는 보호 단언문으로 막아주는 게 좋다.

동등 단언문<Equality Assertion>(단언 메소드 참조)를
-> 동등 단언문<Equality Assertion>(단언 메소드 참조)을

p.560
항상 통과할 수도 있다. -> 항상 통과한다.

p.561
상태를 변경했다면 SUT는 -> 상태를 변경했다면, SUT에서

SUT에 버그가 있다기보다는 테스트의 선조건으로 인해 문제가 생겼다는 걸 알기에는 많은 노력이 필요할 수 있다.
-> SUT 버그가 아닌 테스트 선조건에 문제가 있을 경우, 찾기가 더 힘들다.

p.564
이렇게 하는 데 노력은 크게 들지 않지만 얻는 혜택은 많다.
-> 이러면 큰 노력없이 많은 혜택을 얻을 수 있다.

모든 코드가 동작하기 전에 테스트를 체크인해야 하더라도 초록 막대로 인해 테스트를 제거하거나 작업 중인 테스트 단언문을 제거하면 놓친 테스트<Lost Test>(제품 버그, 268 페이지)가 생길 수 있으므로 안 된다.
-> 모든 코드가 동작하기 전에 테스트를 체크인해야 하더라도 초록 막대를 유지해야 하는 규칙 때문에 작업 중이던 테스트나 테스트 단언문을 제거하다보면 놓친 테스트<Lost Test>(제품 버그, 268 페이지)가 생길 수 있으므로 피해야 한다.

속성을 추가하거나 이름 기반 -> 속성을 추가하거나, 이름 기반

이름을 바꿀 수도 있고, 스위트에서... -> 이름을 바꿔준다. 스위트에서...

쓰는 경우에는 AllTests ... 에서 전체 테스트케이스 클래스를 제거하자.
-> 쓰고 있다면 AllTests ... 에서 해당 테스트케이스 클래스를 통째로 빼 버리자.

대부분의 xUnit에서는 fail -> 대부분의 xUnit에서 fail

p.566
테스트 단언문이 추가됐다. -> 테스트 단언문을 추가했다.

== 22장 ==
p.568
해체 작업이 알아서 처리된다. -> 해체 작업을 알아서 처리한다.

p.569
공유 픽스처<Shared Fixture>(317 페이지)를 쓰는 경우에는 픽스처에서 멋진 방법으로 레퍼런스를 쥐고 있어 테스트 스위트 실행이 끝나면 범위를 벗어날 수 있게 해주지 않는 한 가비지 컬렉션을 이용할 수 없다.
-> 공유 픽스처<Shared Fixture>(317 페이지)를 쓰는 경우에는 테스트 스위트 실행이 끝날 때 알아서 픽스처 변수의 범위를 벗어나게 해 주는 레퍼런스 관리 기법이 없는 한 가비지 컬렉션에 기댈 수 없다.

'클래스 리로드Reload' 옵션이 있거나 자신이 직접 해줘야 할 수도 있다. 이런 기능을 이용해
-> '클래스 리로드Reload' 같은 옵션으로 있거나, 직접 해줘야 한다. 이런 기능으로

IDE를 바꾸거나 테스트를 커맨드라인<command line>(예: ‘크루즈 컨트롤Cruise Control’이나 빌드 스크립트)에서 실행할 경우 실행이 멈출 수 있으므로 주의해야 한다.
-> 나중에 IDE를 변경하거나 테스트를 명령행<command line>(예: ‘크루즈 컨트롤Cruise Control’이나 빌드 스크립트)에서 실행할 경우 (클래스 리로드를 하지 못해 픽스처 가비지 컬렉션이 안 되어 : 옮긴이) 테스트 실행이 멈출 수 있으므로 주의해야 한다.

p.572
해체하지 않으면 계속 -> 해체하지 않는 한 계속

p.573
더 좋은 방법이다. -> 더 좋다.

중간에 만나는 에러를 감지해 객체 정리 도중 하나가 실패해도 나머지 객체의 정리 작업은 중지되지 않게 하고 싶을 것이다. 
-> 객체 정리 도중 하나가 실패해도 나머지 객체의 정리 작업은 계속 진행될 수 있게 해 주는 게 좋다.

p.578
속성를 붙여주거나 -> 속성을 붙여주거나

p.583
객체가 데이터베이스에 저장되므로 -> 데이터베이스에 저장된 객체는

p.584
해체 코드 실행을 보장하려고 -> 해체 코드 실행을 보장하기 위해

기대 예외 단언문<Expected Exception Test>
-> 기대 예외 테스트<Expected Exception Test>

p.590
데이터베이스에서 지속되므로 -> 데이터베이스에서 영속성이 유지되므로

p.591
다음 예제에서는 아까 테스트 코드의 -> 이번에는 이전 테스트 코드의

== 23장 ==
(전체 오른쪽 상단이 22장으로 표시되어 있습니다.)

p.594
어떤 SUT는 -> 어떤 테스트 대상 시스템<system unter test, SUT>은

이런 문제가 생길 수 있다.  또는 테스트 -> 이런 문제가 생긴다. 테스트

p.595
(전체 오른쪽 상단 페이지 번호 옆에 '픽스처 해체 패턴' 이라고 되어 있습니다. 수정 부탁드립니다.)

상호작용하고 불가능했던 -> 상호작용하고 덕분에 불가능했던

기능만 구현하게 하자. -> 기능만 구현하자.

p.600
걱처럼 쓰게 -> 것처럼 쓰게

p.601
많은 경우 SUT가 실행되는 환경이나 문맥context은 SUT의 동작에 많은 영향을 미친다. SUT의 간접 입력을 ... 스텁으로 교체해야 할 때가 있다.
-> SUT가 실행되는 환경이나 문맥<context>이 SUT의 동작에 많은 영향을 미칠 수 있다. 이럴 때는 SUT의 간접 입력을 ... 스텁으로 교체해 줘야 한다.

SUT가 진짜 구현 -> SUT가 실제 구현

값을 검증하면 된다. -> 값을 검증할 수 있다.

p.602
제어 위치로 써서 -> 제어 위치로 활용해

설치할 수 있는 방법도 있어야 -> 설치할 수도 있어야

훼방꾼 -> 훼방꾼<Saboteur>

p.603
자신의 필요와 사용 중인 도구에 따라 테스트 스텁은 여러 가지 다른 방법으로 
-> 테스트 스텁은 요구사항과 도구에 따라 여러 방법으로

p.605
에서는 두 가지 문제가 생긴다. 먼저 -> 에는 두 가지 문제가 있다. 첫째,

이런 가상 시계를 SUT의 간접 입력으로 쓰고 싶은 시간을 테스트에서 설정할 수 있는 테스트 스텁으로 구현한다.
-> SUT의 간접 입력으로 쓰고 싶은 시간을 테스트에서 설정할 수 있는 테스트 스텁으로 구현해 보자.

p.610
신경만 거슬리는 추가 객체 생성은 제거할 수 있다. -> 신경 거슬리기만 하는 추가 객체 생성은 피할 수 있다.

p.614
만으로도 충분할 수 있다. -> 만으로도 충분하다.

마찬가지로 아무 의존 대체 패턴이나 사용해 SUT를 실행하기 전에 테스트 스파이를 설치할 수 있다.
-> 마찬가지로 SUT를 실행하기 전에 의존 대체 패턴으로 테스트 스파이를 설치할 수 있다.

p.615
정적 타입 언어라면 테스트케이스 클래스에서 SUT가 의존하는 출력 인터페이스<outgoing interface>(관찰 위치)를 구현해야만 DOC를 저장하는 변수와 타입을 일치시킬 수 있다.
-> 정적 타입 언어에서는 SUT가 의존하는 출력 인터페이스<outgoing interface>(관찰 위치)를 테스트케이스 클래스에서 구현해 줘야 DOC를 저장하는 변수와 타입을 맞출 수 있다.

p.626
다른 책을 읽을 때는 ... 가리킬 때도 쓰인다는 점에
-> 다른 책에서는 ... 가리킬 때도 있다는 점에 

p.628
실제 DOC를 안 쓰고 있다는 것만 -> 가짜 DOC 를 쓰고 있다는 것만

상호작용을 제공할 뿐이다. -> 상호작용만 제공한다.

해줘야 할 수도 있다. -> 해줘야 할 수 있다.

가짜 객체를 만드는 게 낫다면 길게 놓고 봤을 때 적절한 모의 객체를 생성, 프로그래밍하는 것보다 가짜 객체를 가볍게 구현하는 게 훨씬 쉬울 것이다.
-> 길게 놓고 봤을 때 적절한 모의 객체를 생성, 프로그래밍하는 것보다 가짜 객체를 가볍게 구현하는 게 훨씬 나은 경우가 있다.

p.629
구체적으로 알아보자. -> 구체적으로 살펴보자.

p.630
제공하므로 적어도 -> 제공한다. 따라서 적어도

p.632
바꿀 수 있는 의존을 아까 뽑아낸 -> 바꿀 수 있는 의존<substitutable dependency>을 아까 뽑아낸

그냥 픽스처를 설치하면 된다. -> 그냥 일반적인 방식대로 픽스처를 설치하면 된다.

p.635
테스트 대역<Test Double> (<> 병기 표시)

p.636
호출하면 테스트 대역은 해당 변수 값으로 리턴하거나 단언문의 기대 값으로 사용한다.
-> 호출하면 테스트 대역에서는 관련 변수 값을 리턴하거나 단언문의 기대 값에 넣어준다.

피하고 싶다면 설정되는 -> 피하고 싶을 때 설정되는

p.637
직접 만든 테스트 대역을 만드는 것이다. -> 직접 만든 테스트 대역<Hand-Built Test Double>을 만드는 것이다.

직접 테스트 대역을 하드 코딩한다. -> 직접 테스트 대역을 하드 코딩하자.

설정 가능한 테스트 대역 -> 설정되는 테스트 대역

p.638
이 과정을 빼먹지 않을 수 있다는 장점을 얻을 수 있다.
-> 이 과정을 빼먹지 않을 수 있다.

만들어진 클래스 이름을 써서 설정되는 테스트 대역을 생성한다.
-> 클래스 이름으로 설정되는 테스트 대역을 생성한다.

p.639
생성하지만 일반적으로 검색 인터페이스<Retrieval Interface>(테스트 스파이 참조)는 제공하지 않는다.
-> 생성하는 기능은 있어도, 검색 인터페이스<Retrieval Interface>(테스트 스파이 참조)를 제공하는 경우는 별로 없다.

p.641
작업해야 한다면 기존 ... 없다면 포팅을 하는 게 
-> 작업해야 한다면 먼저 기존 ... 없다면 아예 개발 환경에 맞게 포팅하는 게

테스트부터 수정하면서 ... 알아보는 게 가장 좋은 출발이다.
-> 처음에는 테스트부터 수정하면서 ... 알아보는 게 좋다.

리팩토링을 쓸 수 있다. -> 리팩토링을 해 준다.

p.645
테스트 대역의 메소드들을 -> 테스트 대역의 메소드를

enterPlaybackMode 메소드로 설정되는 ... 시작시키는곳이다.
-> enterPlaybackMode 메소드를 호출해 설정되는 ... 시작시키는 부분이다.

p.648
파일/클래스이 -> 파일/클래스가

p.650
설정할 필요가 없게 된다. -> 설정할 필요가 없다.

‘내부 클래스 대역’이라는 이름은 여기에서 이용하는 자바 언어의 개념에서 따왔지만... 지원한다.
-> ‘내부 클래스 대역’이라는 이름은 자바 언어에서 따왔지만... 지원한다.(역주 : C++ 에도 local class 라는게 있다.)

p.651
실제 시스템 시계에 의존함으로써 -> 실제 시스템 시계에 의존하다보니

p.656
다음과 같은 출력이 보일 것이다. -> 다음과 같은 출력을 볼 수 있을 것이다. 

‘구현도 하는 아키텍트’의 의미는 이 패턴에 대해 읽어보지 않아도 패턴 이름만 보고 대강 어떤 의미인지 알 수 있다.
-> ‘구현도 하는 아키텍트’같은 경우에는 이 패턴에 대해 읽어보지 않아도 패턴 이름만 보고 대강 어떤 의미인지 짐작할 수 있다.

표시한 그래프를 보고 지었다고 한다. -> 표시한 그래프에서 유래했다고 한다.

p.657
마이클 테더스<Michael Feathers>는 -> 마이클 페더스<Michael Feathers>는

"모의<mock>를 안에 넣으세요" -> "모의<mock>를 안에 넣으세요"(역주 : "목<mock>을 안에 넣으세요" 가 좀 더 적당한 거 같지만, '목 객체'보다는 '모의 객체'라는 단어가 익숙해 mock 라는 단어를 '목' 대신 '모의'로 통일했습니다)

아무 테스트 대역<Test Double>(522 페이지)이든
-> 모든 테스트 대역<Test Double>(522 페이지)을

p.658
마이클 패더스<Michael Feathers>고 -> 마이클 페더스<Michael Feathers>고

p.661
SUT에 어떤 변화도 찾을 수 없다. -> SUT에 아무런 변화도 느낄 수 없다.

테스트를 더 쉽게 하기 위해 SUT를 고쳐야 하되 직접 고치면 제품 코드 내 테스트 로직<Test Logic in Production>(217 페이지)이 생길 거 같다면 테스트용 하위클래스를 써야 한다.
-> 테스트를 더 쉽게 하기 위해 SUT를 고쳐야 하되 제품 코드 내 테스트 로직<Test Logic in Production>(217 페이지)은 피하고 싶을 때 테스트용 하위클래스를 쓴다.

p.662
빌드할 수 있을 것이다 -> 빌드할 수 있다

테스트용 하위클래스 사용에는 다음과 같은 문제점이 있다.
-> 테스트용 하위클래스를 사용하려면 다음과 같은 점들을 해결해야 한다.

오버라이딩하거나 노출하려는 동작이 하나의 단일 목적 메소드에 들어있게 한다.
-> 오버라이딩하거나 노출하려는 동작별로 하나의 단일 목적 메소드<single-purpose method>에 집어넣기.

동작에 접근할 수 있게 한다. -> 동작에 접근할 수 있게 하기.

덜 공격적이고 문제가 없다고 본다. -> 덜 공격적이고 문제가 없다고 본다.(역주 : 심지어 '테스트가 없는 private 메소드보다 테스트가 있는 public 메소드가 훨씬 안전하다'고 주장하는 사람도 있다.)

p.667
문서화로 인해 테스트용 하위클래스를
-> 문서화를 돕기 위해 테스트용 하위클래스를

p.668
우주 과학은 없다. -> 우주 과학은 필요없다.

p.670
모두 단점도 있지만 아예 불가능할 수도 있다. -> 모두 단점도 있거니와 아예 불가능할 수도 있다.

p.671

Another option is to use a Test-Specific Subclass to add a more appropriate definition of equality for our test purposes alone.

다른 방법은 테스트에서는 더 적합한 동등 정의를 추가한 테스트용 하위클래스를 쓰는 것이다.
-> 다른 방법은 테스트용으로만 적합한 동등 정의를 추가한 테스트용 하위클래스를 쓰는 것이다.

p.672
DTO -> DTO<Data Transfer Object>

== 24 장 ==
p.676
스위트를 정의하고, 적당한 이름을 지어준다.
-> 스위트를 정의한 뒤, 적당한 이름을 붙여준다.

테스트들을 묶어줄 수 있다 -> 테스트들을 묶을 수 있다

p.677
이러는 가장 큰 이유는 -> 가장 큰 이유는

그냥 지나갔으면 하는 경우가 많다 -> 그냥 넘어갔으면 할 때가 많다.

p.681
속성을 변경하는 것이 일반적인 방법이다. -> 속성을 변경하는 게 일반적이다.

p.682
이런 모든 방법은 ... 생길 가능성 때문에 문제가 있다. 
-> 이런 방법들은 ...생길 수 있다는 문제가 있다.

p.684
메소드에 옮기면 여러 테스트나 한 테스트 안에서도
-> 메소드에 옮겨놓으면 여러 테스트에서, 심지어 한 테스트 내에서도

p.685
하는 API가 또 생긴다는 점이다. -> 하는 API가 늘어난다는 점이다.

이런 추가적인 고생은 ... 리팩토링을 해 많이 
-> 이렇게 추가되는 노력은 ... 리팩토링을 하면 많이

p.686
혼합형 기법 둘 다 사용할 수 있다.
-> 혼합형 기법에서 전부 다 사용될 수 있다.

p.687
더 시그니처가 단순하고 -> 시그니처가 더 단순하고

검증 메소드<Verification Method>(맞춤 단언문 참조)은 
-> 검증 메소드<Verification Method>(맞춤 단언문 참조)는

p.688
유틸리티 메소드를 쓰는 데 일부 -> 유틸리티 메소드를 일부

테스트에소 -> 테스트에서

‘해체 메소드’라 부를 수도 있지만 이런 이름은 묵시적 ... 혼동을 불러 일으킬 수 있다.
-> ‘해체 메소드<Teardown Method>’라 부를 수도 있지만 이러면 묵시적 ... 혼동될 수 있다.

p.689
프로젝트나 회사용으로 정의한
-> 프로젝트나 전사공용으로 정의한

테스트 유틸리티 메소드가 의존하는 타입/클래스들이 모든 클라이언트가 볼 수 있는 특정 위치에서 전부 볼 수 있는 게 아니라면 테스트 유틸리티 메소드를 적당한 테스트 패키지나 하위시스템의 테스트 도우미에 둬야 한다.
-> 테스트 유틸리티 메소드가 의존하는 타입/클래스가 모든 클라이언트에서 볼 수 있는 특정 위치에 있는 게 아니라면 적당한 테스트 패키지나 하위시스템의 테스트 도우미로 옮겨줘야 한다.

p.695
인자를 받는 테스트를 쓸 수 있다. -> 인자를 받는 테스트로 만들 수 있다.

캡슐화한다. 또한 인자를 받는 -> 캡슐화한다. 인자를 받는

를 막아준다. 또한 인자를 받는 테스트는 데이터 주도
-> 를 막아줄 뿐만 아니라 데이터 주도

p.696
인자를 받은 테스트 변형인 -> 인자를 받는 테스트의 변형인

p.697
(누구 아는 분 없으세요?)
-> (누구 아는 분 없으세요?) (역주 : JUnit 4 부터 인자를 받는 테스트를 작성할 수 있는 기능을 지원한다. http://www.ibm.com/developerworks/kr/library/tutorial/j-junit4/section6.html 참조)

p.696
실제로 해 보면 금방 감을 잡는다는 점이다 -> 해 보면 금방 느낌이 온다는 점이다

덕분이라는 점도 잊지 말자. -> 덕분이라는 점도 놓치지 말자.

p.701
이번 절 뒤에 나오는 MbUnit 예제와 함께 맞춰줄려고 이름 로우를 잘 정렬했지만 그냥 test_element 같은 걸로 부를 수도 있었다.
-> 뒤에 나오는 MbUnit 예제와 비슷하게 보일려고 함수 이름도 row 라고 정했지만, 평소라면 test_element 같은 이름으로 만들었을 것이다.

p.703
텍스트 편집기의 ‘찾기와 바꾸기’ 기능만 잘 쓴다면 
-> 텍스트 편집기의 ‘바꾸기’ 기능만 잘 활용하면

예제: 반복문 주도 테스트(나열 값) -> 예제: 반복문 주도 테스트(열거 값)

p.704
기대 값을 열거했다. -> 기대 값을 testValues 에 열거했다.

p.707
이름 안에 기대 결과 값을 넣을
-> 이름 안에 기대 결과 값이 들어갈

p.719, 726
몇 그루의 나무라도 살리기 위해 -> 몇 그루의 나무라도 구하기 위해

p.731, 738
테스트케이스 상위클래스인지 테스트 도우미Test Helper(643 페이지)인지는
-> 테스트케이스 상위클래스를 쓸지, 테스트 도우미Test Helper(643 페이지)를 쓸지는

p.739
변형: 객체 부모 -> 변형: 객체 부모<Object Mother>

== 25 장 ==
p.744
데이터베이스로 지속 상태를 저장한다 -> 데이터베이스에 지속 상태를 저장한다

데이터를 지속시키므로 변덕스러운 테스트<Erratic Test>(228 페이지)의 원흉이다.
-> 데이터를 지속시켜서 변덕스러운 테스트<Erratic Test>(228 페이지)가 생기게 하는 1등 공신이다.

p.750
설계도처럼 좋아지곤 한다. -> 설계도 함께 좋아지곤 한다.

p.755
포매팅을 -> 포맷팅<formatting>을

p.759
이나 묵시적 해체 -> 나 묵시적 해체

제한들과 트리거를 테스트 -> 제한과 트리거를 테스트

p.760
TransactoinManager에 -> TransactionManager에 

일부 공유 픽스처에서만 실행되는 해체 방법으로 게으른 해체가 있다. 이 패턴에서는
-> 지연 해체는 공유 픽스처 중에서도 일부에서만 실행되는 해체 방법이다. 지연 해체에서는

p.766
반복 가능하고 단단하게 -> 반복 가능하고 견고하게

트랜잭션 롤백 해체를 쓰기 전에 먼저 대강 만든 트랜잭션 컨트롤러를 쓰게 리팩토링해봐야 한다.
-> 트랜잭션 롤백 해체를 쓰기 전에 먼저 대강 만든 트랜잭션 컨트롤러를 쓸 수는 없는지 리팩토링해봐야 한다.

p.767
ACID를 지원하지 않는 -> ACID(Atomic, Consistent, Isolated, Durable. 용어집 참고)를 지원하지 않는

p.768
상위클래스를 사용하고 있었습니다. -> 클래스를 상속받아 사용하고 있었습니다.

p.769
오해는 하지 말아 주시길. 저는 이 패턴이 꼭 포함돼야
-> 그렇다고 제가 이 패턴을 반대하는 것은 아닙니다. 오히려 이 패턴이 꼭 포함돼야

노출해줘야 할 것이다. -> 노출해줘야 한다.

p.770
ORM로 -> ORM으로

p.771
픽스처Fixture 설치 이전에 -> 픽스처 설치 이전에

== 26장 ==
p.776
SUT와 의존 간의 결합을 깰 수 있는
-> 테스트 대상 시스템<system unter test, SUT>과 의존 간의 결합을 깰 수 있는

의존은 메소드의 호출 인자나 생성자의 인자, 업데이트 가능한 속성(프로퍼티)등으로 포함할 수 있다.
-> 메소드의 호출 인자나 생성자의 인자, 업데이트 가능한 속성(프로퍼티)등으로 의존 객체를 전달할 수 있다.

p.777
의존 주입을 쓰면 코드를 설계하는 자연스러운 방법을 제공할 수 있다.
-> 의존 주입을 쓰면 자연스러운 방법으로 코드를 설계할 수 있다.

p.779
문맥<context>이 자유롭다. 가장 큰 단점은
-> 문맥<context>에 자유롭다. 가장 큰 단점은

바꿀 수 있게 고민해봐야 한다 -> 바꿀 수 있는지 고민해봐야 한다

생성해도 좋지 않은 부수효과가 없고 -> 생성해도 나쁜 부수효과가 없고

p.780
생성될 때 안 좋은 부수효과가 -> 생성될 때 나쁜 부수효과가

p.787
사용할 때 얻을 수 있는 가치는 적지 않다. -> 사용하면 많은 걸 얻을 수 있다.

'다중 모드(bimodal)’ -> '다중 모드(multimodal)’

p.788
의미는 다르지만(새로운 객체와 기존 객체) 이게 중요한 건 아니다.
-> 의미는 각자 다르지만(새로운 객체냐 기존 객체냐) 크게 중요하진 않다.

p.793
테스트 스텁<Test Stub>(529 페이지)를 전달한다.
-> 테스트 스텁<Test Stub>(529 페이지)을 전달한다.

p.796
불가능한 경우도 많으므로 테스트하기 어렵다. 아니면 객체가 비동기로 동작하므로 
-> 불가능한 경우도 많아 테스트가 어렵다. 객체가 비동기로 동작하는 바람에

p.797
옮겨놓는다. 이 컴포넌트는 테스트하기 -> 옮겨놓는다. 이 컴포넌트에서는 테스트하기

손쉽게 테스트하기 어렵다. -> 테스트가 쉽지 않다.

p.798
좀 더 어려운 부분은 -> 좀 더 까다로운 부분은

p.800
일반적으로 대강 만든 객체 내에서 -> 대강 만든 객체 내에서

p.801
게으른 초기화<Lazy Initialization>[SBPP]로 초기화한다.
-> 지연 초기화<Lazy Initialization>[SBPP]한다.

p.802
활성 모의 객체 -> 액티브 모의 객체

p.806
이 방법이 잘 통한다. -> 이 방법이 좋다.

p.807
진짜 되는지 검증한다. -> 실제로 되는지 검증한다.

p.809
환경에서 여러 객체(위젯)을 -> 환경에서 여러 객체(위젯)를

== 27 장 ==
p.813
하드 코딩된 의존<Hard-Coded Dependency>(테스트하기 힘든 코드,209 페이지)로 인해
-> 하드 코딩된 의존<Hard-Coded Dependency>(테스트하기 힘든 코드,209 페이지)으로 인해

p.814
프리프로세서나 -> 전처리기나

p.818
객체 속성나 단언문에 -> 객체 속성이나 단언문에

스프레드시트나 직접 -> 스프레드시트로, 아니면 손으로 직접

어떤 값이 쓰여야 하는지가 -> 어떤 값을 써야 하는지가

p.819
정의해 코드가 읽기 쉽게 할 수 있다.
-> 정의해 코드를 읽기 쉽게 할 수 있다.

한 객체의 여러 속성에서 같은 종류의 값이 필요할 때 다른 값을 사용하면 SUT가 제대로 된 속성으로 동작하고 있다는 걸 보여주는 게 도움이 된다.
-> 한 객체에 같은 타입의 속성이 여러 개 있을 때 각기 다른 값을 주면 SUT가 올바른 속성값으로 동작하고 있다는 걸 볼 수 있어 좋다.

고객 이름에 ‘존재하지 않는 고객’ 을 넣어주는 게 ‘김철수’가 들어 있는 것보다 훨씬 테스트를 이해하기 쉽다.
-> 고객 이름에 ‘김철수’가 들어 있는 것보다는 ‘존재하지 않는 고객’ 이 들어있는 게 훨씬 테스트를 이해하기 쉽다.

p.823
객체 속성나 -> 객체 속성이나

확실하게 하려고 이런 문제가 생길 수 있는 테스트에 대해 리터럴 값<Literal Value>(714 페이지)을 쓰는 치료용 테스트케이스를 작성할 수도 있다.
-> 이런 문제가 있는지를 확인하기 위해, 리터럴 값<Literal Value>(714 페이지)을 쓰는 테스트케이스를 따로 몇 개 작성하는 사람도 있다.

p.829
훨씬 많은 경우에 -> 대부분은

필요가 없다면 이 값을 -> 필요가 없다면 오히려 그 값을

p.831
이런 작업에 드는 노력이 덕분에 얻을 수 있는 혜택보다 많이 드는 경우가 대부분이다.
-> 하지만 작업에 드는 노력에 비해서 효과는 그리 크지 않다.

이런 기능이 필요하다면 그건 진짜 필요한 경우다.
-> 물론 이런 기능이 꼭 필요할 때도 있다.

p.832
문자열(Widget Name)을 -> 문자열(Widget 이름)을

p.836
(인자의 널 검사를 하는 함수라면 테스트하려는 코드가 아닌 널 인자가 들어왔을 때 실행되는 검증 코드가 실행될 것이다 - 옮긴이).
-> (인자의 널 검사를 하는 함수라면 테스트하려는 코드가 아닌 널 인자가 들어왔을 때 실행되는 입력값 검증 코드가 호출될 것이다 - 옮긴이).

p.837
자기 기술 값이 든 -> 자기 기술 값이 들어있는

p.839
얼마나 간단해졌는지 살펴보자. -> 얼마나 간단해졌는지를 보자.

= 4부 =
== 부록 A - 테스트 리팩토링 ==
p.846
공유 픽스처<Shared Fixture> -> <> 병기표시

== 부록 B ==
p.854
Astels 책: Test-Driven Development -> Astels 책: Test-Driven Development : A Practical Guide

Beck 책: Test-Driven Development -> Beck 책: Test-Driven Development : By Example

p.855
스위트 픽스처 설치 부분에서...
Test Fixutre -> TestFixture
Fixture Setup -> FixtureSetup
Class Initialize -> ClassInitialize

== 부록 C ==
p.857
JUnit을 ABAP으로 다소 직접적으로 포팅한 -> JUnit을 ABAP용으로 거의 그대로 포팅한

== 부록 D ==
(~를 참조하자. 를 아예 빼면 좋겠네요. 그냥 URL 만 보이게요.)

p.865
Fitness 같이 -> Fitnesse 같이

브라우저를 건너뛰므로 -> 브라우저단을 건너뛰므로

p.866
플러그인으로 굉장히 유명한 -> 플러그인으로 유명한

테스트를 굉장히 읽다. -> 테스트를 굉장히 읽기 쉽다.

p.869
Do No Harm> -> Do No Harm

== 용어집 ==
p.897
데이터베이스까지 시스템의 전체 레이어와 프로그램이 의존하는 시스템과의 통합까지 실행해본다.
-> 데이터베이스에 이르는 전반적인 시스템 레이어와, 어플리케이션에서 의존하는 다른 시스템과의 통합까지 전부 실행해 봐야 한다.

요즘의 데이터베이스에서 보장하는 -> 데이터베이스에서 보장하는

같은 트랜잭션 안에 있는 동작에서는 세상을 전부 같은 상태로 본다.
-> 같은 트랜잭션 안에 있는 동작에서는 일관성 있는 상태가 유지된다.

p.898
처리한 변화가 지속돼야 한다. -> 처리한 변화가 지속된다.

'뭔가' 를 '뭔가' 라고 지정하는 방법. -> '무엇'에 대해 '어떤 것'을 지정하는 방법.

닷넷 속성을 이용한다. -> 닷넷 속성<Attribute>을 이용한다.

때문에 써서는 안 되는 패턴 -> 때문에 피해야 하는 패턴

p.900
명세를 분명히 하려고 프레임워크에서 명시적으로 지원한다.
-> 명세를 명확하게 보여주기 위한 부분을 프레임워크에서 지원한다.

컴파일 에러나 테스트 실패와 같은 방식으로 테스트 냄새가 스스로를 드러내므로
-> 동작 냄새같은 경우에는 컴파일 에러나 테스트 실패등으로 스스로를 드러내기 때문에

같은 용도로 위임을 사용한다.
-> 같은 용도로 위임<delegate>을 사용한다.

p.901
객체가 아닌 클래스에

방식으로 호출돼 -> 방식으로 호출되기 때문에

다른 언어에서는 각기 다른 이름이나 키워드로 부른다.
-> 부르는 이름은 언어별로 다를 수 있다.

p.902
마틴 플로워Martin Fowler가 -> 마틴 파울러Martin Fowler가

p.903
테스트 대상 시스템(SUT)에게 -> 테스트 대상 시스템<system unter test. SUT>에게

p.904
엉성한 컴포넌트. -> 느슨한 컴포넌트.

자연스러운 부작용으로 -> 자연스럽게

p.905
레이어 아키텍트 -> 레이어 아키텍처

‘뒷문’을 이용해 -> ‘뒷문’을 통해서

p.906
최초의 <<모의 객체>> 논문 -> 최초의 모의 객체 논문

p.907
사람들에게는 예제를 보여주는 게 -> 사람들에게는 예제를 제시하는 게

이렇게 하면 아직 있지도 않은 소프트웨어를 ‘테스트’하는 고생은 하지 않아도 된다.
-> 이러면 "아직 만들지도 않은 소프트웨어를 ‘테스트’ 한다"는 개념을 전달해야 하는 부담을 덜 수 있다.

p.908
‘타입 I과 타입 II 에러’ -> ‘타입 I과 타입 II 에러<Type I and type II errors>’

p.909
픽스처<Fixture> -> 픽스처<fixture>

픽스처 (Fit)<Fixture (Fit)> -> 픽스처<fixture> (Fit)

p.910
플시저 변수 -> 프로시저 변수

p.912
의존 컴포넌트(DOC)가 날린 -> 의존 컴포넌트(DOC)가 넘긴

p.913
self 메소드이름 -> self.메소드이름

p.915
지역 변수는 호출자로 해당 코드 블록이 리턴될 때
-> 지역 변수는 해당 코드 블록이 호출자로 리턴될 때

p.917
동력<force> -> 영향<force>

p.918
델리케이트 -> 델리게이트<delegate> 또는 위임

p.919
있는 가능성이 높다 -> 있을 가능성이 높다

p.920
주기마다 -> 반복주기마다

p.921
코를 통해 우리를 붙든 후 -> 냄새로 우리에게

실험해보는 것을 말한다. -> 실험해보는 것.

p.927
Fit 표를 -> Fit 테이블을

픽스처(Fit) 참조 -> 픽스처<Fixture>(Fit) 참조

p.929
코로 우리를 붙잡아 -> 냄새로 우리에게

p.934
FitNess 테스트를 -> FitNesse 테스트를

p.935
우세한 욕구<prepotent needs>가 계층 -> 우세한 욕구<prepotent needs>를 계층

p.936
이 중에는 [Ref]에도 없는 -> 이 중에는 [Ref]에 없는

p.943
‘스스로 자신의 뇌를 수술하기’ -> '스스로 자신의 뇌를 수술하기<doing brain surgery on yourself>'
