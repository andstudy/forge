= 문제 요약 =
 * Median 이 최적해인가?
= 문제 해결 =
 * 절대값 함수의 최소값이 Median 인가?
 * Median 없이 O(n)해법
= Median 을 최적해로 본 이유 =
이 문제에서 거리를 구하는 공식이 Dij= |Si-Sj|.  였다.
 
즉 1 3 5 7 9 가 있을 때, 각 원소와의 차이의 합이 최소값을 수식으로 나타내면 다음과 같다.
{{{
  |1-m| + |3-m| + |5-m| + |7-m| + |9-m| = 최소값 
}}}
 
즉, "절대값 + 절대값 + 절대값 + 절대값 + 절대값 = 최소값" 과 같다.
절대값 합의 최소 값을 구하기 위해서는 순서대로 놓였을 때 중간 원소가 0이 되는 값이므로,
 
'''이 경우에는 |5-m| 이 0 이되는 경우 일 것이다.'''

 
  ''' < 추가 증명 시도 >'''
  위 식을 풀면,
      (m-1) + (m-3) + (7-m) + (9-m) = m에 상관없이 상수만으로 답이 나옴!!
 
     즉, median 을 중심으로 좌우의 개수가 같다면 m 은 다 지워지므로 최소값 상수C 되는 것이고, 
     좌우의 개수가 다르다면,  상수C - m 이 되서 최소값이 되는 것!


= Median 없이 O(n) 시간 풀이 =
 
 
< 드디어 전체 비용 O(n) 알고리즘 >             
 * 키인덱싱을 이용해 입력을 정렬한다 O(n)
 * 1 3 5 7 9 가 있다고 할때. 앞에서 부터 스캔하면서 누적합을 테이블로 만들어 놓는다.
 * 위 과정을 통해 최소값을 나타내는 아이템을 찾을 있따!
 * 핵심은 스캐닝을 통해 누적합을 구해 놓는다는 것!
{{{
          A[5] = { 1, 3, 5, 7, 9 }

                .... 

           // 현재까지의 누적합 배열
           acc[5] = { 1, 4, 9, 16, 25 }

            

           for( int i=0; i<5; i++ )
           {
                  // 현재 원소가 최적해라면!
                  // ( 현재 원소 * 앞선 항목개수 - 현재누적합) 
                  // + [ ( 전체누적합 - 현재누적합 ) - 남은항목개수 * 현재원소 ]

                  int left = A[i] * i - acc[i]; 
                  int right = ( acc[5] - acc[i] ) - (5-i) * A[i];

                 
                  if( left + right 가 현재까지 최소냐? )
                          
                  .....

            }
}}}

= 기타 =
* 열심히 가고 있습니다 ^^;; 20분 늦을것 같아여~~  
