[xUnitTestPatterns] 상위로 가기
오종빈 [ohyecloudy]

= 1장 =
== p3 ==
 * 여기에서 보여주는 원칙, '''패턴''', 냄새들은 오랫동안 우리에게 도움이 될 핵심 '''패턴들'''이다.
  * 위 아래 패턴 범위가 다른데, 중복해서 쓰여있습니다. 뒤에 패턴들을 다른 용어로 고치면 더 읽기 편할것 같습니다.

== p4 ==
 * 특히 성공했을 때 어떻게 돼야 하는지에 대해 합의된 정의를 얻을 수 있다.
  * 번역이 어색합니다. 좀 더 읽기 좋게 다듬었으면 좋겠습니다.
 * 코드의 전체 패스
  * 코드의 전체 패스가 어떤걸 의미하는지 정확히 모르겠습니다. 주석이나 참고 페이지를 기입하면 이해가 잘 될 것 같네요.

== p6 ==
 * 테스트 계획의 일환으로 테스트 픽스쳐라는 시작 위치를 각 테스트가 시작할 때마다 설치하게 된다.
  * 읽기가 힘듭니다. 좀 더 다듬었으면 좋겠습니다.
 * 불변 공유 픽스처가 아닌 공유 픽스처는 사용을 자제해야 변덕스러운 테스트로 조금씩 넘어가는 걸 막을 수 있다.
  * 읽기가 힘듭니다. 좀 더 다듬었으면 좋겠습니다.
 * 연결 테스트 chanied test
  * 연결된 테스트가 좀 더 명확하지 않을까 생각합니다.
 * 이것은 테스트 냄새가 나는 서로 반응하는 테스트가 변장한 것일 뿐이다.
  * 읽기가 힘듭니다. 좀 더 다듬었으면 좋겠습니다.

== p7 ==
 * 각 테스트 메소드는 최소 픽스처를 만들기 위해 위임 설치를 쓸 수 있다.
  * 읽기가 힘듭니다. 좀 더 다듬었으면 좋겠습니다.
  * "위임 설치를 해서 최소 픽스쳐를 만들 수 있다." 는 어떨까요?
 * 테스트를 자체 검사(자체 검사 테스트, 26페이지)하게 만든다.
  * "테스트를 자체 테스트(자체 검사 테스트, 26페이지) 한다." 혹은
  * "자체 테스트(자체 검사 테스트, 26페이지)를 한다." 가 어떨까요?
 * 코드 중에서 실행시킬 방법을 찾지 '''못해''' 테스트 안 된 코드가 있다면
  * 코드 중에서 실행시킬 방법을 찾지 '''못한''' 테스트 안 된 코드가 있다면

== p8 ==
 * 컴포넌트가 의존하는 다른 컴포넌트를 대체할 수 있게 하려면 '''테스트 대역'''을 사용하게 될 것이다.
  * 테스트 대역이란 단어가 어렵습니다. 뒤에 예제가 있지만 어떤 뜻을 가진 단어인지 추측하기가 어렵네요.
  * 전체 문장도 읽기가 힘듭니다.

= 2장 =
== p14 ==
 * 여러 종류의 냄새를 살펴볼 때 중요한 것은 냄새와 동시에 그 냄새의 증상도 같이 '''살펴본다'''는 점이다.
  * 여러 종류의 냄새를 살펴볼 때 중요한 것은 냄새와 동시에 그 냄새의 증상도 같이 '''살펴봐야 한다'''는 점이다.
 * 프로젝트 관리자는 테스트를 실행하거나 작성하지 않으므로 프로젝트 냄새를 통해 관리자는 테스트 자동화가 완벽함에서 멀어지고 있다는 사실을 알 수 있는 힌트를 얻을 수 있다.
  * 문장도 길고 단어 반복도 많아서 읽기가 어렵습니다.
  * 프로젝트 냄새는 테스트를 실행하거나 작성하지 않는 프로젝트 관리자에게 테스트 자동화가 완벽함에서 멀어지고 있다는 사실을 알 수 있는 힌트를 준다.
  * 프로젝트 냄새는 테스트를 실행하거나 작성하지 않는 프로젝트 관리자에게 힌트를 준다. 이 힌트를 통해 테스트 자동화가 완벽함에서 멀어지고 있다는 사실을 알 수 있다.

== p16 ==
 * "테스트 만든다고 시간 낭비하지 마라"'''로'''
  * "테스트 만든다고 시간 낭비하지 마라"'''고'''

== p19 ==
 * 찾을 수 있는 '''초기''' 경고 역활도 한다.
  * 초기 보다는 '''조기'''가 더 알맞지 않을까요?

== p20 ==
 * 제품 코드 내 테스트 로직Test Logic in Production(217 페이지)'''는'''
  * '''은'''

= 3장 =
== p26 ==
 * 위험 감소의 다른 형태는 전체 애플리케이션을 하나의 블랙박스로 보고 테스트하는 전통적인 고객 테스트에서는 '불가능한'상황에서 소프트웨어 동작을 검증해보는 것에서 나타난다.
  * 너무 길어서 읽기가 힘듭니다.
  * 위험 감소의 다른 형태는 전체 애플리케이션을 하나의 블랙박스로 보고 테스트 하는 전통적인 고객 테스트에서 나타난다. 이 전통적인 고객 테스트는 '불가능한'상황에서 소프트웨어 동작을 검증한다.

== p27 ==
 * 뭔가를 변경하기 전에 '''수동으로''' 오랫동안 분석해야 한다.
  * 수동 보단 '''한줄한줄'''이 적당하지 않을까요?

== p29 ==
 * 여러 번 돌려봐도 같은 결과를 얻을 수 있는 '''반복되는''' 테스트여야 한다.
  * 여러 번 돌려봐도 같은 결과를 얻을 수 있는 '''반복 가능한''' 테스트여야 한다.

== p30 ==
 * 반본 안 되는 테스트만큼
  * 반복

== p32 ==
 * 테스트 스크립트 언어와 테스트에서 표현하고자 하는 도메인 개념의 이전/이후 관계와의 '표현 간극'이 너무 크다.
  * 의가 많아서 읽기 힘듭니다.
  * 테스트 스크립트 언어와 테스트에서 표현하고자 하는 도메인 개념 이전/이후에 너무 큰 '표현 간극'이 있다.

= 4장 =
== p39 ==
 * 그리고 바깥쪽 소프트웨어가 안쪽 스프트웨어와는 독립적으로 테스트되지 않음을 의미한다.
  * 앞문장과 이어지지 않습니다. 무엇이 의미하는걸 가르키는지 문장을 보고 알기 힘듭니다.

== p43 ==
 * 갖지고
  * 가지고

= 5장 =
 * '''유지 보수'''로 쓴 문장이 많습니다.
  * '''유지보수''' - 한 단어로 쓰이는게 더 맞을 것 같습니다.
== p47 ==
 * DOC
  * 어떤 약자인지 설명이 없습니다. 설명을 곁들여 주는게 좋을 것 같습니다.

== p50 ==
 * 다음 테스트에 아무런 영향이 없을지를 알 수 '''있다'''.
  * 다음 테스트에 아무런 영향이 없을지를 알 수 '''없다'''.
  * 문맥상 없다 같습니다.

== p53 ==
 * 테스트 훅이 실제 제품 소프트웨어'''가''' 실패하게 만들 수도 있다.
  * 테스트 훅이 실제 제품 소프트웨어'''를''' 실패하게 만들 수도 있다.

= 6장 =
== p58 ==
 * 이 책에서 다루는 전략과 더 상세한 패턴들은 '''사용하려는''' 어떤 종류의 테스트 자동 프레임워크'''에서든''' 동일하게 적용할 수 있다.
  * 이 책에서 다루는 전략과 더 상세한 패턴들은 어떤 종류의 테스트 자동 프레임워크에서도 동일하게 적용할 수 있다.

== p60 ==
 * 자동화는 개발자가 하더라도 최종 사용자가 테스트할 때 테스트가 실제로 어떻게 생겼는지는 모르더라도 테스트가 정의하는 동작은 알 수 있어야 한다는 점이 핵심이다.
  * 이해는 가는데 읽기 힘든 문장입니다.
 * 핵심 비즈니스 로직이 '''캡슐화돼 있는''' 경우가 아니라면
  * 핵심 비즈니스 로직이 '''캡슐화된''' 경우가 아니라면

== p61 ==
 * 이런 요구 사항은 어떤 '''종류의''' 기능에
  * 이런 요구 사항은 어떤 기능에
 * '무슨 무슨 품질 ilities'
  * 오타

== p62 ==
 * 하려는 작업에 맞는 '''적절한''' 도구를 선택하는 것은
  * 하려는 작업에 맞는 도구를 선택하는 것은
 * 테스트 프로그램(스크립트)'''를''' 직접 코딩하는 '''직접 작성한''' 스크립트 기반 테스트
  * 테스트 프로그램(스크립트)'''을''' 직접 코딩하는 스크립트 기반 테스트

== p63 ==
 * 그림 밑에 설명이 이상합니다.

== p65 ==
 * 정밀도 수준에서 적용되지만 시스템의 나머지 부분을 '''스텁'''할 수만 있다면
  * 문장이 어렵습니다. 스텁이란 단어때문에 이해가 안 됩니다.
 * 테스트 하나나 여러 테스트를 한번에 실행하기 쉬워야 한다.
  * 하나 또는 여러 테스트를 한번에 실행하기 쉬워야 한다.

== p67 ==
 * xUnit'''에서'''보다 Fit에서 더욱 더 인기가 없을 수도 있다.
  * xUnit보다 Fit에서 더욱 더 인기가 없을 수도 있다.
 * xUnit 계열에서는 테스트를 설치하기 쉬운 조그만 픽스처를 필요로 하는 작은 테스트들의 큰 집합으로 만들 때 가장 잘 돌아간다.
  * 한 번에 안 읽어집니다. 문장이 어렵습니다.

== p75 ==
 * 공유 픽스처의 변경되는 부분'''을 적게''' 제한해 덜 변덕스럽게 만들 수 있다.
  * 공유 픽스처의 변경되는 부분''이 작도록''' 제한해 덜 변덕스럽게 만들 수 있다.

== p81 ==
 * 오지 않는 메시지 응답을 '''기다려야 할 수도''' 있다면
  * 오지 않는 메시지 응답을 '''기다릴 수도''' 있다면

= 7장 =
== p90 ==
 * 7.2에서처럼 커맨드라인 돌아가는
  * 7.2에서처럼 커맨드라인'''으로''' 돌아가는

== p94 ==
 * 절차적 세상에서의 xUnt
  * 절차적 세상에서의 xUnit

= 8장 =
== p98 == 
 * SUT를 '''실행하기 위해 필요한''' 상태로 만들어 둔다.
  * SUT를 '''실행할 수 있는''' 상태로 만든다.
 * 픽스처를 '''설치하기 위해서 호출하는''' 테스트 로직 부분을 테스트의 픽스처 설치라 한다.
  * 픽스처를 '''설치하는''' 테스트 로직 부분을 테스트의 픽스처 설치라 한다.

== p103 ==
 * 이렇게 별개의 생성 값'''를'''
  * 이렇게 별개의 생성 값'''을'''
 * 변덕스러운 테스트'''의''' 여러 형태,
  * 변덕스러운 테스트'''가 가지는''' 여러 형태,
 * 따라서 문서로서의 테스트를 중요하게 생각한다면 테스트를 읽을 때 픽스처가 무엇을 하는지 알 수 있게 하기 위해 호출되는 테스트를 의도가 드러나는 이름을 가진 생성 메소드로 감싸는 것을 고려해야 할 것이다.
  * 문장이 너무 길어서 이해가 힘듭니다.

== p104 ==
 * 특정한 어노테이션이나 메소드 속성'''가'''
  * 특정한 어노테이션이나 메소드 속성'''이'''
 * setUp 메소드는 '''선택적이거나''' 프레임워크에서 비어있는 기본 구현을 제공하므로 테스트케이스 클래스마다 전부 setUp 메소드를 작성할 필요는 없다.
  * setUp 메소드 '''실행을 선택할 수 있거나''' 프레임워크에서 비어있는 기본 구현을 제공하므로 테스트케이스 클래스마다 전부 setUp 메소드를 작성할 필요는 없다.

== p105 ==
 * 격리시켜 주지만 '''적어도 하나(NUnit)는''' 그렇지 않다.
  * 격리시켜 주지만 '''NUnit은''' 그렇지 않다.


= 9장 =
== p113 ==
 * 표 9.1
  * 글에서 같거나 많이 숨겨주는 해체 코드 방식을 선택한다고 합니다.
||권장하지 않음||권장하지 않음||권장||
||권장하지 않음||권장하지 않음||권장||
||권장하지 않음||권장하지 않음||권장||
이 아니라
||권장||권장||권장||
||권장하지 않음||권장||권장||
||권장하지 않음||권장하지 않음||권장||
이렇게 같거나 많이 숨겨주는 방식이 아닐까 생각합니다.

== p116 ==
 * 픽스처가 지속되는 이유가 테스트에'''게''' 있다면
  * 픽스처가 지속되는 이유가 테스트에 있다면

== p117 ==
 * 좀 더 정확하게는 '''렉'''이 생겨
  * 좀 더 정확하게는 '''랙'''이 생겨


= 10장 =
== p125 ==
 * 동작 검증은 더 복잡하며 상태를 검증하기 위해 다양한 검증 기법을 써야 한다.
  * 동작 검증을 설명하는 문장인거 같은데, 바로 상태 검증에 사용하는 상태 검증 이야기가 나옵니다. 그래서 문장 읽기가 힘든데, 뒤에 상태가 상태 검증에 있는 상태면 문장을 분리하는게 나아 보입니다.


= 11장 =
== p144 ==
 * DOC를 호출하면 객체나 값을 리턴하거나 '''DOC의 인자를 업데이트하고 예외를 발생 시키는''' 경우도 있다.
  * DOC를 호출하면 객체나 값을 리턴''',''' DOC의 인자를 업데이트''', 또는''' 예외를 발생 시키는 경우가 있다.
  * '하고 예외를 발생 시키'는 식으로 되어 있어 업데이트하고 예외를 던지는 것처럼 읽혀집니다.

== p155 ==
 * if '''테스트 중''' then ... else
  * 'if testing then ... else' 식으로 영어로 계속 쓰다가 이 문장에서 한글을 사용합니다. 어떤 단어로든 간에 통일하는 게 좋겠네요.

== p164 ==
 * 의존 주입은 클라이언트가 SUT에게 어떤 DOC를 써야 하는지 '''런타임에 알려줄 수 있는 설계 결합'''을 제거하는 클래스다.
  * 의존 주입은 클라이언트가 SUT에게 어떤 DOC를 써야 하는지 '''런타임에 알려줘서''' 설계 결합을 제거하는 클래스다.
  * 의존 주입은 클라이언트가 SUT에게 어떤 DOC를 써야 하는지 '''런타임에 알려줘서 SUT와 DOC의 설계 결합'''을 제거하는 클래스다.

== p166 ==
 * '''테스트의 테스트 대역 의존을''' 좀 더 명확하게 해준다는 점에서 두 방법 모두 바람직하다.
  * '''테스트가 테스트 대역에 의존 하는걸''' 좀 더 명확하게 해준다는 점에서 두 방법 모두 바람직하다.

 * 그 외 다른 용도로 사용된 싱글턴은''',''' 테스트 작성에 있어
  * 그 외 다른 용도로 사용된 싱글턴은 테스트 작성에 있어

= 12장 =
== p175 ==
 * 많은 xUnit 순수주의자들은 '''좋은''' 결함 국소화를 제공하는 테스트별로 하나의 조건만 검증하라는 원칙을 선호한다.
  * 많은 xUnit 순수주의자들은 결함 국소화를 '''제공하기 위해''' 테스트별로 하나의 조건만 검증하라는 원칙을 선호한다.
 * 매번 같은 '''코드 경로'''로 실행할 때
  * 앞에 나온 코드 패스 아닌가요? 용어를 하나로 통일하는 게 좋아 보입니다.

== p178 ==
 * 최선의 방법이란 주어진 상황에 '''가장 적당한 것이다'''.
  * 최선의 방법이란 주어진 상황에 '''가장 적당한 방법을 선택하는 것이다'''.

== p185 ==
 * 플러그인의 특정 상세를 검사하기 위해 테스트하려는 특정 플러그인에 해당하는 하위클래스에서 제공하는 메소드를 호출하는 템플릿 메소드로 플러그인의 일반적인 동작을 명시하는 일치 테스트를 만드는 게 도움이 될 수 있다.
  * 문장이 길어 읽기 힘듭니다.


= 14장 =
== p197 ==
 * 어떤 테스트'''들은 다른 것'''보다 작성하기가 더 어렵다.
  * 어떤 테스트'''는 다른 테스트'''보다 작성하기가 더 어렵다.
 * 쓸 만한 도구도 별로 '''없으므로''' 발생한다.
  * 쓸 만한 도구도 별로 '''없어서''' 발생한다.


= 15장 =
== p208 ==
 * 이들 두 가지 목표는 테스트를 '''실행하게''' 상세히 구현하다보면
  * 이들 두 가지 목표는 테스트를 상세히 구현하다보면

== p213 ==
 * Resource(772 페이지''')''' 리펙토링)
  * Resource(772 페이지, 리펙토링)

== p219 ==
 * 테스트를 작성하는 가장 무난한 방법이 테스트와의 관련 여부와 상관없이 사용할 수 있는 거라면 어느 메소드라도 사용하고 모든 인자에 값을 넣어주는 것이다.
  * 문장이 길고 의미가 불명확해서 이해가 힘듭니다.

== p224 ==
 * 넘기는 식으로 만들면 다양한 경우에'''서서'''
  * 넘기는 식으로 만들면 다양한 경우에 있어

== p235 ==
 * 어떤 코드는 다른 클래스와 강하게 결합돼 있어 테스트를 컴파일하기 힘들다.
  * 어떤 코드는 다른 클래스와 강하게 결합돼 있어 테스트 '''코드'''를 컴파일하기 힘들다.
  * 이건 좀 애매한데 그냥 기록합니다.

== p241 ==
 * 잘라 붙이'''이'''
  * 잘라 붙이'''기'''

== p246 ==
 * 노출시키거나 초기화'''에''' 더 많은 제어를 하기 위한
  * 노출시키거나 초기화'''를 할 때''' 더 많은 제어를 하기 위한

= 16장 =
== p265 ==
 * 비관적인 락
  * 영문 병기, 그리고 주석으로 간단한 설명을 하면 좀 더 이해가 빠르겠네요.

== p267 ==
 * 무엇이든지 테스트를 완전히 결정적이지 못하게 하는 것은 안 좋다!
  * 무엇이든지 테스트를 비결정적으로 만드는 것은 안 좋다!
 * 이로 '''안해''' 테스트 코드 중복이
  * 이로 '''인해''' 테스트 코드 중복이

== p270 ==
 * 또는 사용자 인터페이스로 SUT와 상호작용'''하려고''' 필요한 사용자 인터페이스 요소를 찾지 못해 실패할 수도 있다.
  * 또는 사용자 인터페이스로 SUT와 상호작용'''에''' 필요한 사용자 인터페이스 요소를 찾지 못해 실패할 수도 있다.

== p275 ==
 * SUT를 '''헤갈리는''' 데 있다.
  * SUT를 '''헷갈리는''' 데 있다.


= 18장 =
 * 페이지 윗면에 17장, 프로젝트 냄새로 표시되어 있습니다.

== p314 ==
 * 이 방법은 새로 기록 테스트에서
  * 이 방법은 새로'''한''' 기록 테스트에서

 * actual 요소 <elements>
 * status 특성 <attributes>
  * 글씨가 같은 크기라서 읽을 때 헷갈립니다. 작게 표시.

== p328 ==
 * 고치느라 '''고생하는 걸 막을 수 없다.'''
  * 고치느라 '''고생한다.'''

== p334 ==
 * 만들면 다음과 '''같'''.
  * 만들면 다음과 '''같다'''.

== p346 ==
 * 테스트 하니스
  * 처음 등장. test harness 영문 병기. 그리고 간단한 설명이 주석으로 달리면 좋을 것 같습니다.

== p361 ==
 * 크루즈 컨트롤
  * 간단한 설명이 주석으로 달리면 좋을 것 같습니다.

== p384 ==
 * 이런 종류의 버그는 당장의 프로그램 동작에는 영향을 '''미칠지''' 않을 수도 
  * 이런 종류의 버그는 당장의 프로그램 동작에는 영향을 '''미치지''' 않을 수도 

= 19장 =
== p406 ==
 * 여러 개의 작은 단일 조건 테스트가 있는 더 낫다.
  * 여러 개의 작은 단일 조건 테스트가 있는 '''게''' 더 낫다.

== p414 ==
 * 스몰토크의 SUnit hould: [aBlockToExecute]
  * 스몰토크의 SUnit '''s'''hould: [aBlockToExecute]

== p415 ==
 * 소스 코드에는 AssertionFailedError()이고 본문에는 AssertionFailedException()입니다. 다르게 표시한 게 의도한 건지 모르겠네요.

= 20장 =
== p466 ==
 * 특히 묵시적 설치에서 같은 테스트 픽스처가 필요한 테스트케이스 메소드를 setUp 메소드 재사용 하나로 인해 같은 테스트케이스 클래스에 둬야 하는 제약을 피할 수 있다.
  * 문장이 길고 의미가 불명확해서 이해하는데 힘이 듭니다.

== p472 ==
 * 자신이 받은 인자'''는''' 꼭 고유ㅏ지 않더라도 알아서 생성해준다.
  * 자신이 받은 인자'''가''' 꼭 고유ㅏ지 않더라도 알아서 생성해준다.

== p480 ==
 * 이런 방법은 인라인 설치'''이나''' 위임 설치
  * 이런 방법은 인라인 설치'''나''' 위임 설치

== p500 ==
 * 어떻게 하면 공유 픽스쳐<Shared Fixture>
  * <Shared Fixture>를 작게 표시

== p509 ==
 * 테스트에서 하드 코딩된 값'''를''' 쓰고 있어
  * 테스트에서 하드 코딩된 값'''을''' 쓰고 있어
 * 여러 다른 데코레이터를 '''쓰지 않을 이유가 없다.'''
  * 여러 다른 데코레이터를 '''쓸 수 있다.'''

== p521 ==
 * 테스트 자동 프레임워크'''이''' 알아서 새로
  * 테스트 자동 프레임워크'''가''' 알아서 새로

= 21장 =
== p527 ==
 * 하지만 소프트웨어에 대해 '''심하게''' 명세를 만들어
  * 하지만 소프트웨어에 대해 '''지나치게 자세한''' 명세를 만들어
  * 아니면 패턴 이름이란 걸 표시해 줬으면 합니다.

== p549 ==
 * '''vefiry으로''' 시작하는
  * '''verify로''' 시작하는

== p553 ==
 * 예를 들어 스냅샷'''에 쿼리에 대해''' SUT가 리턴하는 객체 컬렉션이 들어있다면 깊은 복사를 해야 한다.
  * 예를 들어 스냅샷 '''쿼리 결과 값이''' SUT가 리턴하는 객체 컬렉션이 들어있다면 깊은 복사를 해야 한다.

== p559 ==
 * 동등 단언문'''를''' 보호 단언문으로 사용해
  * 동등 단언문'''을''' 보호 단언문으로 사용해

= 22장 =
== p569 ==
 * 이런 동작은 '클래스 리로드' 옵션이 '''있거나''' 자신이 직접 해줘야 '''할 수도 있다.'''
  * 이런 동작은 '클래스 리로드' 옵션이 '''있다면 사용하거나''' 자신이 직접 해줘야 '''한다.'''

== p573 ==
 * 해체하려면 따로 작업을 해줘야 하는 등록된 객체들이 들어있는 목록을 관리한다.
  * 따로 해체 작업을 해줘야 하는 등록된 객체 목록을 관리한다.

= 23장 =
 * 전체 머리글이 잘못됐습니다. 22장으로 표시하고 있음.

== p614 ==
 * 마찬가지로 아무 의존 대체 패턴이나 사용해 SUT를 실행하기 전에 테스트 스파이를 설치할 수 있다.
  * 마찬가지로 의존 대체 패턴을 사용해서 SUT를 실행하기 전에 테스트 스파이를 설치할 수 있다.

== p637 ==
 * 설정되는 테스트 대역을 생성하는 확실한 방법은 직접 만든 테스트 대역을 만드는 것이다.
  * 직접 만든 테스트 대역 : 패턴으로 보이게 표시하면 좋겠습니다.

== p661 ==
 * 테스트를 더 쉽게 하기 위해 SUT를 고쳐야 하되 직접 고치면 제품 코드 내 테스트 로직이 생길 거 같다면 테스트용 하위클래스를 써야 한다.
  * 문장이 읽기 힘듭니다.

== p670 ==
 * 두 방법 모두 단점도 '''있지만''' 아예 불가능할 수도 있다.
  * 두 방법 모두 단점도 '''있고''' 아예 불가능할 수도 있다.

= 24장 =
== p687 ==
 * 검증 메소드'''은''' 기대 결과 값이 나왔는지
  * 검증 메소드'''는''' 기대 결과 값이 나왔는지

== p688 ==
 * 이 패턴이 로직 일부를 테스트'''에소''' 제거하므로
  * 이 패턴이 로직 일부를 테스트'''에서''' 제거하므로

== p696 ==
 * 인자를 받'''은''' 테스트 변형인 테이블 테스트에 대해 알려줬다.
  * 인자를 받'''는''' 테스트 변형인 테이블 테스트에 대해 알려줬다.

= 25장 =
== p750 ==
 * 테스트 우선 개발에서와 마찬가지로 '''설계도처럼 좋아지곤 한다.'''
  * 테스트 우선 개발에서와 마찬가지로 '''설계도 좋아지곤 한다.'''

== p759 ==
 * TRUNCATE나 DELETE 명령은 인라인 해체'''이나'''
  * TRUNCATE나 DELETE 명령은 인라인 해체'''나'''

== p767 ==
 * ACID를 지원하지 않는 간단한 가짜
  * ACID는 용어집을 참고 하라는 글을 적어주면 좋겠네요

== p770 ==
 * ORM 레이어를 쓴다면 ORM'''로''' 데이터베이스 객체를
  * ORM 레이어를 쓴다면 ORM'''으로''' 데이터베이스 객체를

= 26장 =
== p776 ==
 * 업데이트 가능한 속성등'''으로''' 포함할 수 있다.
  * 업데이트 가능한 속성등'''을''' 포함할 수 있다.

== p793 ==
 * 테스트 스텁'''를''' 전달한다.
  * 테스트 스텁'''을''' 전달한다.

== p809 ==
 * 많은 개발 환경에서 여러 객체'''을''' 
  * 많은 개발 환경에서 여러 객체'''를'''

== p813 ==
 * 하드 코딩된 의존'''로'''
  * 하드 코딩된 의존'''으로'''

= 27장 =
== p818 ==
 * 계산기나 스프레드시트'''나''' 직접 기대 값을 계산한 후
  * 계산기나 스프레드시트'''에서''' 직접 기대 값을 계산한 후

 * 어떤 값이 쓰여야 하는지가 테스트 요구 사항에 명시돼 있고
  * 어떤 값을 써야 하는지가 테스트 요구 사항에 명시돼 있고

== p819 ==
 * 기호 상수를 정의해 코드'''가''' 읽기 쉽게 할 수 있다.
  * 기호 상수를 정의해 코드'''를''' 읽기 쉽게 할 수 있다.

== p831 ==
 * 이런 작업에 드는 노력이 '''덕분에''' 얻을 수 있는
  * 이런 작업에 드는 노력이 얻을 수 있는

= 부록A =
== p844 ==
 * [RTC]에서
  * 참고 도서가 주석식이 아닌 문장에 처음 나오는데, 이게 참고 도서를 뜻하는지 와닿지가 않네요. 이건 주석으로 표시해주면 좋겠습니다.

= 부록 C =
== p857 ==
 * ABAP으로 다소 직접적으로 포팅한 것이다.
  * ABAP로 포팅한 것이다.

== p862 ==
 * 스위트 픽스처 설치를 처음으로 지원하고,
  * 스위트 픽스처 설치를 처음으로 지원했고,

= 부록 D =
== p866 ==
 * 테스트를 굉장히 쉽다.
  * 테스트를 굉장히 '''읽기''' 쉽다.

= 부록 E =
== p868 ==
 * Do No Harm>
  * Do No Harm

= 용어집 =
== p898 ==
 * '뭔가'를 '뭔가'라고 지정하는 방법.
  * 무슨 뜻인지 모르겠습니다.

= 후기 =
다 읽었습니다. 휴~ 꽤 양이 많네요.
저자가 용어덕후인게 너무 마음에 듭니다.
