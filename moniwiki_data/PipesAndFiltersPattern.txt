[POSA1]
[[TableOfContents]]

= Pipes and Filters =
 * 스트림 데이터를 처리하는 시스템의 구조를 제공.
 * 각 프로세싱 스텝은 필터 컴포넌트로 캡슐화 되며 데이터는 파이프를 통해 전달
 
= Example =
 * 책에 나온 예
  * 새로운 프로그래밍 언어(Mocha) 개발.
  * Mocha의 컴파일러를 제작하며 가상머신 Cup상에서 동작하는 중간 언어인 AuLait 를 정의. 
  * Mocha -> AuLait로의 해석은 문장 어휘 분석, 문법 분석, 의미 분석, 중간코드 생성(AuLait), 중간코드 최적화로 구성.
  * 입력 - ASCII 문자 데이터열 이며 마지막 단계에선 입력으로 AuLait바이너리 코드를 취한다.
   * Input -> Scanner -> Parser -> Semantic Analyser -> Code Generator -> UNIX Pipe -> AuLait Interpreter
 * 자바 코드
  * 자바 코드 -> (자바 컴파일러) -> 자바 byte code(.class) -> (자바 가상 머신) -> native code -> (OS)
  
= Context =
데이터 스트림 처리.

= Problem =
 * 여러 명의 개발자가 작업을 분담해서 개발.
 * 전체 시스템 작업은 여러 개의 처리 단계로 분해된다.
 * 요구사항은 계속 변화한다.
  * 사용자나 개발자가 컴포넌트 순서를 바꾸는 것만으로도 요구사항 변화를 처리할 수 있어야 한다.
  * 작은 컴포넌트가 재사용에 더 유리
  * 인접하지 않은 컴포넌트끼리는 정보를 공유하지 않는다.
  * 최종 결과를 여러 방법으로 저장할 수 있어야 한다.
  * 다중 프로세스로 처리할 수도 있어야 한다. 

= Solution =
 * 시스템을 여러 개의 순차적인 컴포넌트들로 분리한다.
 * 이 컴포넌트들은 데이타 흐름으로 연결된다.
 * 각 컴포넌트들은 Filter 라고 하자.
 * 데이타 흐름은 Pipe 라고 하자.
 * 어떤 Filter 의 출력 Pipe 는 다음 단계 Filter 의 입력 Pipe 이기도 하다.

= Structure =
 * 파이프/필터 구조는 시스템의 작업을 여러 처리 단계로 나누어 처리한다.
 * 필터 : 데이터를 처리 단계.
  * Filter 는 다음 경우에 활성화 된다.
   1. 다음 Filter 가 이 Filter 의 출력 pipe 로부터 데이타를 뽑아갔다.(Passive)
   2. 이전 Filter 가 이 Filter 의 입력 pipe 에 데이타를 집어넣었다.(Passive)
   3. loop 안에서 입력 Filter 에 데이타를 집어넣고, 출력 Filter 에 데이타를 뽑아낸다.(Active)
 * 파이프 : 데이터의 흐름을 구현. 데이터 송신부와 필터, 데이터 수신부를 연결.
  * 인접 Filter 는 Pipe 가 동시성 제어한다.
  * FIFO 방식으로 데이타 전달
 * Data Source : 처음 데이타 시작 장소
 * Data Sink : 데이타 처리가 완료되는 장소
 
= Dynamics =

= Implementation =
함수호출(패시브 필터), 시스템에서 제공하는 파이프(UNIX, WIN) 를 통해 구현.
 1. 시스템 작업을 순차적인 처리단계로 나눔
 2. 파이프를 통해 전달되는 데이터 포멧을 정의.
 3. 각 파이프 연결을 구현하는 방법을 결정.
 4. 필터 디자인/구현.
 5. 에러 처리 디자인.
      잘못된 입력을 무시할 수 있다면 무시한다.
      입력 데이타에 marker 를 붙여서 에러가 나면 그 데이타를 적절한 위치로 옮겨놓은 후 pipelining 을 재시작한다.
 6. 파이프 라인을 설정.
 
= Think about it =
 * 대량의 데이터를 파이프를 통해 전달하지 말자.
 * 공유되는 데이터를 사용하는 필터들을 패시브 필터로 구현.

= Variants =
 * 단일 입력/단일 출력 필터-> 다중입력/다중출력 필터.
     e.g. tee (UNIX)

= Known Uses =
 * UNIX
 * CMS Pipelines
 * LASSPTools

= Consequences =
== Benefits ==
 * 중간 파일의 생성이 필요 없다.
 * 데이터의 병렬처리가 가능.
 * 필터의 기능을 교체/재조합 및 재사용 가능.
 * 빠른 프로토타이핑을 가능하게 해줌.
== Liabilities ==
 * 데이터 복사로 인한 비용발생. 대용량의 데이터 교환 시 부적합.
 * 단일 필터에서 처리하는 비용보다 전송하는 비용이 더 높은 경우 병렬처리의 이점이 없어짐.
 * 잘못 설계된 필터가 입력을 모두 처리하는 경우 점진적인 처리가 이루어지지 않음.
  * 특정 필터에서 Bottleneck 발생 가능
 * 단일 CPU상에서는 태스크 스위칭의 비용이 상대적으로 높다.
 * 파이프의 버퍼가 작은 경우 데이터 동기화로 필터를 자주 멈추게 한다.
 * 에러 처리가 약하다. - 레이어 사용 추천.

= Related Patterns =
[LayersPattern]
   에러 처리가 쉽기 때문에 신뢰할 만한 동작을 요구하는 시스템에 더 적당. Pipe & Filer  패턴과는 달리 컴포넌트 재조합/재사용에 취약하다는 단점을 가짐
[CSP]
