== 풀이 ==
 1. 예 : 13 * 8547 = 111111 (6자리)
 1. 13을 각 숫자의 배열로 n[] = {1, 3} (인덱스는 1부터 시작하면 편하다)
 1. 구하고자하는 배열은 a[] = {8,5,4,7} (아직은 값을 모른다고 치자)
 1. 7 구하기 : (3*x) % 10 == 1 이라면 x=7
 1. 위에서 3*7=21 이므로 올림값은 2
 1. 4 구하기 : (3*x + 1*7 + 2) % 10 == 1 이라면 x=4
  1. 1 = n[2], 7 = a[1], 2 = 이전 올림값
 1. (3*4 + 1*7 + 2) = 21 이므로 새로운 올림값은 2
 1. 5 구하기 : (3*x + 1*4 + 2) % 10 == 1 에서 x=5, 올림값 2
 1. 8 구하기 : (3*x + 1*5 + 2) % 10 == 1 에서 x=8, 올림값 3
 1. 0 구하기 : (3*x + 1*8 + 3) % 10 == 1 에서 x=0
 1. x = 0 이므로 끝
 1. 대충 정리하면 {{{(올림값 + n[1]*x + n[2]*a[i-1] + n[3]*a[i-2] + ...) % 10 == 1}}} 인 x 가 {{{a[i]}}} 가 된다. (맞나?)

== 어려운 점 ==
 1. 역시 풀어보지 않고는 장담하지 못한다.

== 오버플로우 ==
 1. 오버플로우 없는 파이썬 만만세
 {{{#!python
num = 887

ones = 1
count = 1
while (ones % num) != 0:
    ones = ones*10 + 1
    count += 1
print(num, count, ones)
 }}}
 {{{
(887, 886, 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111L)
 }}}
