[xUnitTestPatterns] 상위로 가기
이름을 써 주세요. [ParkPD]

용어 변경 요청

Application을 모두 프로그램으로 번역 하셨는데 어플리케이션으로 하는 것이 어떨지 의견 드립니다.

Testing with Database에 대하여 두 가지 방식으로 번역이 되어 있습니다. 제목에서는 "데이터베이스와 테스트" 소제목에서는 "데이터베이스 테스트하기" 이 것을 통일 시키는 것이 어떨까 의견 드립니다.

각 챕터의 끝에 나오는 "What's next"에 대한 번역으로 "정리"는 적합 하지 않은 것으로 생각 됩니다. "다음 내용은", "앞으로는", "예고" 등 의미에 맞는 표현이 어떨지 의견 드립니다.

||프로그램||어플리케이션||
||해체 (Teardown)||해제||
||애매한 테스트(Obscure Test)||모호한 테스트||
||미스터리한 손님||수수께끼 손님 또는 블가사의한 손님||

= 13장 =
''page 187''
||'''테스트베이스'''와 테스트 ||'''데이터베이스'''에 대한 테스트 ||
||'12장. 테스트'''조직'''하기' ||'12장. 테스트 '''구성''' 하기 ||
||13장에서는 프로그램에 데이터베이스가 있을 때 발생할 수 있는 문제점들을 살펴본다.  ||이번 장에서는 어플리케이션이 데이터베이스를 이용 할 때 테스트 과정에 발생 할 수 있는 문제점들을 살펴본다.||
||데이터베이스를 쓰는 프로그램에서 자동 테스트를 작성할 때 특히 어려운 점이 몇 가지 있다.  ||데이터베이스를 사용 하는 어플리케이션에 대한 자동화 테스트 작성에는 몇 가지 특별한 어려움이 있다. ||
||데이터베이스는 요즘 컴퓨터의 프로세스보다 훨씬 느리다. 따라서 데이터베이스와 상호작용하는 테스트는 메모리에서만 돌아가는 테스트보다 아주 훨씬 느린 편이다.  ||데이터베이스는 최신 컴퓨터에서 사용 되는 프로세스에 비해 느린 특성이 있다. 결과적으로 데이터베이스와 상호작용 하는 테스트는 메모리에서만 수행 하는 테스트에 비하여 훨씬 느릴 수 밖에 없다. ||
||느린 테스트 (253 페이지)에 대한 가능성은 젖혀 두고라도 데이터베이스는 자동 테스트 스위트에서 여러 가지 냄새가 나게 만드는 원인이 되기 쉽다.  ||느린 테스트 (253 페이지)가 발생할 가능성을 제외하더라도 데이터베이스는 자동 테스트 스위트에 여러가지 테스트 냄새를 발생 시키는 고약한 원흉이다. ||
||이런 냄새 중 일부는 데이터베이스의 지속성으로 인해 발생하고, 다른 것들은 테스트들이 픽스처 객체를 공유하므로 발생 한다.  ||이런 냄새 중 일부는 데이터베이스의 지속성이 직접적인 원인이며, 다른 것들은 테스트 간에 픽스처를 공유 하도록 구성 할 경우 발생 하게 된다. ||

''page 188''
||이번 주제에서 첫 번째이며 가장 중요한 조언은 다음과 같다. ||||이번 주제에 대한 첫 번째이며 가장 중요한 조언은: ||
||어떻게든 데이터베이스 없이 테스트 할 수 있다면, 그렇게 하라'!' ||만일 데이터베이스 없이 테스트 할 수 있는 방법이 있다면 데이터베이스 없이 테스트를 수행 하라! ||
||데이터베이스는 프로그램에 온갖 종류의 복잡함을 생기게 만들고, 특히 테스트에서 더 그렇다.||||데이터베이스는 프로그램에 온갖 종류의 복잡함을 발생 시키며, 테스트의 경우에는 더 심하다.||
||왜 데이터베이스를 테스트 하는가? ||왜 데이터베이스를 이용한 테스트를 수행 하는가? ||
||많은 프로그램이 객체나 데이터를 오래 지속시키기 위해 데이터베이스를 사용 한다. ||데이터베이스는 객체들과 자료들을 오랜기간 저장 하기 위한 용도로 많은 어플리케이션에서 사용된다. ||
||따라서 데이터베이스 샌드박스로 개발자와 테스터를 제품과 격리시키는 것은 거의 모든 프로젝트에 있어 기본이다.||그러므로 대부분의 프로젝트에서 개발자와 테스터를 제품으로 부터 (그리고 그들끼리도 서로)격리 시키는 용도로 데이터베이스 샌드박스를 사용 하는 것이 필요하다.||
||배관공과 전기기술자가 동시에 같은 벽에서 일하는 게 맞는 일일까?||배관공과 전기기술자를 동시에 같은 벽에서 작업 시키시겠습니까?||

''page 189''
||데이터베이스와 관련된 문제||데이터베이스와 관련된 문제들||
||데이터베이스에는 테스트 자동화를 어렵게 만드는 여러 문제점이 있다.||데이터베이스는 테스트 자동화를 어렵게 만든다.||
||픽스처가 지속된다는 점과 관련된 많은 문제가 있다.||문제들의 상당 부분은 픽스처가 지속되는 것이 원인이다.||
||이런 문제는 '9장. 지속되는 픽스처 관리'에서 소개했지만 여기에서 다시 요약해보자.||이런 문제에 대해서 '9장. 지속되는 픽스처 관리'에서 설명 하였으며 여기에 간략 하게 요약 하여 보았다.||
||데이터베이스를 쓰는 프로그램에 대해 자동 테스트를 작성할 때 볼 수 있는 몇 가지 문제점이 있다.||데이터베이스를 사용 하는 어플리케이션에 대한 테스트 자동화 수행 시 고려 해야 할 몇 가지 사항들이 있다.||
||이런 반복 안 되는 테스트||이런 반복 불가능한 테스트||
||픽스처를 공유하는 문제는 픽스처가 지속되는 것과는 또 다른 문제다.||픽스처를 공유하는 것은 픽스처가 지속되는 것과 다른 문제다.||
||일부러 픽스처를 공유할 경우 연결 테스트라 해서 다른 테스트에서 픽스처를 설치해줘야 하는 외로운 테스트가 될 수 있다.||외로운 테스트는 어떤 테스트들이 픽스처 설정을 다른 테스트들에 의존하게 되는 경우이며 의도적으로 픽스처를 공유 할 때 발생 할 수 있다. 이런 경우를 연결된 테스트라고 부른다.||
||지속 정도와 픽스처 공유 범위에 따라 이런 냄새들이 생기기도 하고 생기지 않기도 한다.||지속 정도와 픽스처 공유 범위에 따라 이런 냄새들이 생겨 날 수 있다.||

''page 190''
||데이터베이스를 사용하는 테스트의 또 다른 문제점은 데이터배이스가 커다란 일반 픽스처가 돼 여러 테스트에서 다른 목적으로 사용하게 된다는 점이다.||데이터베이스를 사용하는 테스트의 또 다른 문제점은 데이터베이스가 여러 테스트에서 다른 목적으로 사용되는 커다란 일반 픽스처가 되는 것이다.||
||레이어 테스트를 쓰면 각 레이어를 다른 레이어와는 독립적으로 빌드 할 수 있다.||레이어 테스트를 사용 하면 각 레이어를 독립적으로 개발 할 수 있다.||
||이 방법은 특히 지속 레이어를 테스트의 문맥에 민감함을 줄여주는 테스트 대역으로 변경할 때 좋다.||특히 문맥 민감성을 줄이기 위해 지속 레이어를 테스트 대역으로 변경 할 수 있을 때 보다 효과적이다.||

''page 191''
||테스트를 왕복 테스트 형태로만 작성 한다면..||테스트를 public 인터페이스에 대해서만 작성 하는 왕복 테스트 형태로만 작성 한다면..||
||벤더 전용 기능을 쓰는 경우에는 좀 더 재미있어진다.||벤더 전용 기능을 쓰는 경우에는 좀 더 어려워진다.||

''page 193''
||가장 대표적인 저장 프로시저 언어 중 xUnit이 지원하는게 몇 개 있다. utPLSQL은 그 중 하나다.||대표적인 저장 프로시저 언어 중 xUnit 계열을 지원하는 것들이 있으며 utPLSQL이 한 예이다.||
||저장 프로시저에 대한 자동 회귀 테스트를 만드는 건 굉장한 가치가 있지만 이런 테스트들을 반복 가능하게 하고 튼튼하게 만드는 과정에서 조심해야 한다.||저장 프로시저에 대한 자동 회귀 테스트는 반복 가능하고 변화에 강건하게 만들어야 한다.||
||데이터 접근 레이어 테스팅을 하는 동안 픽스처가 지속되는 걸 막아주는 좋은 팁 하나는 트랜잭션 롤백 해체를 쓰는 것이다.||데이터 접근 레이어 테스팅 과정에서 픽스처의 데이터가 기록 되어 지속성을 갖지 못하게 하는 유용한 방법이 트랜잭션 롤백 해제 이다.||

''page 194''
||이를 위해 데이터 접근 레이어를 만들 때 대강 만든 트랜잭션 컨트롤러 DFT 패턴에 의존 한다.||이를 위해 데이터 접근 레이어를 만들 때 대강 만든 트랜잭션 컨트롤러 DFT 패턴을 사용 한다.||

번역 누락 된 문장 "개발자의 독립성 보장하기" 단락의 두 번재 문장이 번역 되지 않았습니다.
||누락||이런 테스트 과정에서 모든 개발자는 각자의 데이터베이스 샌드박스가 필요 하다.||

''page 195''
||데이터베이스로 테스트하기(또!)||데이터베이스를 이용한 테스트(강조!)||


= 14장 =
Roadmap을 로드맵과 길잡이 두 가지로 표현 하셨습니다. 길잡이로 통일 하시는 것이 어떨지 의견 드립니다.

Happy Path에 대한 해석인 주요 경로를 다른 표현으로 변경 하면 어떨지 의견 드립니다. 다른 번역서에서는 행복 경로라고 했는데 이것도 적절한 표현 같지는 않습니다. 뾰족한 답을 드리지 못하고 고민만 드리네요.
 저도 많이 고민해 봤는데, (비겁하지만) 영문 병기 말고는 해결책을 모르겠더군요. [ParkPD]

''page 197''

||효과적인 테스트 자동화를 위한 로드맵||효과적인 테스트 자동화를 위한 길잡이||
||테스트를 효과적으로 하기 전에 알아야 할 것들이 너무나 많았다.||테스트를 효과적으로 하기 전에 알아야 할 것들이 너무나 많다.||
||이런 기법들을 익히고 여러 도구와 패턴을 자유자재로 쓰기에는 시간이 든다.||이런 기법들을 익히고 여러 도구와 패턴을 자유자재로 쓰기 위해서는 시간이 필요하다.||
||기술도 많이 필요하고,잘 알려져 있지도 않은 데다...||기술도 많이 필요하고, 잘 알려져 있지도 않은 데다...||
||쓸만한 도구도 별로 없으므로 발생한다.||쓸 만한 도구도 없는 것에 기인한다.||

''page 198''
||의존 없는 간단한 비즈니스 클래스||의존 관계가 없는 간단한 비즈니스 클래스||
||의존 있는 복잡한 비즈니스 클래스||의존 관계가 있는 복잡한 비즈니스 클래스||
||개별 컴포넌트를 컴포넌트 테스트||컴포넌트 테스트를 이용한 개별 컴포넌트들에 대한 테스트||
||전체 비즈니스 로직 레이어를 레이어 테스트||레이어 테스트를 이용한 전체 비즈니스 로직 레이어 테스트||
||고객 테스트를 서비스 파사드와 피하 테스트||피하 테스트를 이용하는 서비스 파사드를 통한 고객 테스트 수행||
||상태가 다양한 컴포넌트를 컴포넌트 테스트||컴포넌트 테스트를 이요한 상태를 갖는 컴포넌트 테스트||
||노출된 사용자 인터페이스 로직을 대강 만든 다이얼로그||보잘 것 없는 대화상자를 통하여 노출된 사용자 인터페이스 로직||
||아무론 테스트 없이 구현한 소프트웨어||아무런 테스트 없이 구현된 소프트웨어||
||둘 다 다른 것보다도 훨씬 많은 경험을 필요하다.||둘 다 다른 것 보다도 훨씬 많은 경험이 필요하다.||

''page 199''
||잘 유지되는 자동 테스트를 위한 길잡이||유지보수성 높은 자동화된 테스트를 위한 길잡이||
||다른 테스트보다 훨씬 작성하기 어려운 테스트가 있긴 해도 그런 어려운 테스트를 하기 전에 쉬운 테스트부터 어떻게 작성할지 배우는 게 좋다.||다른 테스트보다 훨씬 작성하기 어려운 테스트가 주어진 경우라도 먼저 쉬운 테스트에 대한 작성법을 배우고 난 뒤 그런 어려운 테스트에 대한 작성법을 배우는 것이 좋다.||
||SUT의 간단한 테스트 전 상태를 설치한다.||간단한 테스트 전 상태로 SUT를 설정한다.||
||SUT의 테스트 전 상태를 다양하게 해본다.||SUT의 테스트 전 상태를 변경해 본다.||
||테스트 실행을 빠르게 만들기||테스트 실행 속도 향상 시키기||
||빠진 버그에 대한 위험 줄이기||놓치는버그들에 대한 위험 부담 감소 시키기||

''page 200''
||이런 테스트를 통과시킬려면 SUT에서 테스트를 주요 경로로 진행하게 하기 위해 SUT가 다른 컴포넌트에서 정보를 얻어오는 로직 부분에 하드 코딩을 약간 해야 할 수도 있다.||이런 테스트를 성공 하기 위해서는 SUT내에 있는 로직의 일부를 하드 코딩으로 작성해야 할 때도 있다. 특히, 주요 경로를 태우기 위한 의사 결정 정보가 다른 컴포넌트의 호출에 의해서 얻어질 경우가 그러하다.||
||SUT를 실행하기 전에 SUT를 테스트 전 상태로 초기화해 테스트 픽스처를 설치해야 한다.||SUT를 실행하기 전에는 SUT를 테스트 전 상태로 초기화해 테스트 픽스처를 설치해야 한다.||
||SUT가 에러 없이 실행된다면 테스트를 통과했다고 본다. 현재 성숙 단계에서는 기대 결과 값과 실제 결과 값을 비교 하지 않는다.||SUT의 실행 과정에 오류가 발생 하지 않는 다면 테스트가 통과 되는 것으로 간주하며 이러한 성숙도 단계에서는 실제 결과값을 기대값과 비교 확인 하지 않는다.||
||주요 경로 결과 바로 검증||주요 경로의 직접 출력값 검증||

''page 201''
||테스트 자동화를 하다 보니 이런 코드도 작성하게 되는 것일 수도 있다||제품 코드 구현을 유도할 자동화된 테스트를 작성 하기 위해 분투 하고 있는 상태 일 수도 있다||
||"어떻게 하면 대안 경로를 실행되게 할 수 있을까?"||이 시점에서 품어야 할 의문은 "어떻게 하면 원인이 대안 경로를 실행하게 만들까?" 이다.||
||설정되는 테스트 스텁||설정가능한 테스트 스텁||

''page 202''
||테스트를 반복 가능하고 단단하게 만들기||테스트를 반복 가능하고 강건하게 만들기||
||굉장히 바람직한 부작용이 나타나게 된다.||굉장히 바람직한 부수효과가 나타나게 된다.||
||즉, 테스트가 훨씬 튼튼해지고 반복 가능해진다.||즉, 테스트가 보다 강건해지고 반복 가능해진다.||
||테스트 후 상태를 검증하는 방법을 자세히 알아봤다.||테스트 후 상태를 검증 하는 방법에 대하여 주로 알아봤다.||
||즉, 여전히 테스트가 안 된 요구 사항이 있고, 동작 검증을 통해서만 검증할 수 있다||즉, 행위 검증을 통해서만 검증이 되는 테스트 되지 않은 요구 사항을 가지고 있다는 것이다.||
||테스트 스텁과 그의 친구들을 통해 SUT로부터 나가는 메소드 호출을 가로챌 수 있다.||우리는 이미 잘알고 있는 테스트 스텁과 매우 유사한 종류들을 이용 하여 테스트 대상인 SUT에서 외부로 나가는 호출을 가로 챌 수 있다.||
||자동 테스트가 설치돼 있겠지만..||자동화된 테스트가 만들어졌겠지만..||

''page 203''
||어렵게 만드는 애매한 테스트..||어렵게 만드는 모호한 테스트..||
||또한 체계적으로 테스트케이스 클래스와 테스트메소드의 이름으로 테스트 조건을 보여줄 수 있게 해주면 의도를 더 잘 전달할 수 있다.||테스트 클래스와 메소드의 이름을 체계적으로 정하여 테스트의 조건과 검증 하려는 바가 명확 하게 나타나게 해주면 보다 정확하게 의도를 전달 할 수 있다.||
||누락된 버그에 대한 위험 줄이기||놓치는 버그에 대한 위험 줄이기||

''page 204''
||...캡슐화해(통과하면 안 되는 테스트가 통과하는) 거짓 음성..||...탭슐화해 거짓 음성(통과하면 안 되는 테스트가 통과하는)...||

= 15장 =
''page 207''
||애매한 테스트||모호한 테스트||
||테스트 조건문 로직||테스트 내 조건문 로직||

''page 208''
||애매한 테스트의 첫 번째 문제는 테스트를 이해하기 힘들게 만들고 유지 보수 하기도 힘들게 한다는 점이다.||모호한 테스트의 첫 번째 문제는 테스트를 이해하기 어렵게 만들어 유지 보수도 힘들게 한다는 점이다.||
||이러면 문서로서의 테스트를 만들기 어렵고, 높은 테스트 유지 비용 문제도 발생 할 수 있다.||이 문제는 문서로서의 테스트 작성 목적을 이룰 수 없게 만들고 결국은 높은 테스트 유지 보수 비용을 지불 하게 만든다.||
||애매한 테스트의 두 번째 문제는 애매한 테스트에 숨어 있는 테스트 코드 에러로 인해 버그가 빠져나갈 수 있다는 점이다.||모호한 테스트의 두 번째 문제는 모호한 테스트에 숨어 있는 테스트 코드 오류로 인해 버그가 발견 되지 않을 수 있다는 점이다.||
||이러면 버그투성이 테스트가 된다.||이것은 버그투성이 테스트를 만들게 된다.||
||미스터리한 손님은 정보가 너무 적을 때 생긴다. 욕심쟁이 테스트와 관련 없는 정보가 너무 많을 때 생긴다.||불가사의한 손님은 정보가 너무 적은 경우의 예이며 욕심쟁이 테스트 와 관련 없는 정보의 경우는 정보가 너무 많은 경우에 해당 하는 예이다.||

''page 209''
||보통 테스트 코드를 깔끔하고 간단하게 유지하려는 관심이 없는 것이 애매한 테스트의 근본 원인이다.|| 모호한 테스트가 발생 하게 되는 근본 원인은 일반적으로 테스트 코드를 깔끔 하고 단순 하게 유지 하는 것에 대한 주의를 기울이지 않기 때문이다.||
||하드 코딩된 테스트 데이터 픽스처나 단언문, SUT 인자의 데이터 값이 테스트 메소드에 하드 코딩돼 있어 입력과 기대 결과 값 사이의 인과 관계가 애매하다.||픽스처의 데이터 값, 단언문 또는 SUT의 인자값 등이 테스트 메소드에 하드 코딩 되어 있어 입력과 기대 출력 사이의 인과 관계를 파악 하기 어렵게 만든다.||
||간접 테스팅|| Bold 폰트가 누락 되어 있습니다. 다른 것 들은 모두 볼드체||

''page 211''
||해결책||가능한 해결책||

''page 219''
||신호 대비 잡음비||신호대잡음비||
||두 번재로 큰 충돌은 다른 테스트에서 같은 값을 쓰다가 충돌이 날 때 생긴다.||두 번째 주요 영향은 다른 테스트가 동일한 값을 사용하여 테스트 간의 충돌이 발생 할때 나타난다.||

''page 220''
Literal value에 대하여 번역 없이 사용 하였으나 Leteral Constant에 대해서는 문자 상수라고 번역 하셨습니다. 문자값 (스트링)과 혼란을 피하기 위하여 번역을 하지 않은신 거라면 문자 상수도 번역 하지 않는 것이 어떨지 의견 드립니다.

''page 229''
Custom Assertion을 맞춤 단언문으로 번역 하신 것을 "사용자 정의 단언문"으로 바꾸시는 것은 어떨지 의견 드립니다.

= 16장 =
''page 256''
그림 16.1의 원인에 대한 추축 부분이 "~ 인지도"로 되어 있는데 표현이 완결 되지 않은 느낌이 듭니다. 이를 "~일 가능성 조사 또는 확인" 등의 표현으로 바꾸어 주는 것이 어떨지 의견 드립니다.

''page 264''
||꼭 지속되는 데이터 저장소를 써야 해야 한다면...||꼭 지속되는 데이터 저장소를 사용 해야 한다면...||

''page 269''
그림 16.2 "~일지도" "~아닐지도"를 완결형 문장으로 변경 하면 어떨까요?
||Caveat emptor!||매수자위험부담원칙!||

''page 272''
||다시 말해 SUT를 너무 전부 테스트하려고 하는 것일 수 있다.||이것은 너무 큰 SUT를 테스트 하고 있는 것일 수 있다.||

''page 275''
||검증하려는 기능이 시간이나 날짜에 어떤 식으로든 의존한다.||검증하려는 기능이 시간이나 날짜에 어떤 의존관계를 가지고 있다.||
||..SUT를 헤갈리는 데 있다.||... SUT를 혼동 하는데 있다.||

''page 285''
||이런 게 느린 컴포넌트를 쓸 때 생길 수 있는 가장 일반적인 문제 중 하나다.||이것이 느린 컴포넌트를 사용 할 때 발생 하는 가장 보편적인 문제이다.||

= 17장 =

''page 291''
||이들 민감함이 무언인가를 ...||이들 민감함이 무엇인가를...||

''page 293''
||아니라면 바로 지금 바로 뭔가를 하자.||아니라면 조치를 취해야 하는 시점이다.||

''page 296''
||기존 테스트 유지 보수에 너무 힘이 많이 든다.||기존 테스트 유지 보수에 너무 많은 힘이 든다.||

''page 297''
||... 테스트를 치워버려 지금까지..||..테스트를 포기하여 지금까지...||

''page 306''
||...두려움 때문에 무자비한 리팩토링...||...두려움 때문에 과감한 리팩토링...||

= 18장 =
'' 312 ~ 390 페이지의 장 표시가 18장이 아닌 17장으로 되어 있습니다.''

''page 327''
||.. 테스트 적용 범위를 최대로 할 수 있고, 더 많은 필요한 테스트도 쉽게 추가할 수 있다.||.. 테스트 적용 범위를 최대로 할 수 있고, 필요한 테스트를 더 많이 쉽게 추가 할 수 있다.||

''page 330''
||조잡한 xUnit 테스트 인터프리터||초보적인 xUnit 테스트 인터프리터||
