= 리팩토링 =
프로그램이 초기 개발시와 초기 릴리즈 후에 변경될수 있다는 것은 엄연한 인생의 현실이다.
 * 리팩토링 정의 
  * 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경한 것

 * 리팩토링을 하는 이유 - 리팩토링이 필요하다는 것을 암시하는 냄새에 주의를 기울여야 한다.
 * 코드가 중복되어있다
  * 루틴이 너무 길다
  * 루프가 너무 길거나 깊이 중첩되어 있다
  * 클래스의 응집력이 약하다
  * 클래스 인터페이스가 일관된 추상화 수준을 제공하지 않는다
  * 매개 변수가 너무 많다
  * 클래스 내에서의 변경사항이 상호 관계를 고려하지 않고 구분되는 경향이 있다
  * 변경을 할 때 여러 개의 클래스를 동시에 수정해야 한다
  * 상속 계층 구조가 병렬로 변경되어야 한다.
  * Case 문이 병렬로 변경되어야 한다.
  * 함께 사용되는 연관된 데이터 항목이 클래스로 구성되지 않았다.
  * 루틴이 자신이 포함된 클래스보다 다른 클래스의 기능을 더 많이 사용한다.
  * 기본 데이터 형이 오버로드되었다
  * 클래스가 많은 일을 수행하지 않는다
  * 일련의 루틴들이 뜨내기 데이터를 전달하고 있다
  * 미들 맨 객체가 아무것도 하지 않는다
  * 한 클래스가 지나치게 다른 클래스에 참견한다
  * 루틴이름이 엉성하다
  * 데이터 맴버가 public이다
  * 서브클래스는 부모 클래스가 제공하는 극히 일부만을 사용한다.
  * 주석이 어려운 코드를 설명하기 위하여 사용되었다
  * 전역 변수가 사용되었다.
  * 루틴이 루틴을 호출하기 전에 설정 코드를 사용하거나, 루틴을 호출한 다음에 분해 코드를 사용한다.(p.785)
  * 프로그램이 언젠가 필요할 것 같은 코드를 포함하고있다.
 * 구체적인 리팩토링 - 수많은 리팩토링 방법을 학습하도록 하자
  * 데이터 수준 리팩토링
   * 매직 넘버(ex.PI)를 명명된 상수로 대체한다
   * 변수 이름을 보다 분명하고 많은 정보를 제공하는 이름으로 다시 명명한다
   * 표현식을 인라인(inline)으로 이동시킨다
   * 표현식을 루틴으로 대체한다
   * 중간변수를 사용한다
   * 여러 목적으로 사용 되는 변수를 여러 개의 단일 목적을 갖는 변수로 변환한다
   * 로컬에서 사용하기 위한 목적이라면 매개변수 대신 지역 변수를 사용한다.
   * 기본 데이터를 클래스로 변환한다.
   * 타입 코드 집합을 클래스나 열거로 변환한다.(enum사용)
   * 타입 코드 집합을 서브클래스를 갖는 클래스로 변환한다.
   * 배열을 객체로 변경한다
   * 컬렉션을 캡슐화한다
   * 전형적인 레코드를 데이터 클래스로 대체한다
  * 명령문 수준 리팩토링
   * 불린 표현식을 분해한다
   * 복잡한 불린 표현식을 잘 명명된 불린 함수로 이동시킨다
   * 서로 다른 조건문 내에 중복되어 있는 코드들을 결합한다
   * 루프 제어 변수 대신 break나 return을 사용한다
   * 중첩된 if-then-else 명령문 내에서 리턴 값을 할당하는 대신, 답을 알았을 때 곧바로 리턴한다.
   * 조건문(특히,반복되는 case문)을 다형성으로 대체한다.
   * 널 값을 테스트하는 대신, 널 객체를 생성하여 사용한다.
  * 루틴 수준 리팩토링
   * 루틴을 추출한다/메서드를 추출한다
   * 루틴의 코드를 인라인으로 이동시킨다
   * 긴 루틴을 클래스로 변환한다.
   * 복잡한 알고리즘 대신 간단한 알고리즘을 사용한다
   * 매개변수를 추가한다
   * 매개변수를 제거한다
   * 변경 연산으로부터 쿼리연산을 분리한다.
   * 매개변수를 이용하여 유사한 루틴을 결합한다.
   * 전달되는 매개변수에 따라서 행동하는 루틴들을 분리한다
   * 특정한 필드 대신 전체 객체를 전달한다
   * 전체 객체 대신 특정한 필드만 전달한다
   * 다운캐스팅을 캡슐화한다
  * 클래스 구현 리팩토링
   * 값 객체를 참조 객체로 변경한다
   * 참조 객체를 값 객체로 변경한다
   * 가상 루틴들을 데이터 초기화로 대체한다
   * 맴버 루틴이나 데이터의 위치를 변경한다.
   * 특화된 코드를 서브 클래스로 추출한다.
   * 유사한 코드를 슈퍼클래스로 결합한다
  * 클래스 인터페이스 리팩토링
   * 루틴을 다른 클래스로 이동시킨다
   * 한 클래스를 두 개로 변환한다
   * 클래스를 제거한다
   * 위임을 숨긴다
   * 미들맨을 제거한다
   * 상속을 위임으로 대체한다
   * 위임을 상속으로 대체한다
   * 외부 루틴을 소개한다
   * 확장 클래스를 소개한다
   * 노출된 맴버 변수를 캡슐화한다
   * 변할 수 없는 필드에 대한 Set() 루틴을 제거한다.
   * 클래스 외부에서 사용되기 위한 것이 아닌 루틴을 감춘다.
   * 사용되지 않는 루틴을 캡슐화한다
   * 슈퍼클래스와 서브클래스의 구현이 매우 유사하다면, 이 둘을 결합한다.
  * 시스템 수준 리팩토링
   * 제어할 수 없는 데이터를 위해서 명확한 참조 소스를 생성한다
   * 단방향 클래스 관계를 양방향 클래스 관계로 바꾼다
   * 양방향 클래스 관계를 단방향 클래스 관계로 바꾼다
   * 간단한 생성자 대신 팩토리 매서드를 제공한다.
   * 오류 코드를 예외로 대체하거나 그 반대로 한다
  * 안전한 리팩토링
   * 리팩토링을 시작하는 코드를 저장한다.
   * 리팩토링을 작게 유지한다.
   * 리팩토링은 한번에 하나만 수행한다
   * 여러분의 취할 단계에 대한 목록을 만든다
   * 주차장을 만든다(미래의 변경사항에 대한 목록을 만들어본다.)
   * 빈번하게 체크 포인트를 설정한다
   * 컴파일러의 경고를 활용한다
   * 다시 테스트한다
   * 테스트 케이스를 추가한다
   * 변경 사항을 검토한다
    * 작은 변경이 큰 변경보다 오류를 발생시킬 가능성이 더 높은 경향이 있다.(p800)
   * 리팩토링의 위험 수준에 따라서 접근 방법을 조절한다
  * 리팩토링에 좋지 않은 시기
   * 코드를 작성하고 수정하는 것을 감추는 용도로 리팩토링을 사용하지 않는다.
   * 코드를 재 작성하는 대신 리팩토링을 하지 않는다.
  * 리팩토링 전략
   * 루틴을 추가할 때 리팩토링 한다.
   * 클래스를 추가할 때 리팩토링 한다
   * 결합을 수정할 때 리팩토링한다
   * 오류를 유발할 가능성이 있는 모듈을 대상으로 삼는다
   * 복잡도가 높은 모듈을 대상으로 삼는다
   * 유지 보수 환경에서는 여러분이 맡은 부분을 개선한다
   * 정돈된 코드와 엉성한 코드간의 인터페이스를 정의한 후, 인터페이스를 통해서 코드를 이동시킨다(p803)
