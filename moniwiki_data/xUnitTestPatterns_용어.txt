[xUnitTestPatterns] 상위로 가기

== 패턴 목록 ==
 * Abstract Setup Decorator : 추상 설치 데코레이터
 * Abstract Test Fixture : 추상 테스트 픽스처
 * Abstract Testcase : 추상 테스트케이스
 * Abstract Testcase superclass : 추상 테스트케이스 상위클래스
 * Assertion Message : 단언 메시지
 * Assertion Method : 단언 메소드
 * Automated Teardown : 자동 해체
 * Back Door Manipulation : 뒷문 조작
 * Behavior Verification : 동작 검증
 * Chained Tests : 엮인 테스트
 * Configurable Test Double : 설정되는 테스트 대역
 * Creation Method : 생성 메소드
 * Custom Assertions : 맞춤 단언문
 * Data-Driven Test : 데이터 주도 테스트
 * Database Sandbox : 데이터베이스 샌드박스
 * Delegated Setup : 위임 설치
 * Delta Assertion : 델타 단언문
 * Dependency Injection : 의존 주입
 * Dependency Lookup : 의존 찾기
 * Derived Value : 파생값
 * Dummy Object : 더미 객체
 * Fake Object : 가짜 객체
 * Four-Phase Test : 4 단계 테스트
 * Fresh Fixture : 신선한 픽스처
 * Garbage-Collected Teardown : 가비지 컬렉션 해체
 * Generated Value : 생성값
 * Guard Assertion : 보호 단언문
 * Hard-Coded Test Double : 하드코딩된 테스트 대역
 * Humble Object : 대강 만든 객체
 * Implicit Setup : 암묵적 설치
 * Implicit Teardown : 암묵적 해체
 * In-line Setup : 인라인 설치
 * In-line Teardown : 인라인 해체
 * Layer Test : 레이어 테스트
 * Lazy Setup : 지연 설치
 * Literal Value : 리터럴 값
 * Minimal Fixture : 최소 픽스처
 * Mock Object : 모의 객체
 * Named Test Suite : 이름있는 테스트 스위트
 * Parameterized Test : 인자를 받는 테스트
 * Poor Man's Humble Executable : 얼렁뚱땅 대강 만든 실행기
 * Poor Man's Humble Object : 얼렁뚱땅 대강 만든 객체(불쌍한 남자의 초라한 오브젝트ㅋ)
 * Prebuilt Fixture : 미리 만든 픽스처
 * Recorded Test : 기록 테스트
 * Scripted Test : 스크립트 기반 테스트
 * Setup Decorator : 설치 데코레이터
 * Shared Fixture : 공유 픽스처
 * Standard Fixture : 표준 픽스처
 * State Verification : 상태 검증
 * Stored Procedure Test : 저장 프로시저 테스트
 * Suite Fixture Setup : 스위트 픽스처 설치
 * Table Truncation Teardown : 테이블 삭제 해체
 * Test Automation Framework : 테스트 자동 프레임워크
 * Test Discovery : 테스트 찾기
 * Test double : 테스트 대역
 * Test Enumeration : 테스트 나열
 * Test Helper : 테스트 도우미
 * Test Hook, Test Hooks : 테스트 훅
 * Test Method : 테스트 메소드
 * Test Runner : 테스트 실행기
 * Test Selection : 테스트 선택
 * Test Spy : 테스트 스파이
 * Test Stub : 테스트 스텁
 * Test Suite Object : 테스트 스위트 객체
 * Test Utility Method : 테스트 유틸리티 메소드
 * Test-Specific Subclass : 테스트용 하위클래스
 * Testcase Class : 테스트케이스 클래스
 * Testcase Class per Class : 클래스별 테스트케이스 클래스
 * Testcase Class per Feature : 기능별 테스트케이스 클래스
 * Testcase Class per Fixture : 픽스처별 테스트케이스 클래스
 * Testcase Object : 테스트케이스 객체
 * Testcase Superclass : 테스트케이스 상위클래스
 * Transaction Rollback Teardown : 트랜젝션 롤백 해체
 * Unfinished Test Assertion : 작업중인 테스트 단언문

== 냄새 목록 ==
 * Assertion Roulette : 단언 룰렛
 * Buggy Tests : 버그투성이 테스트
 * Conditional Test Logic : 테스트 내 조건문 로직
 * Developers Not Writing Tests : 테스트를 작성하지 않는 개발자
 * Erratic Test, Erratic Tests : 변덕스러운 테스트
 * Fragile Test : 깨지기 쉬운 테스트
 * Frequent Debugging : 잦은 디버깅
 * Hard-to-Test Code : 테스트하기 힘든 코드
 * High Test Maintenance Cost : 높은 테스트 유지 비용
 * Manual Intervention : 수동 조정
 * Obscure Test : 애매한 테스트
 * Production Bugs : 제품 버그
 * Slow Tests : 느린 테스트
 * Test Code Duplication : 테스트 코드 중복
 * Test Logic in Production : 제품 코드 내 테스트 로직

== [http://xunitpatterns.com/Goals%20of%20Test%20Automation.html 목표 : Goals of Test Automation] ==
 * Tests as Specification : 명세로서의 테스트
 * Fully Automated Tests : 완전 자동 테스트
 * Executable Specification : 실행가능한 명세
 * Bug Repellent : 버그 퇴치
 * Defect Localization : 결함 국소화
 * Tests as Documentation : 문서로서의 테스트
 * Tests as Safety Net : 안전망으로서의 테스트
 * Do No Harm : 해를 끼치지 않을 것 - 해롭지않아!
 * Repeatable Test, Repeatable Tests : 반복되는 테스트
 * Simple Tests : 단순한 테스트
 * Expressive Tests : 표현이 풍부한 테스트
 * separation of concern, Separation of Concerns : 관심의 분리
 * Robust Test, Robust Tests : 견고한 테스트

== [http://xunitpatterns.com/Principles%20of%20Test%20Automation.html 원칙 : Principles of Test Automation] ==
 * Design for Testability : 테스트하기 쉽게 설계하라
 * Use the Front Door First : 정문을 먼저 사용하라
 * Communicate Intent : 의도를 드러내라
 * Single Glance Readable, Single-Glance Readable : 한 눈에 읽을 수 있는
 * Keep Tests Independent : 테스트를 독립적으로 유지하라
 * Don’t Modify the SUT : SUT 를 고치지 마라
 * Isolate the SUT : SUT 를 격리하라
 * Minimize Test Overlap : 겹치는 테스트를 최소화해라
 * Minimize Untestable Code : 테스트 할 수 없는 코드를 최소화하라
 * Keep Test Logic Out of Production Code : 테스트 로직을 제품 코드에 넣지마라
 * No Test Logic in Production Code : 제품 코드에 테스트 코드 불가
 * Verify One Condition per Test : 테스트 별로 하나의 조건만 검증하라
 * Test Concerns Separately : 따로 테스트하라
 * Ensure Commensurate Effort and Responsibility : 효과와 책임을 적당하게 맞춰라

== 테스트 리팩토링 ==
 * Extract Testable Component : 테스트 가능한 컴포넌트 뽑아내기
 * In-line Resource : 인라인 자원
 * Make Resource Unique : 자원을 유일하게 만들기
 * Minimize Data : 최소 데이터
 * Replace Dependency with Test Double : 테스트 대역으로 의존 교체하기
 * Setup External Resource : 외부 자원 설치

== 이름 ==
 * (Uncle) Bob Martin : (엉클) 밥 마틴
 * Abraham Maslow : 매슬로우
 * Alistair Cockburn : 앨리스테어 코번
 * Ariane : 아리안(218)
 * Bell-Northern Research : 벨-노던 리서치
 * Brian Marrick : 브라이언 메릭
 * Clint Shank : 클린트 쉥크
 * Denis Clelland : 데니스 클리랜드
 * Dijkstra : 데이크스트라 (다익스트라)
 * Gerald M. Weinberg : 제럴드 M. 와인버그
 * Gerard Meszaros : 제라드 메스자로스, 제라드 메자로스?
 * James Newkirk : 제임스 뉴커크
 * Jeremy Miller : 제레미 밀러
 * Jim Coplien : 짐 코플리엔
 * John Hurst : 존 허스트
 * Joseph King : 조셉 킹
 * Joshua Kerievsky : 조슈아 케리에브스키
 * Kent Beck : 켄트 벡
 * Martin Fowler : 마틴 파울러
 * Michael Feathers : 마이클 페더스
 * Nortel : 노텔
 * Paolo Perrotta : 파올로 페로타
 * Rick Mugridge : 릭 머그리지
 * Rod Johnson : 로드 존슨
 * Sebastian Bergmann : 세바스찬 버그만
 * Seven Gorts : 스밴 고츠
 * Shaun Smith : 숀 스미스
 * Somerville : 소머빌
 * Stephen Covey : 스티븐 코비
 * Steve Jorgensen : 스티븐 요르겐센, 스티브??
 * Sven Gorts : 스밴 고츠(Seven Gorts)
 * Ted O’Grady : 테드 오 그레디
 * Tim Mackinnon : 팀 맥키넌
 * Ward Cunningham : 워드 커닝햄

== 그외 == 
 * ACID : atomicity, consistency, isolation, durability (원자성, 일관성, 독립성, 지속성)
 * AllTests Suite : AllTests 스위트
 * Anonymous Creation Methods : 익명 생성 메소드
 * Anonymous Inner Test Double : 익명 내부 테스트 대역
 * Application Program Interface, API : 응용프로그램 인터페이스
 * Architect Also Implements : 구현도 하는 아키텍트
 * Argument-Describing Message : 인자를 보여주는 메시지
 * Assertion Method Styles : 단언 메소드 형식
 * Assertion-Identifying Message : 단언문 구별 메시지
 * Asynchronous Code : 비동기 코드
 * Attachment Method : 첨부 메소드
 * Automated Exercise Teardown : 자동 실행 해체
 * Automated Fixture Teardown : 자동 픽스처 해체
 * Automated tests : 자동 테스트
 * Back Door Setup : 뒷문 설치
 * Back Door Teardown : 뒷문 해체
 * Back Door Verification : 뒷문 검증
 * Base Name : 기본 이름
 * Base class : 상위클래스
 * Behavior Sensitivity : 동작 민감함
 * Behavior Smells : 16장, 동작 냄새
 * Behavior-Exposing Subclass : 동작 노출 하위클래스
 * Behavior-Modifying Subclass : 동작 변경 하위클래스
 * Bespoke Assertion : 주문제작 단언문
 * Big Design Upfront, Big design up front, BDUF : 미리 크게 설계하기
 * Block Closure : 블록 클로저
 * Bottom-Up : 상향식
 * Buggy software : 버그 있는 소프트웨어
 * Built-In Test Recording : 내장 테스트 기록 기능
 * Built-in Self-Test : 내장 자체 테스트
 * COTS : commercial off-the-shelf - 상용 기성품
 * CRUD : Create Read, Update and Delete (생성, 읽기, 수정, 삭제)
 * Calculated Value, Calculated Values : 계산된 값
 * Capacity tests : 수용 능력 테스트
 * Capture : 잡아내다, 갈무리하다
 * Capture/Playback Test : 녹화/재생 테스트
 * Cascade Delete : 단계적 삭제
 * Cascade Updade : 단계적 업데이트 
 * Causes : 원인
 * Caveat emptor! : 소비자 역시 주의하라! 매수자위험부담원칙
 * Choosing the Right Assertion : 올바른 단언문 선택하기
 * Citation : 표기
 * Cleanup Method : 정리 메소드
 * Code Organization : 코드 조직
 * Command Prompt : 명령 프롬프트
 * Command object : Command [GOF] 객체
 * Command-Line Test Runner : 명령행 테스트 실행기 테스트 실행기)
 * Common Features : 공통 특징
 * Common Location : 공통 위치
 * Comparator : 비교자[WWW]
 * Complete Constructor Method : 완전 생성 메소드
 * Complex Teardown : 복잡한 해체 애매한 테스트
 * Complex Test : 복잡한 테스트
 * Component Broker : 컴포넌트 브로커
 * Component Registry : 컴포넌트 레지스트리
 * Component-based development : 컴포넌트 기반 개발
 * Composite : Composite [GOF]
 * Concatenation : 문자열 합치기
 * Conditional Verification Logic : 검증 조건문 로직
 * Condor : 콘도르(계층적 클러스터링 시스템)
 * Configurable Mock Objects : 설정되는 모의 객체
 * Configurable Registry : 설정되는 레지스트리
 * Configurable Test Spy : 설정되는 테스트 스파이
 * Configurable Test Stub : 설정되는 테스트 스텁
 * Configuration Interface : 설정 인터페이스
 * Configuration Mode : 설정 모드
 * Constant Value : 상수값
 * Constructor Injection : 생성자에서 주입
 * Constructor Test : 생성자 테스트
 * Context Sensitivity : 문맥에 민감함
 * Continuous Integration : 지속적인 통합
 * Controlling Indirect Inputs : 간접 입력 제어하기
 * Cross-Reference : 상호 참조
 * Cross-functional tests : 교차 기능 테스트
 * Cruise Control : 크루즈 컨트롤
 * Crystal Report, Crystal Reports : 크리스탈 리포트
 * Custom Assertion Test : 맞춤 단언문 테스트
 * Custom Equality Assertion : 맞춤 동등 단언문
 * Customer Persistence : 고객 저장
 * Cut-and-Paste : Cut-and-Paste ---> Copy & Paste 로 통일하자.
 * Cut-and-Paste Code Reuse : Cut-and-Paste 코드 재사용
 * DB Schema per Test Runner : 테스트 실행기 별 DB 스키마
 * DOC : depended-on component, 의존 컴포넌트
 * Data Access Object [CJ2EEP] : 데이터 접근 객체
 * Data Loader : 데이터 로더
 * Data Retriever : 데이터 반환기
 * Data Sensitivity : 데이터에 민감함
 * Data Transfer Object : 데이터 전송 객체(Data Transfer Object. DTO), Value Object 같은 거
 * Data-Driven Test Interpreter : 데이터 주도 테스트 인터프리터
 * Database Extraction Script : 데이터베이스 추출 스크립트
 * Database Partitioning Scheme : 데이터베이스 분할 스키마 데이터베이스 샌드박스
 * Database Patterns : 25장, 데이터베이스 패턴
 * Database Population Script : 데이터베이스 채우기 스크립트
 * Database Transaction Rollback Teardown : 데이터베이스 트랜젝션 롤백 해체
 * Database as SUT API? : SUT API 로서의 데이터베이스?
 * Decorated Lazy Setup : 데코레이트되는 지연 설치
 * Decorator : 데코레이터, 장식자, 
 * Dedicated Database Sandbox : 전용 데이터베이스 샌드박스
 * Delegated Fixture Setup : 위임 픽스처 설치
 * Delegated Teardown : 위임 해체
 * Deliver early, deliver often : 빨리 인도하고, 자주 인도하라.
 * Dependency Initialization Test : 의존 초기화 테스트
 * Dependent Test : 의존하는 테스트, 종속 테스트
 * Derived Expectation : 파생 기대값
 * Derived Input : 파생 입력값
 * Design-for-Testability Patterns : 26장, 테스트하기 쉬운 설계 패턴
 * Diagnostic Assertion : 진단 단언문
 * Direct Test Method Invocation : 테스트 메소드 직접 호출
 * Distinct Generated Value, Distinct Generated Values : 별개의 생성값 생성값, 고유 생성값?
 * Distinct Value : 고유값, 유일값, 구분값, 명확한 값 
 * Divide and Test : 나눈 후 테스트하라
 * Domain Assertion : 도메인 단언문
 * Domain-Driven Design : 도메인 주도 설계
 * Don't throw the baby out with the bath water : 아이를 목욕물과 함께 버리지 마시라. 서두르지 마라. 알맹이를 껍데기랑 같이 버리지 마라
 * Don’t call us; we’ll call you : 전화 걸지 마세요. 우리가 걸테니
 * Downstream System : 하향 시스템
 * Dummy Argument : 더미 인자
 * Dummy Attribute : 더미 어트리뷰트
 * Dummy Parameter : 더미 파라메터
 * Dummy Value, Dummy Values : 더미 값
 * Dynamic Systems Development Method : 동적 시스템 개발방법론 (DSDM)
 * Dynamically Generated Test Double : 동적 생성 테스트 대역
 * EJB Session Beans : EJB 세션 빈
 * Eager Mock Object : 욕심쟁이 모의 객체 모의 객체)
 * Eager Test, Eager Tests : 욕심쟁이 테스트 단언 룰렛
 * Economics of Test Automation : 테스트 자동화 경제학
 * Encapsulated Test Runner : 캡슐화된 테스트 실행기
 * Encapsulation : 캡슐화
 * Endoscopic Testing : 내시경 테스팅[ET]
 * Entity Bean, Entity Beans : 엔티티 빈
 * Entity Chain Snipping : 엔티티 체인 스니핑
 * Enumerated Values : 나열값
 * Enumeration : 나열, 열거, 목록, 일람표
 * Equality : 동등
 * Equality Assertions : 동등 단언문
 * Equality Pollution : 동등 오염 제품 코드 내 테스트 로직)
 * Eric Evans : 에릭 에반스
 * Erich Gamma : 에릭 감마
 * Exercise SUT and verify outcome : SUT 실행 후 결과 검증
 * Expectation-Describing Message : 기대를 보여주는 메시지
 * Expected Behavior : 기대 동작
 * Expected Behavior Specification : 기대 동작 명세
 * Expected Exception Assertions : 기대 예외 단언문
 * Expected Exception Tests : 기대 예외 테스트
 * Expected Object : 기대 객체
 * Expected State Specification : 기대 상태 명세
 * Exploratory Testing : 탐험적 테스팅, 탐색적 테스팅(용어집)
 * Expression Builder : 표현식 작성기
 * External Test Recording : 외부화된 테스트 기록
 * Extract Class : 클래스 뽑아내기[Fowler]
 * Extract Implementer : 구현 뽑아내기[Fowler]
 * Extract Interface : 인터페이스 뽑아내기[Fowler]
 * Extract Method : 메소드 뽑아내기[Fowler]
 * Extract Superclass : 상위클래스 뽑아내기[Fowler]
 * Facade : 퍼사드[GOF] 
 * Factory Method : 팩토리 메소드[GOF]
 * Fake Database : 가짜 데이터베이스
 * Fake Service Layer : 가짜 서비스 레이어
 * Fake Web Service : 가짜 웹 서비스
 * Family : 계통, 계열, 군, 패밀리?
 * Faster Tests without Shared Fixtures : 공유 픽스처 없이 테스트 빠르게 만들기
 * Feature granularity : 기능 입도(粒度)
 * Feature visibility : 기능 가시성
 * Feature-Driven Development  : 기능 주도 개발
 * File System Test Runner : 파일 시스템 테스트 실행기
 * Finder Methods : 찾기 메소드 테스트 유틸리티 메소드
 * Fixture : 픽스처 
 * Fixture Setup Patterns : 픽스처 설치 패턴(20장)
 * Fixture Setup Testcase : 픽스처 설치 테스트케이스
 * Fixture Teardown Patterns : 22장, 픽스처 해체 패턴
 * Fixture designed test-by-test : 단계별 테스트로 픽스처 설계하기
 * Fixture holding class variable : 클래스 변수에 들어 있는 픽스처
 * Fixture setup phase : 픽스처 설치 단계
 * Flexible Test : 유연한 테스트
 * For Tests Only : 테스트 전용
 * Force, Forces : 영향<Forces>
 * Foreign Method : 외부 메소드[Fowler]
 * Fragile Fixture : 깨지기 쉬운 픽스처
 * Framework-Invoked Setup : 프레임워크 호출 설치
 * Framework-Invoked Teardown : 프레임워크 호출 해체
 * Fresh Context : 신선한 문맥
 * Further Reading : 더 읽을거리
 * Fuzzy Equality Assertions : 퍼지 동등 단언문
 * GUI : 그래픽 환경
 * General Fixture : 일반 픽스처
 * Global Fixture : 전역 픽스처
 * Glossary : 용어집
 * Goals of Test Automation : 테스트 자동화의 목표(3장)
 * Graphical Test Runner : 그래픽 테스트 실행기
 * Green bar : 초록 막대
 * Guaranteed In-line Teardown : 확정 인라인 해체
 * Guard Clause : 보호절 [SPBB]
 * Hand-Built Test Double : 직접 만든 테스트 대역
 * Hand-Coded Teardown : 수동 해체 코드
 * Hand-Scripted Test, Hand-Scripted Tests, hand-scripting test : 직접 작성한 스크립트 기반 테스트 스크립트 기반 테스트
 * Hand-Written Test : 직접 작성한 테스트
 * Hard-Coded Dependency : 하드코딩된 의존 테스트하기 힘든 코드
 * Hard-Coded Mock Object : 하드 코딩된 모의 객체
 * Hard-Coded Setup Decorator : 하드코딩된 설치 데코레이터
 * Hard-Coded Test Data : 하드코딩된 테스트 데이터
 * Hard-Coded Test Spy : 하드 코딩된 테스트 스파이
 * Hard-Coded Test Stub : 하드 코딩된 테스트 스텁
 * Hard-Coded Test Stub : 하드코딩된 테스트 스텁
 * Hard-Coded Values : 하드코딩된 값 리터럴 값
 * Hexagonal Architecture : 6각형 아키텍처
 * Higher-Level Language, higher level language : 상위 언어
 * Highly Coupled Code : 강하게 결합된 코드
 * Highly Maintainable Automated Tests : 잘 유지되는 자동 테스트
 * Hollywood principle : 헐리우드 원칙
 * Hooked Setup : 훅 설치
 * Hooked Teardown : 훅 해체
 * How It Works : 작동 원리
 * Humble Container Adapter : 대강 만든 컨테이너 어댑터
 * Humble Dialog : 대강 만든 다이얼로그
 * Humble Executable : 대강 만든 실행기
 * Humble Transaction Controller pattern : 대강 만든 트랜젝션 컨트롤러 패턴 대강 만든 객체
 * Hybrid Fixture Setup : 혼합형 픽스처 설치
 * Immutable : 변경 불가능한
 * Immutable Shared Fixture : 불변 공유 픽스처 공유 픽스처
 * Imposter : 사기꾼
 * In-Database Stored Procedure Tests : 데이터베이스 내 저장 프로시저 테스트
 * In-Memory Database : 메모리 데이터베이스
 * In-line Temp [Fowler] : 임시변수 합치기[Fowler] a = GetA; return a; 를 return GetA; 로 바꾸는 리팩토링
 * Incomplete and Skipped Tests : 불완전하고 건너뛰는 테스트
 * Incremental Delivery : 점증적 인도
 * Incremental Speedups : 점진적인 속도 향상
 * Incremental Tabular Test : 점진적인 테이블 테스트 인자를 받는 테스트
 * Incremental Tests : 점진적인 테스트
 * Indented Test Code : 들쑥날쑥한 테스트 코드
 * Independent Tabular Test : 독립적인 테이블 테스트
 * Independent Test : 독립적인 테스트
 * Indirect Output Registry : 간접 출력 레지스트리
 * Infrequently Run Tests : 드문 테스트 실행
 * Inner Test Doubles : 내부 테스트 대역 하드코딩된 테스트 대역)
 * Instance : 인스턴스(객체라고 하면 너무 범위가 넓을 듯)
 * Instance variable : 인스턴스 변수(static 변수와는 반대의, 일반 멤버 변수)
 * Intent-Revealing Names : 의도가 드러나는 이름[SBPP]
 * Interacting Tests : 서로 반응하는 테스트 변덕스러운 테스트
 * Interacting Tests Suite, Interacting Test Suites : 서로 반응하는 테스트 스위트
 * Interface Sensitivity : 인터페이스에 민감함
 * Introduce Explaining Variable : 설명적인 변수 추가하기[Fowler]
 * Introduce Field : 필드 추가[JBrains]
 * Introduce Local Extension : 지역 확장 추가[Fowler]
 * Introduce Parameter : 인자 도입[JBrains]
 * Irrelevant Information : 관련 없는 정보
 * Iterative-incremental development : 반복-점진적 개발
 * JUnit New Instance Behavior : JUnit의 새 인스턴스 동작
 * Layered Architecture : 레이어 아키텍트
 * Layered Test : 레이어 테스트
 * Lazy Initialization : 지연 초기화[SBPP]
 * Lazy Teardown : 지연 해체
 * Leakage : 누수(메모리 누수)
 * Lonely Tests : 외로운 테스트
 * Long Test : 긴 테스트 
 * Loop-Driven Test : 반복문 주도 테스트
 * Loopback : 루프백
 * Lost Tests : 놓친 테스트
 * Managing Shared Fixtures : 공유 픽스처 관리
 * Manual Debugging : 수동 디버깅
 * Manual Event Injection : 수동 이벤트 발생
 * Manual Fixture Setup : 수동 픽스처 설치
 * Manual Result Verification : 수동 결과 검증
 * Marker Interface : 표시용 인터페이스[PJV1]
 * Maslow’s hierarchy of needs : 매슬로우의 욕구 계층 이론
 * Master Data : 마스터 데이터
 * Microsoft Office products : 마이크로소프트 오피스 제품군
 * Minimal Context : 최소 문맥 
 * Missing Assertion Message : 빠진 단언 메시지
 * Missing Test : 빠진 테스트
 * Missing Unit test, Missing Unit tests : 빠진 단위 테스트
 * Mocks, Fakes, Stubs, and Dummies (in Appendix B) : 모의 (부록 B)
 * Move Field : 필드 옮기기[Fowler]
 * Move Method : 메소드 옮기기[Fowler]
 * Multi-threaded software : 다중쓰레드 소프트웨어
 * Multiple Test Conditions : 여러 테스트 조건
 * Multiresource In-line Teardown : 다중 자원 인라인 해체
 * Multithread :  다중쓰레드
 * Mystery Guest : 미스테리한 손님
 * Naive : 조잡한, 대충 - 단순한,뻔한,고지식한?
 * Naive In-line Teardown : 조잡한 인라인 해체
 * Naive xUnit Test Interpreter : 조잡한 xUnit 테스트 인터프리터
 * Named State Reaching Method : 이름 있는 상태 도달 메소드
 * Need-Driven Development : 필요 주도 개발[MRNO]
 * Neverfail Test : 절대 실패하지 않는 테스트
 * No battle plan survives contact with the enemy : 어떤 전투계획도 눈앞의 적에겐 무력하다(Colin Powell : 콜린 파월)
 * Non-deterministic Tests,  Nondeterministic Tests : 비결정적 테스트
 * Not Enough Time : 부족한 시간
 * Null Object : 널 객체[PLOPD3]
 * Object Attribute Equality Assertion : 객체 속성 동등 단언문
 * Object Factory : 객체 팩토리
 * Object Mother : 객체 부모
 * Object Relational Mapping : 객체 관계 매핑
 * Object Transaction Rollback Teardown : 객체 트랜젝션 롤백 해체
 * Obscure Setup : 애매한 설치
 * Observer : Observer(관찰자)
 * One Bad Attribute pattern : 하나의 잘못된 속성 패턴
 * Optional Arguments : 생략 가능한 인자, 추가 인자
 * Organizational Pattern : 조직 패턴
 * Organizing Our Tests : 테스트 조직하기 (12장)
 * Outside-in, outside in : 밖에서 안으로
 * Overcoupled Software : 너무 결합된 소프트웨어
 * Overcoupled Test : 심하게 결합된 테스트
 * Overspecified Software : 심하게 명세된 소프트웨어
 * Overuse of Behavior Verification : 동작 검증의 잦은 사용
 * Parameter Injection : 인자로 주입
 * Parameterized Anonymous Creation Method : 인자를 받는 익명 생성 메소드
 * Parameterized Creation Methods : 인자를 받는 생성 메소드
 * Parameterized Setup Decorator : 인자를 받는 설치 데코레이터
 * Per-Functionality Tests : 기능별 테스트
 * Per-Run Fixtures : 실행별 픽스처
 * Persist : 지속, 유지
 * Persistence Layer Test : 지속 레이어 테스트
 * Persistent Fixtures Management : 지속되는 픽스처 관리(9장)
 * Persistent Fresh Fixtures : 지속되는 신선한 픽스처
 * Philosophy of Test Automation : 테스트 자동화의 철학(4장)
 * Placeholder : 플레이스 홀더
 * Pluggable Behavior : 동작 플러그인 [SPBB]
 * Possible Solution : 해결책
 * Prebuilt Context : 미리 만든 문맥
 * Presentation Layer Test : 프레젠테이션 레이어 테스트
 * Preserve Whole Object : 객체를 인자로 넘기기[Fowler]
 * Principles of Test Automation : 테스트 자동화의 원칙(5장)
 * Private Fixture : 개인용 픽스처
 * Procedural : 절차적?
 * Procedural Behavior Verification : 절차형 동작 검증
 * Procedural Software : 절차형 소프트웨어
 * Procedural State Verification : 절차형 상태 검증
 * Procedural Test Stubs : 절차형 테스트 스텁
 * Procedural World : 절차적 세상
 * Production Logic in Test : 테스트 내 제품 로직
 * Programmatic Test : 프로그래밍 방식 테스트
 * Project Chartering : 프로젝트 권한 주기(Project Chartering)
 * Pseudo Object, Pseudo-Object : 의사 객체
 * Pull Up Field, Pull-Up Field : 필드 올리기[Fowler]
 * Pull Up Method, Pull-Up Method : 메소드 올리기[Fowler]
 * Pushdown decorator : 푸시다운 데코레이터
 * QA : 품질보증
 * Random Generated Value : 무작위 생성값
 * Record and Playback Test : 기록 후 재생 테스트
 * Recording : 기록기
 * Red Bar : 빨간 막대
 * Red-Green-Refactor : 빨간-초록-리팩토링
 * Reduce Data : 줄인 데이터
 * Reducing Test Code Duplication : 테스트 코드 중복 줄이기
 * Refactored Recorded Test : 리팩토링한 기록 테스트
 * Refactoring : 리팩토링
 * Refactoring Notes : 리팩토링 (Notes 는 무시)
 * Registry, Registries : 레지스트리[PEAA]
 * Reinventing the Wheel : 바퀴 재발명하기
 * Related Generated Value : 관련 생성값
 * Reload Classes : 클래스 다시 읽기
 * Remote Proxy : 원격 프락시[GOF]
 * Remote Stored Procedure Test, Remoted Stored Procedure Test : 원격 저장 프로시저 테스트
 * Rename Method : 이름 바꾸기[Fowler]
 * Repelling bugs : 버그 퇴치
 * Replace Magic Number with Symbolic Constant [Fowler] : 매직 넘버를 기호 상수로 바꾸기[Fowler]
 * Replace Nested Conditional with Guard Clauses : 중첩 조건문을 보호절로 바꾸기[Fowler]
 * Reproduce : 재현
 * Resource Leakage : 자원 누수
 * Resource Optimism : 자원 낙관주의 변덕스러운 테스트
 * Response time tests : 응답 시간 테스트
 * Result Verification : 결과 검증(10장)
 * Result Verification Patterns : 21장, 결과 검증 패턴
 * Retrieval Interface : 검색 인터페이스
 * Reuse Test for Fixture Setup : 픽스처 설치를 위한 테스트 재사용
 * Reused Fixture : 픽스처 재사용
 * Risk Avoidance : 위험회피
 * Risk of Missed Bugs : 빠진 버그에 대한 위험성
 * Roadmap : 길잡이
 * Robot User Test : 로봇 사용자 테스트
 * Robot User Test Framework : 로봇 사용자 테스트 프레임워크
 * Root Cause : 근본 원인
 * Row Test : 로우 테스트
 * Ruby : Ruby (모든 프로그래밍 언어, 개발툴은 영어를 그대로 쓴다)
 * Run As Test : 테스트로 실행하기
 * Running Groups of Tests : 테스트 집단 실행하기
 * STTCPW : The simplest thing that could possibly work.
 * SUT : system unter test, 테스트 대상 시스템
 * SUT API Encapsulation : SUT API 캡슐화 테스트 유틸리티 메소드)
 * SUT Encapsulation Method : SUT 캡슐화 메소드
 * Saboteur : 훼방꾼
 * Sandbox : 샌드박스
 * Sardinia : 사르디니아
 * Self Call : 자체 호출
 * Self Shunt : 자체 분기
 * Self-Calls : 내부 호출, 자체 호출[WWW]
 * Self-Checking Test : 자체검사 테스트(Ref)
 * Self-Describing Value : 자기기술 값
 * Sensitive Equality : 민감한 동등
 * Service Facade : 서비스 퍼사드 [CJ2EEP]
 * Service Layer Test : 서비스 레이어 테스트
 * Service Locator : 서비스 탐지기
 * Setter Injection : 세터로 주입 의존 주입)
 * Shared Context : 공유 문맥
 * Shared Fixture Construction : 공유 픽스처 생성
 * Shared Fixture Guard Assertion : 공유 픽스처 보호 단언문
 * Shared Fixture State Assertion : 공유 픽스처 상태 단언문
 * Shared Setup Method : 공유 설치 메소드
 * Simple Equality Assertions : 단순 동등 단언문 (예 : assertEquals(expected, actual) 같은 거)
 * Simple Guard Assertion : 단순 보호 단언문
 * Simple Success Test : 단순 성공 테스트
 * Simulator : 시뮬레이터
 * Single Layer Test : 단일 레이어 테스트
 * Single Test Suite : 단일 테스트 스위트 이름있는 테스트 스위트. suite 가 테스트케이스 클래스를 하나만 리턴하는 클래스.
 * Single-Condition Test, Single Condition Test : 단일 조건 테스트
 * Single-Outcome Assertions, Single Outcome Assertion : 단일 결과 단언문. fail 같은 거
 * Skippable Sections : 건너뛸 수 있는 절[PLOPD3]
 * Slow Component Usage : 느린 컴포넌트 사용
 * Smalltalk : Smalltalk(스몰토크)
 * Smells in This Chapter : 이 장에서의 냄새들
 * Smoke Test : 스모크 테스트[SCM]
 * Smoke Test Suite : 스모크 테스트 스위트
 * Solution Patterns : 해결책 패턴
 * Source : 출처
 * Special-Purpose Suite , Special Purpose Suite : 특수 목적 스위트
 * Sprout Class : 새싹 클래스 [WEwLC]
 * Stale Fixture : 쉰 픽스처
 * Standard Context : 표준 문맥
 * State pattern : 상태 패턴[GOF]
 * State-Based Testing : 상태 기반 테스팅
 * State-Exposing Subclass : 상태 노출 하위클래스
 * Stated Outcome Assertions : 결과지정 단언문
 * Statically Generated Test Double : 정적 생성 테스트 대역
 * Stop on first failure : 처음 실패하면 멈추기
 * Stored Procedure : 저장 프로시저
 * Strategy : 전략, 기법, 방식, 
 * Strategy object : 스트레티지 객체[GOF]
 * Stress tests : 스트레스 테스트
 * String representation : 문자열로 나타내기
 * Subclassed Humble Object : 상속받은 대강 만든 객체
 * Subclassed Singleton : 상속받은 싱글톤
 * Subclassed Test Double : 상속받은 테스트 대역
 * Subcutaneous Testing : 피하(皮下) 테스트
 * Subset Suite : 부분 스위트
 * Substitutable Singleton : 바꿀 수 있는 싱글턴
 * Substituted Singleton : 교체 싱글턴
 * Suite : 스위트
 * Suite of Suites : 스위트들의 스위트
 * Symbolic Constant : 기호 상수(상수값을 저장하는 장소. const int a = 1; 에서의 a) ???
 * Symptoms : 증상
 * TBD : To Be Determined. 미정
 * Tabular Test : 테이블 테스트
 * Teardown Guard Clause : 보호절 해체
 * Teardown Guard Clauses : 해체 가드절(-> 인라인 해체)
 * Teardown Method : 해체 메소드
 * Template Method : 템플릿 메소드[GOF]
 * Temporary Test Stub : 임시 테스트 스텁 테스트 스텁)
 * Test Automation Strategy : 테스트 자동화 전략(6장)
 * Test Code Reuse : 테스트 코드 재사용
 * Test Commands : 테스트 명령(command)
 * Test Definition : 테스트 정의
 * Test Dependency in Production : 제품 코드 내 테스트 의존
 * Test Double Patterns : 23장, 테스트 대역 패턴
 * Test Double Subclass : 테스트 대역 하위클래스
 * Test Double as Back Door : 뒷문으로서의 테스트 대역
 * Test Execution : 테스트 실행
 * Test First Development, Test-First Development : 테스트 우선 개발
 * Test Fixture Registry : 테스트 픽스처 레지스트리 테스트 도우미 
 * Test Fixture Strategy : 테스트 픽스처 전략
 * Test Helper Mixin : 테스트 도우미 믹스인
 * Test Helper Object : 테스트 도우미 객체
 * Test Infected. Programmers Love Writing Tests. : 테스트에 중독되다. 테스트 작성을 푹 빠진 프로그래머들.
 * Test Method Discovery : 테스트 메소드 찾기
 * Test Method Selection : 테스트 메소드 선택
 * Test Methods per class : 클래스별 테스트 메소드
 * Test Naming Conventions : 테스트 이름 규약
 * Test Object Registry : 테스트 객체 레지스트리
 * Test Organization Patterns : 테스트 조직 패턴(24장)
 * Test Reused for Fixture Setup : 픽스처 설치를 위한 테스트 재사용
 * Test Run Wars : 테스트 실행 전쟁 변덕스러운 테스트)
 * Test Smells : 테스트 냄새(15장) 
 * Test Strategy Patterns : 테스트 전략 패턴(18장)
 * Test Suite Enumeration : 테스트 스위트 나열
 * Test Suite Factory : 테스트 스위트 팩토리
 * Test Suite Object Generator : 테스트 스위트 객체 생성기
 * Test Suite Object Simulator : 테스트 스위트 객체 시뮬레이터
 * Test Suite Procedure : 테스트 스위트 프로시저
 * Test Tree Explorer : 테스트 트리 탐색기
 * Test Utility Tests : 테스트 유틸리티용 테스트
 * Test after : 테스트 나중
 * Test driver : 테스트 개발자
 * Test writer : 테스트 작성자
 * Test-Specific Equality : 테스트용 동등
 * Test-Specific Extension : 테스트용 확장
 * Test-by-test : 단계별 테스트
 * TestCaller : 테스트호출자
 * Testability : 테스트용이성, 쉬운 테스트
 * Testcase : 테스트케이스
 * Testcase Baseclass : 테스트케이스 부모클래스
 * Testcase Class Discovery : 테스트케이스 클래스 찾기 테스트 찾기
 * Testcase Class Selection : 테스트케이스 클래스 선택
 * Testcase Class Structure : 테스트케이스 클래스 구조
 * Testcase Class Suite : 테스트케이스 클래스 스위트
 * Testcase Class as Test Double : 테스트 대역으로서의 테스트케이스 클래스
 * Testcase Class per Method : 메소드별 테스트케이스 클래스
 * Testcase Class per User Story : 사용자 스토리별 테스트케이스 클래스
 * Testing Stored Procedures with JUnit : JUnit 으로 저장 프로시저 테스트하기
 * Testing Stored Procedures with JUnit : 보충자료 "JUnit 으로 저장 프로시저 테스트하기"
 * Testing Stored Procs with JUnit : JUnit 으로 저장 프로시저 테스트하기
 * Testing Terminology : 테스트 용어
 * Testing by Layers : 레이어를 통한 테스팅 
 * Testing with Databases : 데이터베이스와 테스트하기(13장)
 * The Bare Minimum : 최소한 알아야 할 것
 * The simplest thing that could possibly work : 될 거 같은 일 중에서 가장 간단한 것
 * There’s Always an Exception : 보충자료 "항상 예외는 있다"
 * Thread-Specific Storage [POSA2] : 쓰레드 고유 스토리지[POSA2]
 * Too Many Tests : 너무 많은 테스트
 * Top-Down : 하향식
 * Toplink : Java objects 를 Relational data 혹은 XML element 형태로 변환하거나 그 반대의 경우로 변환시키는 기능을 제공한다
 * Transaction Rollback Pain : 보충자료. 트랜젝션 롤백 고통
 * Transaction Script [PEAA] : 트랜젝션 스크립트[PEAA]
 * Transient Fixture Management : 1회용 픽스처 관리 (8장)
 * Transient Fresh Fixture : 1회용 신선한 픽스처
 * Troubleshooting Advice : 문제 해결을 위한 조언
 * True Humble Executable : 진정한 대강 만든 실행기
 * True Humble Object : 진정한 대강 만든 객체 설명 : 로직을 별도 class 에 두고, 델리게이트. 테스트는 별도 클래스를 대상으로 수행. Poor Man's Humble Object 와는 반대
 * Unconfigurable Test Doubles : 설정 안되는 테스트 대역
 * Unfinished Test Method Generation from Template : 템플릿으로 작업중인 테스트 메소드 만들기
 * Unified Modeling Language : 통합 모델링 언어(UML)
 * Unit Test Rulz : 보충자료 "단위 테스트 규칙" 
 * Unrepeatable Test : 반복 안 되는 테스트
 * Untestable Code : 테스트 할 수 없는 코드
 * Untestable Test Code : 테스트 할 수 없는 테스트
 * Untested Code : 테스트 안 된 코드 제품 버그
 * Untested Requirement, Untested Requirements : 테스트 안 된 요구사항
 * Upstream System : 서버
 * Usability Test : 사용성 테스트
 * Usage Interface : 사용 인터페이스
 * Use Case, use cases : 유스 케이스
 * Using Delta Assertions to Detect Data Leakage : 델타 단언문으로 데이터 누수 찾기
 * Using Test Doubles : 테스트 대역 사용하기(11장)
 * Utility Method Location : 유틸리티 메소드 위치
 * VBA(Visual Basic for Applications) : 내장 VBA
 * Value Patterns, Value Pattern : 값 패턴
 * Verbose Test : 장황한 테스트
 * Verification Method : 검증 메소드 맞춤 단언문)
 * Virtual Clock : 가상 시계 [VCTP] (L2TickCount 같은 거)
 * Visibility of Features : 기능 가시성
 * What’s in a (Pattern) Name? : (패턴) 이름에는 무엇이 들어있나? 
 * Why Do We Need 100 Customers? : 100 명의 고객이 왜 필요합니까?
 * Write the Tests First : 테스트를 먼저 작성하라
 * Wrong Test Automation Strategy : 잘못된 테스트 자동화 전략
 * absolute assertions : 절대 단언문
 * acceptance test : 인수 테스트
 * accessor : 접근자
 * action word : 행동 단어
 * active object : 액티브 객체
 * actual object : 실제 객체?
 * adapter : 어댑터[GOF]
 * annotation, annotations : 어노테이션
 * anonymous inner class : 익명 내부 클래스
 * application : 프로그램, 애플리케이션, 어플리케이션, 응용 프로그램
 * architectural requirements : 비기능 요구사항
 * aspect-oriented programming (AOP) : 관점지향 프로그래밍(AOP)
 * assembly : 어셈블리, .NET Assembly 를 얘기하는 듯 (http://falconer.tistory.com/368)
 * assert : 단언
 * assertion : 단언문
 * assertion failures : 단언 실패
 * asset : 자산?
 * asynchronous method : 비동기 메소드
 * asynchronous test : 비동기 테스트
 * at some point : 어디에서는, 어떨 때는, 나중에
 * attribute, attributes : 어트리뷰트(C# 문법에서 쓰일 경우), 멤버변수(를 뜻 할 경우), 특성(XML 의 경우)
 * automated test behavior smells : 자동 테스트 동작 냄새
 * automated unit test, automated unit testing : 자동 단위 테스트
 * automatic method skeleton generation : 자동 메소드 뼈대 생성
 * back side : 뒷면
 * back-country skiing : 백 컨트리 스키
 * back-end : 백 앤드
 * backward compatibility : 하위 호환성
 * baseline : 베이스라인
 * basic test set : 기저 테스트 집합
 * before picture : 이전 상황
 * behave : 동작
 * behavior : 동작
 * behavior smell, behavior smells : 동작 냄새
 * behavior-driven development : 행위 주도 개발?? 동작 주도 개발??
 * behaviorist : 동작주의자? 동작주의자??
 * big Fixture design upfront : 미리 큰 픽스처 설계하기, 미리 골조 설계하기
 * block : 블록
 * body : 본문, 본체, 몸통
 * bookends : 책버팀, 북엔드
 * bootstrapping : 부트스트랩핑
 * boundary condition : 경계조건
 * boundary value, boundary values : 경계값
 * breakpoint : 중단점
 * bug tracking system : 버그 추적 시스템
 * build-time : 빌드 시간, 빌드 타임
 * business person : 사업팀?? 사업가
 * business users : 비지니스 부서 직원, 영업사원, 영업직 사람, 영업팀 사람, 사업팀, 사업팀 직원, 담당 부서 직원
 * cascading failures : 연쇄 실패
 * casting : 형변화
 * cause-effect : 인과
 * change control : 변경 제어
 * check-in test suite : 체크인 테스트 스위트
 * class attribute : 클래스 어트리뷰트
 * class variable : 클래스 변수(C++ 의 static 멤버변수)
 * classname qualifier : 클래스 한정어
 * code coverage : 코드 커버리지
 * code smell : 코드 냄새
 * coding idiom : 코딩 관용구
 * collection : 컬렉션
 * column : 컬럼
 * command line : 명령행
 * compile time : 컴파일 시
 * component test, Component Tests : 컴포넌트 테스트
 * concrete class : 구체 클래스
 * concrete test case : 구체적 테스트 케이스(용어집)
 * concurrency : 동시성
 * configuration : 형상
 * configuration data : 설정 데이터
 * configuration facade : 설정 퍼사드
 * conformance test : 일치 테스트, 적합성 테스트
 * connection : 환승(공항에서의)
 * context : 문맥
 * control point, control points : 제어 위치
 * control structure : 제어 구조
 * control structures : 제어문
 * controllability : 제어성
 * coverage : 커버리지
 * crash : 크래시
 * cross reference : (같은 책 속의) 상호 참조. 
 * cross section : 횡단면
 * cross-cutting concern : 공통 관심 사항 ( 핵심 관심 사항. core concern)), 횡단 관심사
 * cross-referencing tags : 상호 참조 태그
 * curly braces : 중괄호
 * customer test, customer tests : 고객 테스트
 * cut and run : 지우고 계속 진행하기
 * cyclical dependency graph : 순환 의존 그래프
 * daily integration build : 일일 통합 빌드
 * data abstraction layer : 데이터 추상화 레이어, 데이터 추상화 계층,
 * data access layer : 데이터 접근 레이어
 * data configuration : 데이터 설정
 * data export : 데이터 내보내기
 * data flow : 데이터 흐름분석
 * data store : 데이터 저장공간
 * data-driven behavior : 데이터 주도 동작
 * database rows : 데이터베이스 로우
 * dead code : 죽은 코드
 * declarative : 이해하기 쉬운, 설명문
 * decouple : 분리, 디커플링, 결합도 줄이기
 * deep copy : 깊은 복사
 * defect density : 결함 빈도
 * degenerate form : 변형
 * delivery : 인도
 * depended-on class : 의존 클래스
 * depended-on objects : 의존 객체
 * dependency substitution mechanisms : 의존 대체 방식(의존 대체 메커니즘)
 * dependency-breaking : 의존 깨기
 * deprecated : 폐기
 * descriptive : 내용을 설명하는, 이해를 도와주는
 * design-for-testability : 테스트하기 쉬운 설계, 테스트용이성을 위한 설계? 박일
 * deterministic : 결정되어 있는, 정한대로 돌아가는
 * deterrent : 단념하게 하는, 방해하는
 * developer test, developer tests : 개발자 테스트
 * diagramming notation : 도표 표기법
 * direct input : 직접 입력
 * direct output : 출력(직접 출력)
 * disable : 비활성, 안 되다
 * disambiguation : 중의성 해소.
 * diversion : 분기
 * document-driven development : 문서 주도 개발
 * domain layer : 도메인 레이어
 * domain model : 도메인 모델
 * domain object : 도메인 객체
 * domain-specific testing language : 도메인에 특화된 테스트용 언어
 * double precision : 배정밀도
 * down-range velocity : 비행방향 속도?
 * drill down : 타고 들어가기, 세부목록으로
 * drive : 진행
 * duality : 이중성, 이원성. (duality of light : 빛의 이중성)
 * dynamic : 동작
 * dynamic analysis : 동적분석
 * dynamic binding : 동적 바인딩
 * dynamic languages : 동적 언어
 * dynamic linked library, dynamic linked libraries : 동적 연결 라이브러리(DLL)
 * dynamically typed languages : 동적 타입 언어
 * eXtreme Programming : 익스트림 프로그래밍
 * eager class : 욕심쟁이 클래스
 * early day : 초창기
 * edit check : A program instruction or subroutine that tests the validity of input in a data entry program. Also known as edit test.
 * editor : 편집기
 * effectively : 효과적으로, 사실상
 * element : 요소(XML 에서)
 * emergent design : 창발적 설계
 * emulator : 에뮬레이터
 * end-to-end tests : 종단(縱斷) 테스트
 * end-user test : 최종 사용자 테스트
 * ending state : 종료 상태
 * entity : 엔터티, 개체
 * entity object : 엔티티 객체
 * entry criteria : 시작 조건
 * equals method : equals 메소드
 * equivalence class : 동등 클래스
 * error scenario, error scenarios : 오류 시나리오
 * error seeding :  오류 유입(용어집)
 * essential but irrelevant : 필수적이지만 일반적인???? 꼭 필요하긴 해도 관련없는
 * everything but the kitchen sink : 없는 거 빼고 전부 다
 * evocatively named : ???
 * evolve : 다듬어지다, 전개되다, 발전되다. 진화하다
 * examble resolved : 예제 심화
 * example-driven development : 예제 주도 개발
 * executable - 실행기? Java쪽 언어로 확인 필요
 * exercise SUT phase : SUT 실행 단계
 * exit point : 종료 지점(용어집)
 * expected outcome : 기대 결과값
 * expected results : 기대 결과값
 * expected table : 기대 표
 * expected value : 기대값
 * expensive operation : 비용이 많이 드는 조작
 * expressiveness gap : 표현에 있어서의 간극
 * extended cost : 확장 비용??
 * extended double precision : 확장 배정밀도
 * extra-functional property : 추가기능 속성
 * extra-functional test : 추가기능 테스트
 * factor : 요인
 * failure mode : 장애 모드(용어집)
 * faked-out : 가짜로 교체할 수 있는
 * false negative, false-negative : 거짓 음성, 잘못된 것이 있는데 발견하지 못함
 * false pass : 거짓 통과
 * false positive, false-positive : 거짓 양성, 진단오류, 긍정 오류, 뭔가 발견은 했으나 사실 잘못된 것이 없음, 위양성
 * false sense of security : 거짓으로 안심시키다
 * false-fail result : 위조-실패 결과(용어집)
 * fault : 잘못, 실패
 * fault insertion test, Fault Insertion Tests : 실패 주입 테스트
 * feasible path : 실행 가능 경로(용어집)
 * feature : 기능
 * field testing : 현장 테스팅
 * find and replace : 찾아서 고치기
 * finishing point : 도착점
 * first-class objects, firstclass objects : 1등 객체
 * fixture holding instance variable : 인스턴스 변수에 들어 있는 픽스처
 * fixture holding local variable : 지역 변수에 들어 있는 픽스처
 * flat file : 플랫파일
 * floating-point : 부동 소수점 숫자
 * fluent Configuration Interface : 유연한 설정 인터페이스
 * foreign key constraints : 외래키 제한
 * form-based input : 폼 형식의 입력?
 * formal review : 공식 리뷰
 * formal test : 공식 테스트
 * format : 형식, 포맷
 * forward recovery : 순방향 복구
 * four sensitivities : 4 가지 민감함
 * front door Fixture setup : 정문 픽스처 설치, 정문보다 앞문? 대문? (뒷문과 대구를 맞추기 위해)
 * front-end : 프론트 앤드
 * full test coverage : 완전 테스트 커버리지
 * fully abstract class : 완전 추상 클래스
 * fully qualify name : 완전한 이름, 정규화된 이름, FQN 
 * function pointer : 함수 포인터
 * functional tests : 기능 테스트
 * functionality : 기능성
 * garbage collection : 가비지 컬렉션
 * generative :  생성적인
 * generic : 일반화, 일반적
 * global variable : 전역 변수
 * going in the front door : 정문으로 들어가기
 * golden database : 완벽한 데이터베이스
 * granularity : 정밀도, 입도(粒度. 암석이나 퇴적물을 구성하는 주요 광물 입자의 평균적인 크기). 다른 용어는? 정교성? 세분화? 성김도?
 * graphical user interface : 그래픽 사용자 인터페이스
 * gross over : 겉꾸리다, 얼버무리다
 * hand-coded : 직접 코딩한
 * hang : 응답없음
 * happy path : 주요 경로, 주경로, 주요 흐름??
 * harder-to-test : 테스트하기-힘든
 * harness : 하네스
 * healthy : 견고한
 * high latency : 응답이 느림
 * horizontal line, horizontal lines : 가로선
 * housekeeping : 시스템 뒷정리
 * identifier : 식별자
 * identifycation : 식별
 * implementation variation, implementation variations : 구현 변형
 * implementer : (인터페이스) 구현자
 * in-memory : 메모리에 있는, 메모리상의, 메모리전용
 * in-memory fixture : 메모리상의 픽스처
 * incomplete assertions : 불완전한 단언문
 * increment : 증분
 * incremental development : 점진 개발
 * indirect input, indirect inputs : 간접 입력
 * indirect output, indirect outputs : 간접 출력
 * indirect testing : 간접 테스팅
 * individual class : 개별 클래스
 * individual test : 단일 테스트
 * infrastructure : 기반 구조
 * inner class, inner classes : 내부 클래스
 * instance method : 인스턴스 메소드
 * integrated development environment (IDE) : 통합 개발 환경
 * integration tests : 통합 테스트
 * integration token : main branch 로의 통합을 한 명만 할 수 있도록, 통합하기 전에 쥐고 있어야 하는 토큰. single-check out 개념.  An Integration Token is a single physical object used to determine who has the authority to integrate code into the main build of a software project at any given time. 
 * interact : 상호작용, 접근
 * interaction point : 상호작용 위치
 * interaction testing : 상호작용 테스팅
 * interactive debugger : 상호 작용하는 디버깅
 * intermediary : 중계자
 * intermediate object : 중간 객체
 * inversion of control (IOC) : 제어 역전(IOC)
 * invoice : 송장
 * iterative development : 반복적 개발
 * just-in-time design : 적시 설계
 * just-in-time manufacturing : 적시 생산
 * known use : 용례
 * lack : 랙
 * language-specific : 언어 종속
 * large-grain, large-grained : 엉성한??, 거친 입자
 * last resort : 최후의 수단
 * layer-crossing test, layer-crossing tests : 레이어 횡단 테스트 round-trip test)
 * layered archiecture : 레이어 아키텍처[DDD, PEAA, WWW]
 * leftover FIxture : 버려진 픽스처
 * legacy : 레거시
 * legacy software : 레거시 소프트웨어
 * lenient Mock Object : 느슨한 모의 객체, 관대한 모의 객체
 * lightweight database : 경량 데이터베이스
 * literal constant : 리터럴 상수값
 * liveware : 라이브웨어, 사람, 컴퓨터 조작[종사]자(프로그래머, 시스템 분석자 등); 그 두뇌, 라이브웨어
 * mantra : 구호, 만트라, 기도, 진언, 슬로건
 * manual test, manual testing : 수동 테스팅
 * meta object : 메타 객체
 * metatest : 메타 테스트
 * method attribute : 메소드 어트리뷰트
 * metrics : 메트릭
 * micro-layer, micro-layers : 작은 레이어
 * mixin, mix-in, mixed-in : 믹스인
 * mushware : wetware(웻웨어)
 * name-based Test Discovery : 이름 기반 테스트 찾기
 * no pun intended! : 말장난 아님!
 * non-functional requirement : 비기능 요구사항
 * nonconfigurable Dependency Lookup : 설정 안 되는 의존 찾기
 * nonfunctional property : 비기능 속성
 * nonfunctional, non-functional : 비기능적
 * nonproprietary : 비독점, 공용, 국제공용이름(International Nonproprietary Names)
 * nonvisual : 비-비주얼(비가시적)
 * object inspector : 객체 속성창
 * object seams : 객체 이음매, 객체 봉합 (무엇이 좋을까?)
 * object-relational mapping (ORM) : 객체 관계 맵핑
 * observability : 가시성
 * observation point, observation points : 관찰 위치
 * obtuse Fixture setup : 둔한 픽스처 설치(무딘?)
 * on-page scripting : on-page 스크립트
 * operability : 운용성
 * operation : 조작, 작업, 작동
 * out parameter, out-parameter : 출력 인자
 * outbound : 국제선(항공), 주(州) 밖으로 나가는...
 * outgoing interface, outgoing interfaces : 출력 인터페이스
 * outgoing parameter : 출력용 인자
 * over-engineered : 괜히 복잡한
 * over-engineering : 과도한 엔지니어링
 * overhead : 비용, 고생, 부담
 * overlap : 오버랩
 * overview : 개요
 * pair programming : 짝 프로그래밍
 * partially complete : 일부만 완성된, 아직 완성이 안 된, 미완의, 부분적 완전
 * pass-by-reference : 참조자전달
 * pass-by-value : 값전달
 * path : 실행 경로
 * path coverage : 경로 커버리지
 * pattern language : 패턴 언어
 * peer review : 동료검토
 * penetration test : 침투 테스트
 * per-test fixtures : 테스트별 픽스처
 * persistence framework : 지속 프레임워크, 저장 프레임워크
 * persistence layer : 지속 레이어
 * perspective : 입장?
 * playback : 재생
 * point-cut : 포인트 컷(공통 기능 적용 가능 지점(joinpoint) 중에 실제로 적용할 지점을 지정)
 * polymorphism : 다형성
 * post-condition : 후조건 
 * post-exercise state : 실행 후 상태
 * post-test state : 테스트 후 상태
 * postmortem : 포스트모텀
 * postpartum : 포스트팔텀
 * power user : 파워 유저
 * pragmatic programmers : 실용주의 프로그래머(유한 책임 회사 이름)
 * pre-commit suite : 커밋 전 스위트
 * pre-test state : 테스트 전 상태
 * preceding : 선행, 앞선,
 * precondition, pre-condition, pre-conditions  : 선조건
 * presentation framework : 프레젠테이션 프레임워크
 * presentation layer : 프레젠테이션 레이어
 * presentation logic : 프레젠테이션 로직
 * private : private
 * procedure : 프로시저
 * procedure variable, procedure variables : 프로시저 변수(즉, function pointers)
 * process of elimination : 오답 제외
 * production code : 제품 코드
 * progress bar : 진행 막대
 * project smell, Project Smells : 프로젝트 냄새(17장)
 * project smells : 프로젝트 냄새
 * project-level : 프로젝트 단위
 * properties file, property file : 프로퍼티 파일
 * property : 성질
 * protected : protected
 * protocol : 규약
 * public : public
 * pull : 당김
 * pun intended! : 말장난임
 * quality assessment : 품질 평가
 * quality assurance : 품질 보증
 * quality attribute : 품질 속성
 * quality characteristic : 품질 특성
 * record and playback : 기록 후 재생
 * recoverability : 복구성
 * reference : 참조
 * reference count, reference counting : 레퍼런스 관리
 * reflection : 리플렉션
 * regression testing : 회귀 테스팅
 * relational database : 관계형 데이터베이스
 * release : 릴리스
 * repository : 저장소
 * require : 로딩(Ruby에서 include 같은 거)
 * responder : 응답기
 * result verification phase : 결과 검증 단계
 * resulting context : 결과 문맥
 * retrospective : 회고
 * revisit : 다시 수정하다
 * risk of false negatives : 거짓 음성의 위험 
 * robot user : 로봇 사용자
 * root Testcase Superclass : 최상단 테스트케이스 상위클래스
 * round-trip test : 왕복 테스트
 * rounding error : 마무리 오차
 * row fixture : 로우 픽스처
 * rsync : 변한 파일만 업데이트해주는 "동기화"의 개념을 가진 백업 프로그램이 필요한데, 가장 자주 사용하고 쓰기 편한 것
 * rumble strips : 요철 구간
 * runtime : 런타임, 실행시간, 실행 시
 * runtime system : 런타임 시스템
 * safety critical system : 안전 최우선 시스템
 * scheme : ~안 (예 : 조직안)
 * scripted testing : 스크립트 기반 테스팅(용어집)
 * search criteria : 검색 기준
 * section : 절
 * see also : 관련자료
 * self-cleaning : 자체 정리
 * self-consistent : 일관성이 있는
 * self-contained : 독립적인, 자급자족의
 * self-test : 자체 테스트
 * self-verifying : 자체 검증
 * semantics : 의미
 * sensitivity : 감도, 민감도, 예민도
 * sequence number : 일련 번호
 * service component : 서비스 컴포넌트
 * service object : 서비스 객체
 * service-oriented architecture : 서비스 지향 아키텍처
 * setter : 세터
 * severity : 심각도
 * shallow copy : 얕은 복사
 * sheet : 시트(엑셀)
 * side effect : 부수효과, 부작용
 * sidebar : 보충자료
 * sign : 징조
 * signal-to-noise ratio : 신호 대비 잡음비
 * signatures : 시그니처
 * single assertion per Test Method : 테스트메소드별로 하나의 단언문
 * single precision : 단정밀도
 * singleton Singletons : 싱글턴[GOF]
 * slippery slope : 파멸에 이르는 길, 처음에는 잘 보이지만 나중에는 브레이크가 잘 듣지 않게 되는 위험한 코스, 위험한 비탈길 
 * small footprint : 소규모, 크기가 작은, 공간절약형
 * smell : 냄새
 * snapshot : 스냅샷
 * sniff test, sniffability test : 냄새맡기 테스트
 * source code repository : 소스 코드 저장소
 * spec : 명세
 * specialization : 구체화, 특수화
 * specification : 명세
 * spike : 스파이크
 * spreadsheets : 스프레드시트
 * square bracket : 대괄호, 꺾쇠 괄호, []
 * stack trace : 스택 트레이스
 * starburst : 폭죽
 * start state : 시작 상태
 * starting point : 시작점
 * stateful : 상태가 있다
 * stateful object : 상태가 다양한 객체
 * stateless : 상태없음
 * statement coverage : 구문 커버리지, 문장 커버리지
 * statements : 구문, 코드(라고 번역해도 될 듯), 명령문
 * static analysis : 정적 분석
 * static binding : 정적 바인딩
 * static method : 정적 메소드
 * statically typed languages : 정적 타입 언어
 * statist : 상태주의자- 통계를 지향하는 사람
 * storytest : 스토리테스트
 * storytest-driven development : 스토리테스트 주도 개발(STDD)
 * strategic decision : 전략적인 결정
 * strict : 엄격한, 꼼꼼한
 * strict Mock Object : 엄격한 모의 객체
 * strongly typed, strong typing : 강타입
 * structural coverage : 구조적 커버리지
 * stub : 스텁(설계를 테스트하는 동안 코드에서 임시로 만들어 사용하는 부분. from 실용테스트)
 * stub out , stubbing out: 바꿔치다??
 * stunt double : 스턴트 대역
 * subject matter expert, subject matter experts : 내용 전문가(SME), 관련 전문가, 영역 전문가
 * subroutine : 서브루틴
 * substitutable dependency mechanism : 바꿀 수 있는 의존 메커니즘, 의존 대체 방식
 * substitutable initialization test : 바꿀 수 있는 초기화 테스트
 * subsystem tests : 서브시스템 테스트
 * succinctness : 간단한, 간결한
 * synchronous method : 동기 메소드
 * synchronous test : 동기 테스트
 * syntactic sugar : 간편 표기법, 문법 설탕
 * syntax : 구문, 문법
 * system under test (SUT) : 테스트 대상 시스템(SUT)
 * systematic : 체계적인
 * systemic : 시스템적인
 * tab-delimited : 탭으로 구분된
 * table : 테이블, 일람표, 목록(표는 쓰지 말자. 어색하다)
 * task : 테스크
 * teardown : (픽스처) 해체 작업
 * technical people : 엔지니어?, 기술팀 사람들, 기술부서 사람들, 기술직 사람들
 * technical review : 기술검토
 * test automaters : 테스트 개발자, 테스트 자동화 개발자
 * test automation : 자동 테스트
 * test bed : 시험대
 * test case : 테스트 케이스
 * test code smells : 테스트 코드 냄새
 * test condition : 테스트 조건
 * test context : 테스트 문맥
 * test database : 테스트용 데이터베이스
 * test debt : 테스트 빚
 * test driving : 테스트로 개발
 * test error : 테스트 오류
 * test fail : 테스트 실패
 * test failure : 테스트 실패
 * test first : 테스트 먼저
 * test fixture (in NUnit) : test fixture(NUnit 에서의)
 * test fixture (in xUnit) : test fixture(xUnit 에서의)
 * test harness : 테스트 하네스; 테스트를 수행하기 위해 필요한 스텁(stubs) 과 드라이버(drivers) 로 구성된 테스트 환경
 * test infected : 테스트에 중독된, 테스트 중독자
 * test last : 테스트 나중
 * test maintainer : 테스트 유지보수팀, 테스트를 유지보수할 때
 * test package : 테스트 패키지
 * test procedure : 테스트 프로시저, 테스트 실행절차
 * test reader : 테스트를 읽어볼 때, 테스트 독자
 * test recorder : 테스트 기록기
 * test result : 테스트 결과
 * test rig : 테스트 장비
 * test run : 테스트 실행
 * test set : 테스트 모음
 * test smell : 테스트 냄새
 * test stripper : 테스트 제거기
 * test success : 테스트 성공
 * test-driven bug fixing : 테스트 주도 버그 수정
 * test-driven development, Test-Driven Development : 테스트 주도 개발
 * test-friendly : 테스트에 유리한, 테스트하기 좋은??
 * test-infected : 테스트에 중독된, 테스트 중독자
 * test-last development, test last development : 테스트 나중 개발
 * test-specific : 테스트 전용
 * test-specific equivalent : 테스트용 대체물
 * tester : 테스터?
 * testware : 테스트웨어
 * text pane : 텍스트 창
 * the line (path) of least resistance : 가장 무난한 방법(길)
 * time behavior : 시간 반응성(용어집)
 * time-boxing : 시간제한
 * tolerance : 오차, 허용 오차
 * tool : 도구, 툴
 * toolkit : 툴킷
 * top-to-bottom : 하향식
 * traceability : 추적성
 * traceback : 역추적, 트레이스백
 * trade-off : 트레이드오프
 * transactional database : 트랜젝션을 지원하는 데이터베이스 그냥 
 * transition strategy : 변경 전략
 * truth in Advertising :사실광고, 진실한 광고 - 광고속의 진실,광고의 진실
 * try/catch block : try/catch 절
 * type compatibility : 타입 호환성
 * type visibility : 타입 가시성
 * type-compatible, type compatible : 타입 일치
 * unique customers : 고유한 고객
 * unique identifier : 고유 식별자
 * unique key : 유일 키
 * unique key constraint, unique key constraints : 유일 키 제한
 * unqualified references : 그냥 사용, 수식어가 붙지 않은
 * upstream : 업로드??
 * usage patterns : 사용 패턴?
 * user acceptance test, user acceptance testing : 사용자 인수 테스트(용어집), 사용자 승인 테스트(UAT)
 * user interface : 사용자 인터페이스
 * user interface element : 사용자 인터페이스 요소
 * user story : 사용자 스토리
 * value system : 가치 체계
 * variant : 변형, 일종 
 * variation : 변형, 일종, 변이
 * vendor-specific functionality : 벤더 전용 기능
 * verify direct output : 직접 출력 검증
 * version control : 버전 컨트롤 
 * virtual machine : 가상 머신
 * visual : 시각적으로
 * visual classes : 비주얼 클래스
 * visual component : 비주얼 컴포넌트
 * visual layer : 비주얼 레이어
 * warping method : 포장 메소드
 * wave-particle duality : 입자-파동 이중성
 * wetware : 웻웨어. (소프트웨어를 생각해 내는) 인간의 두뇌
 * what it is : 현재 상태
 * what should be : 바람직한 상태
 * whitewater (extreme) kayaking : 급류 카약타기
 * widgets : 위젯
 * work flow : 워크 플로우
 * work their way up the learning curve : 학습곡선을 극복, 학습곡선을 넘기
 * workbook : 통합문서(엑셀의)
 * workspace : 작업공간
 * xUnit Basics : xUnit 기초
 * xUnit Basics Patterns : 19장, xUnit 기본 패턴
 * xUnit Terminology Cross-Reference : xUnit 용어 상호 참조

== 의견 ==
 * Lazy는 의미적으로 '게으른'보다 '지연' 또는 '제때'가 적당한듯 싶습니다.
  * SICP에 'lazy evaluation'이 '제때계산법'으로 번역되어 있엇죠. ^^ [mkkim]
