attachment:theartofcalling_함수호출규약.pdf

== cdecl 호출 규약 ==
cdecl은 C 표준 함수 호출 규약이다. 특별한 지시자가 없으면 모든 C 함수는 기본적으로 cdecl 호출 규약을 사용한다. 파라미터는 오른쪽에서 왼쪽 순서로 스택을 사용해서 전달된다. 스택을 통해 전달한 파라미터는 호출한 곳에서 정리한다. <리스트 2>과 <리스트 3>에 간단한 cdecl 함수와 그것을 호출하는 어셈블리 코드가 나와있다.
{{{
리스트 2 cdecl 함수 
extern "C" int __cdecl CdeclFunc(int a, int b, int c) { 
	printf("%d %d %d\n", a, b, c); 
}
}}}

<리스트 3>를 살펴보자. 파라미터가 오른쪽에서 왼쪽 순서로 스택으로 전달되기 때문에 가장 먼저 push되는 3이 c에 해당한다. 2는 b에, 1은 a에 해당한다. 호출한 곳에서 스택을 정리해야 하기 때문에 자신이 push한 것들을 제거해 주어야 한다. pop을 통해서 비울 수 있지만 그렇게 할 경우에는 호출할 때의 들어간 인자만큼 pop을 해 주어야 하기 때문에 비효율적이다. 보통은 <리스트 3>에 나타난 것과 같이 esp를 직접 조작해서 스택을 비운다.
{{{
리스트 3 CdeclFunc를 호출하는 어셈블리 코드 
push 3 
push 2 
push 1 
call CdeclFunc
add esp, 12 
}}}

cdecl 규약의 가장 큰 특징은 가변 인자를 지원한다는 것이다. 가변 인자 함수란 파라미터를 정해진 개수가 아닌 가변적으로 전달하는 것을 말한다. printf가 대표적인 함수다. cdecl 호출 규약이 가변 인자 함수를 지원할 수 있는 이유는 호출한 곳에서 스택을 정리하기 때문이다. 스택에 인자를 넣은 곳에서 제거 하기 때문에 자신이 인자를 얼마나 전달했는지 정확하게 알 수 있고, 그 정보를 토대로 정확하게 삭제할 수 있는 것이다.


== stdcall 호출 규약 ==
stdcall은 윈도우의 표준 함수 호출 규약이다. 특별한 표기가 없는 한 대부분의 API는 모두 이 호출 규약을 사용한다. stdcall은 cdecl과 마찬가지로 스택을 통해서 오른쪽에서 왼쪽 순서로 파라미터를 전달한다. 단지 차이가 있다면 cdecl은 호출한 곳에서 스택을 정리하지만 stdcall은 호출을 당한 함수 내부에서 스택을 정리한다는 점이다. <리스트 4>에는 간단한 stdcall 함수가 <리스트 5>에는 그것을 호출하는 어셈블리 코드가 나와있다.
{{{
리스트 4 stdcall 함수 
extern "C" int __stdcall StdcallFunc(int a, int b, int c) { 
	printf("%d %d %d\n", a, b, c); 
}
}}}

Visual C++의 경우 stdcall을 사용하는 함수에 대해서는 <리스트 5>에 나타난 것과 같이 함수 이름을 장식한다. 앞쪽에 언더스코어를 붙이고, 뒤쪽에 @와 함께 인자의 바이트 수를 적어준다. StdcallFunc는 4바이트 인자 세 개를 받기 때문에 12가 붙는다.
{{{
리스트 5 StdcallFunc를 호출하는 어셈블리 코드 
push 3 
push 2 
push 1 
call _StdcallFunc@12
}}}

<리스트 6>에 StdcallFunc의 어셈블리 리스트가 나와있다. stdcall 호출 규약에서는 스택 정리를 함수 내부에서 한다고 했다. 함수 마지막에 있는 ret 12가 스택을 정리하는 역할을 한다. x86 어셈블리에서는 ret 다음에 숫자를 적어주면 그 만큼 스택을 비운 다음 리턴한다. 이러한 특징 때문에 stdcall 함수는 cdecl에 비해 두 가지 장점을 가진다. 수행 속도와 코드 크기가 그것이다. ret, add 명령어를 수행하는 것보다 ret 명령어를 한번 수행하는 것이 속도가 더 빠르다. 그리고 함수를 호출할 때마다 매번 add 명령어가 붙지 않기 때문에 프로그램의 전체 크기도 줄일 수 있다.
{{{
리스트 6 StdcallFunc 어셈블리 리스트 
PUBLIC _StdcallFunc@12 
_TEXT SEGMENT 
_a$ = 8 
_b$ = 12 
_c$ = 16 
_StdcallFunc@12 PROC NEAR 
	push ebp 
	mov ebp, esp 
	... 중략 ... 
	pop ebp 
	ret 12 
_StdcallFunc@12 ENDP 
_TEXT ENDS
}}}

== fastcall 호출 규약 ==
fastcall은 이름처럼 빠른 실행을 위한 호출 규약이다. fastcall이 빠른 이유는 파라미터의 일부를 레지스터를 사용해서 전달하기 때문이다. x86 계열에서는 일반적으로 ecx, edx로 두 개의 파라미터를 전달하고, 나머지는 스택으로 전달한다. 파라미터는 오른쪽에서 왼쪽으로 전달되고, 스택 정리는 호출되는 함수 내부에서 한다. 
{{{
리스트 7 fastcall 함수
extern "C" int __fastcall FastcallFunc(int a, int b, int c) { 
	printf("%d %d %d\n", a, b, c); 
}
}}}

<리스트 8>에 보이는 것처럼 fastcall 함수도 이름 장식이 된다. stdcall과 다른 점은 앞쪽에 언더스코어(_)가 아닌 @가 붙는다는 점이다. 앞 쪽 두 개의 파라미터가 ecx와 edx를 통해 전달되는 것을 볼 수 있다.
{{{
리스트 8 FastcallFunc를 호출하는 어셈블리 코드 
push 3 
mov edx, 2 
mov ecx, 1 
call @FastcallFunc@12
}}}

불행하게도 fastcall 함수가 이름만큼 굉장히 빠르지는 않다. 인자의 개수가 두 개를 넘어서면 다른 호출 규약과 마찬가지로 스택을 사용하고, 인자의 개수가 두 개 이하라고 하더라도 함수가 복잡한 경우에는 인자 값을 다시 스택에 저장해야 하기 때문이다. fastcall 함수가 속도적인 측면에서 이득을 볼 수 있는 경우는 인자의 개수가 두 개 이하인 간단한 함수에서이다.

== thiscall 호출 규약 ==
thiscall은 C++의 멤버 함수를 위한 호출 규약이다. 기본적인 원칙은 stdcall과 동일하고, 추가적으로 ecx를 통해서 this 포인터를 전달한다는 특징이 있다. 멤버 함수에 특별한 호출 규약을 지정하지 않으면 thiscall이 사용된다. <리스트 9>에는 간단한 thiscall 함수가, <리스트 10>에는 그것을 호출하는 어셈블리 코드가 나와있다.
{{{
리스트 9 thiscall 함수
class CCallConv { 
	public: 
	int ThisCall(int a, int b, int c); 
}; 

int CCallConv::ThisCall(int a, int b, int c) {
	return printf("%d %d %d\n", a, b, c);
}
}}}

{{{
리스트 10 ThisCall 함수를 호출하는 어셈블리 코드
push 3
push 2
push 1
lea ecx, conv
call CCallConv::ThisCall
}}}

그렇다면 멤버함수에 다른 호출 규약을 지정하면 어떻게 될까? 그냥 지정된 호출 규약이 사용된다. 이 경우에 this 포인터는 첫 번째 인자로 전달된다.

지금까지 언급한 함수 호출 규약 별 특징이 <표 1>에 나와있다. “인자 전달 순서나 리턴 값을 다르게 처리하는 호출 규약도 있나요?”라고 물어보시는 분들이 종종 있다. 인자를 왼쪽에서 오른쪽으로 전달하는 방식은 볼랜드의 호출 규약 쪽에 많이 있다. 또한 과거 Visual C++이 지원했던 pascal 호출 규약도 왼쪽에서 오른쪽으로 전달한다. 그리고 EAX를 사용하지 않는 호출 규약에 대해서는 필자도 아직까지 들어 본적이 없다. 보다 많은 호출 규약에 관한 정보를 알고 싶다면 참고 자료에 있는 함수 호출 규약에 관한 위키 페이지를 참고하자.

표 1 함수 호출 규약 별 특징
|| 호출 규약 || 인자 전달 순서 || 인자 전달 방법 || 인자 파괴 위치 || 리턴 값 || 특징 ||
|| cdecl || 오른쪽에서 왼쪽  || 스택 || 호출한 곳 || EAX, fp0(부동 소수) || 가변 인자를 지원한다. ||
|| stdcall || 오른쪽에서 왼쪽 || 스택 || 호출된 곳 || EAX, fp0(부동 소수) || Windows 표준 호출 규약이다. ||
|| fastcall || 오른쪽에서 왼쪽 || 레지스터, 스택 || 호출된 곳 || EAX. fp0(부동 소수) || 처음 두 개의 인자를 ECX, EDX를 통해 전달하기 때문에 빠르다. ||
|| thiscall || 오른쪽에서 왼쪽 || 레지스터, 스택 || 호출된 곳 || EAX, fp0(부동 소수) || ECX를 통해 this 포인터를 전달한다. ||

== x64 호출 규약 ==
64비트 환경으로 넘어오면서 함수의 호출 규약도 크게 변경되었다. 가장 큰 변화라면 앞서 소개한 네 가지 호출 규약을 통일해서 단일 호출 규약으로 만들었다는 점이다. 64비트 환경에서는 앞서 소개한 호출 규약을 지정하는 지시자인 __cdecl, __stdcall, __fastcall, __thiscall은 모두 무시되고, 64비트의 호출 규약을 사용하는 함수로 컴파일된다. 64비트 호출 규약은 앞서 소개한 __fastcall 호출 규약과 유사하다. 단지 동작 방식이 그것보다는 다소 복잡하다는 점이 특징이다.

64비트 호출 규약은 파라미터를 전달하기 위해서 지정된 네 개의 레지스터와 스택을 사용한다. RCX, RDX, R8D, R9D 레지스터를 앞 쪽 네 개의 인자를 위해서 사용한다. 인자가 실수인 경우에는 XMM0, XMM1, XMM2, XMM3이 사용된다. 네 개를 넘어서는 인자들은 __fastcall과 마찬가지로 스택을 통해서 전달된다. <리스트 11>에 이러한 특성이 잘 나와있다.
{{{
리스트 11 64비트 호출 규약을 사용하는 함수들 
// a는 RCX, b는 RDX, c는 R8, d는 R9, e는 스택을 통해 전달된다. 
func1(int a, int b, int c, int d, int e); 

// a는 XMM0, b는 XMM1, c는 XMM2, d는 XMM3, e는 스택을 통해 전달된다. 
func2(float a, double b, float c, double d, float e); 

// a는 RCX, b는 XMM1, c는 R8, d는 XMM3를 통해 전달된다. 
func3(int a, double b, int c, float d); 

// a는 RCX를 통해 전달된다. 
func4(int a);
}}}

64비트 호출 규약이 __fastcall과 다른 점은 레지스터를 통해 전달하는 변수에 대한 것까지 스택 공간을 할당해야 한다는 점이다. <리스트 11>의 함수에서 func1은 40(5*8)바이트의 스택 공간을 필요로 하고, func3은 32(4*8)바이트의 스택 공간을 필요로 한다. 여기에 덧붙여 인자의 개수가 네 개 이하인 함수에 대해서는 모두 기본적으로 32바이트의 공간을 할당해야 한다. 따라서 func4 함수에 필요한 스택 공간도 32바이트가 된다. 레지스터에 저장된 값을 보관할 스택을 별도로 두는 이유는 함수 내부에서 해당 레지스터를 사용하고자 할 때, 값을 보관하기 쉽도록 하기 위해서다. 
리턴 값이 64비트에 저장될 수 있는 경우에는 RAX를 통해 반환되며, 실수 타입인 경우에는 XMM0를 통해서 반환된다. 만약 리턴 값을 64비트에 저장할 수 없다면 호출하는 곳에서 해당 리턴 값에 대한 포인터를 첫 번째 인자로 전달해야 한다.
스택 정리는 호출한 곳에서 한다. 그런데 특이한 점은 스택 정리를 함수 호출을 할 때마다 하지 않는다는 것이다. 컴파일러는 해당 지역에서 호출되는 함수 중에 가장 많은 인자를 필요로 하는 함수에 맞추어 스택을 할당한 다음 해당 스택 공간을 지속적으로 활용한다. 그리고 함수가 끝나기 직전에 한번만 스택을 정리해 준다. 스택 포인터(RSP)를 조작하는 일이 빈번하지 않기 때문에 근소한 속도 향상을 가져온다고 할 수 있다. <리스트 12>는 앞서 나온 func1과 func4를 호출하는 코드로 이러한 특징을 잘 보여준다.
{{{
리스트 12 func1과 func4를 호출하는 어셈블리 코드 
main PROC 
	sub rsp, 40 
	
; func1(1,2,3,4); 
	mov r9d, 4 
	mov r8d, 3 
	mov edx, 2 
	mov ecx, 1 
	call func1 
	
; func4(1); 
	mov ecx, 1 
	call func4 
	
; return 0; 
	xor eax, eax 
	
	add rsp, 40 
	ret 0 
	
main ENDP
}}}
